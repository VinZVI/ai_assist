W292 [*] No newline at end of file
  --> app\__init__.py:12:88
   |
10 | __version__ = "0.1.0"
11 | __title__ = "AI-Компаньон"
12 | __description__ = "Telegram-бот для эмоциональной поддержки с интеграцией DeepSeek API"
   |                                                                                        ^
   |
help: Add trailing newline

F821 Undefined name `MagicValues`
   --> app\config.py:112:20
    |
110 |     def validate_temperature(cls, v: float) -> float:
111 |         """Валидация температуры генерации."""
112 |         min_temp = MagicValues.DEEPSEEK_MIN_TEMPERATURE
    |                    ^^^^^^^^^^^
113 |         max_temp = MagicValues.DEEPSEEK_MAX_TEMPERATURE
114 |         if not min_temp <= v <= max_temp:
    |

F821 Undefined name `MagicValues`
   --> app\config.py:113:20
    |
111 |         """Валидация температуры генерации."""
112 |         min_temp = MagicValues.DEEPSEEK_MIN_TEMPERATURE
113 |         max_temp = MagicValues.DEEPSEEK_MAX_TEMPERATURE
    |                    ^^^^^^^^^^^
114 |         if not min_temp <= v <= max_temp:
115 |             raise ValueError(ConfigErrorMessages.INVALID_DEEPSEEK_TEMPERATURE)
    |

F821 Undefined name `MagicValues`
   --> app\config.py:122:22
    |
120 |     def validate_max_tokens(cls, v: int) -> int:
121 |         """Валидация максимального количества токенов."""
122 |         min_tokens = MagicValues.DEEPSEEK_MIN_MAX_TOKENS
    |                      ^^^^^^^^^^^
123 |         max_tokens = MagicValues.DEEPSEEK_MAX_MAX_TOKENS_DEEPSEEK
124 |         if v < min_tokens or v > max_tokens:
    |

F821 Undefined name `MagicValues`
   --> app\config.py:123:22
    |
121 |         """Валидация максимального количества токенов."""
122 |         min_tokens = MagicValues.DEEPSEEK_MIN_MAX_TOKENS
123 |         max_tokens = MagicValues.DEEPSEEK_MAX_MAX_TOKENS_DEEPSEEK
    |                      ^^^^^^^^^^^
124 |         if v < min_tokens or v > max_tokens:
125 |             raise ValueError(ConfigErrorMessages.INVALID_DEEPSEEK_MAX_TOKENS)
    |

F821 Undefined name `MagicValues`
   --> app\config.py:174:20
    |
172 |     def validate_temperature(cls, v: float) -> float:
173 |         """Валидация температуры генерации."""
174 |         min_temp = MagicValues.OPENROUTER_MIN_TEMPERATURE
    |                    ^^^^^^^^^^^
175 |         max_temp = MagicValues.OPENROUTER_MAX_TEMPERATURE
176 |         if not min_temp <= v <= max_temp:
    |

F821 Undefined name `MagicValues`
   --> app\config.py:175:20
    |
173 |         """Валидация температуры генерации."""
174 |         min_temp = MagicValues.OPENROUTER_MIN_TEMPERATURE
175 |         max_temp = MagicValues.OPENROUTER_MAX_TEMPERATURE
    |                    ^^^^^^^^^^^
176 |         if not min_temp <= v <= max_temp:
177 |             raise ValueError(ConfigErrorMessages.INVALID_OPENROUTER_TEMPERATURE)
    |

F821 Undefined name `MagicValues`
   --> app\config.py:184:22
    |
182 |     def validate_max_tokens(cls, v: int) -> int:
183 |         """Валидация максимального количества токенов."""
184 |         min_tokens = MagicValues.OPENROUTER_MIN_MAX_TOKENS
    |                      ^^^^^^^^^^^
185 |         max_tokens = MagicValues.DEEPSEEK_MAX_MAX_TOKENS_OPENROUTER
186 |         if v < min_tokens or v > max_tokens:  # OpenRouter поддерживает больше токенов
    |

F821 Undefined name `MagicValues`
   --> app\config.py:185:22
    |
183 |         """Валидация максимального количества токенов."""
184 |         min_tokens = MagicValues.OPENROUTER_MIN_MAX_TOKENS
185 |         max_tokens = MagicValues.DEEPSEEK_MAX_MAX_TOKENS_OPENROUTER
    |                      ^^^^^^^^^^^
186 |         if v < min_tokens or v > max_tokens:  # OpenRouter поддерживает больше токенов
187 |             raise ValueError(ConfigErrorMessages.INVALID_OPENROUTER_MAX_TOKENS)
    |

W291 [*] Trailing whitespace
   --> app\config.py:225:41
    |
223 |         if v < min_retries or v > max_retries:
224 |             message = ConfigErrorMessages.INVALID_AI_PROVIDER_RETRIES_FORMAT.format(
225 |                 min_retries=min_retries, 
    |                                         ^
226 |                 max_retries=max_retries
227 |             )
    |
help: Remove trailing whitespace

E501 Line too long (90 > 88)
   --> app\config.py:248:89
    |
246 |         """Валидация лимита бесплатных сообщений."""
247 |         if v < 0:
248 |             raise ValueError(ConfigErrorMessages.INVALID_FREE_MESSAGES_LIMIT_NON_NEGATIVE)
    |                                                                                         ^^
249 |         return v
    |

ANN204 Missing return type annotation for special method `__init__`
   --> app\config.py:391:9
    |
389 |     rate_limit: RateLimitConfig | None = None
390 |
391 |     def __init__(self, **data):
    |         ^^^^^^^^
392 |         super().__init__(**data)
393 |         # Создаем экземпляры вложенных конфигураций
    |
help: Add return type annotation: `None`

ANN003 Missing type annotation for `**data`
   --> app\config.py:391:24
    |
389 |     rate_limit: RateLimitConfig | None = None
390 |
391 |     def __init__(self, **data):
    |                        ^^^^^^
392 |         super().__init__(**data)
393 |         # Создаем экземпляры вложенных конфигураций
    |

F821 Undefined name `MagicValues`
   --> app\config.py:427:21
    |
425 |         if not v or v == "your_secret_key_here":
426 |             raise ValueError(ConfigErrorMessages.INVALID_SECRET_KEY)
427 |         if len(v) < MagicValues.MIN_SECRET_KEY_LENGTH:
    |                     ^^^^^^^^^^^
428 |             raise ValueError(ConfigErrorMessages.SECRET_KEY_TOO_SHORT)
429 |         return v
    |

PLW0603 Using the global statement to update `_config_instance` is discouraged
   --> app\config.py:445:12
    |
443 | def get_config() -> AppConfig:
444 |     """Получение экземпляра конфигурации приложения."""
445 |     global _config_instance
    |            ^^^^^^^^^^^^^^^^
446 |
447 |     if _config_instance is None:
    |

PLW0603 Using the global statement to update `_config_instance` is discouraged
   --> app\config.py:445:12
    |
443 | def get_config() -> AppConfig:
444 |     """Получение экземпляра конфигурации приложения."""
445 |     global _config_instance
    |            ^^^^^^^^^^^^^^^^
446 |
447 |     if _config_instance is None:
    |

RUF002 Docstring contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
 --> app\constants.py:3:37
  |
1 | """
2 | @file: constants.py
3 | @description: Константы и сообщения об ошибках для всего приложения
  |                                     ^
4 | @created: 2025-09-27
5 | """
  |

RUF002 Docstring contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
 --> app\constants.py:3:38
  |
1 | """
2 | @file: constants.py
3 | @description: Константы и сообщения об ошибках для всего приложения
  |                                      ^
4 | @created: 2025-09-27
5 | """
  |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
 --> app\constants.py:7:13
  |
5 | """
6 |
7 | # Сообщения об ошибках для конфигурации
  |             ^
8 | class ConfigErrorMessages:
9 |     """Сообщения об ошибках конфигурации."""
  |

RUF003 Comment contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
 --> app\constants.py:7:14
  |
5 | """
6 |
7 | # Сообщения об ошибках для конфигурации
  |              ^
8 | class ConfigErrorMessages:
9 |     """Сообщения об ошибках конфигурации."""
  |

RUF002 Docstring contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\constants.py:9:18
   |
 7 | # Сообщения об ошибках для конфигурации
 8 | class ConfigErrorMessages:
 9 |     """Сообщения об ошибках конфигурации."""
   |                  ^
10 |     
11 |     # Telegram
   |

RUF002 Docstring contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
  --> app\constants.py:9:19
   |
 7 | # Сообщения об ошибках для конфигурации
 8 | class ConfigErrorMessages:
 9 |     """Сообщения об ошибках конфигурации."""
   |                   ^
10 |     
11 |     # Telegram
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:10:1
   |
 8 | class ConfigErrorMessages:
 9 |     """Сообщения об ошибках конфигурации."""
10 |     
   | ^^^^
11 |     # Telegram
12 |     INVALID_BOT_TOKEN_FORMAT = "BOT_TOKEN must be set to a valid Telegram bot token"
   |
help: Remove whitespace from blank line

S105 Possible hardcoded password assigned to: "INVALID_BOT_TOKEN_FORMAT"
  --> app\constants.py:12:32
   |
11 |     # Telegram
12 |     INVALID_BOT_TOKEN_FORMAT = "BOT_TOKEN must be set to a valid Telegram bot token"
   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     INVALID_BOT_TOKEN_STRUCTURE = "BOT_TOKEN must be in format 'number:hash'"
   |

S105 Possible hardcoded password assigned to: "INVALID_BOT_TOKEN_STRUCTURE"
  --> app\constants.py:13:35
   |
11 |     # Telegram
12 |     INVALID_BOT_TOKEN_FORMAT = "BOT_TOKEN must be set to a valid Telegram bot token"
13 |     INVALID_BOT_TOKEN_STRUCTURE = "BOT_TOKEN must be in format 'number:hash'"
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |     
15 |     # DeepSeek
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:14:1
   |
12 |     INVALID_BOT_TOKEN_FORMAT = "BOT_TOKEN must be set to a valid Telegram bot token"
13 |     INVALID_BOT_TOKEN_STRUCTURE = "BOT_TOKEN must be in format 'number:hash'"
14 |     
   | ^^^^
15 |     # DeepSeek
16 |     INVALID_DEEPSEEK_API_KEY = "DEEPSEEK_API_KEY must be set to a valid API key"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:19:1
   |
17 |     INVALID_DEEPSEEK_TEMPERATURE = "DEEPSEEK_TEMPERATURE must be between 0.0 and 2.0"
18 |     INVALID_DEEPSEEK_MAX_TOKENS = "DEEPSEEK_MAX_TOKENS must be between 1 and 4000"
19 |     
   | ^^^^
20 |     # OpenRouter
21 |     INVALID_OPENROUTER_API_KEY = "OPENROUTER_API_KEY cannot be empty"
   |
help: Remove whitespace from blank line

E501 Line too long (89 > 88)
  --> app\constants.py:22:89
   |
20 |     # OpenRouter
21 |     INVALID_OPENROUTER_API_KEY = "OPENROUTER_API_KEY cannot be empty"
22 |     INVALID_OPENROUTER_TEMPERATURE = "OPENROUTER_TEMPERATURE must be between 0.0 and 2.0"
   |                                                                                         ^
23 |     INVALID_OPENROUTER_MAX_TOKENS = "OPENROUTER_MAX_TOKENS must be between 1 and 8000"
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:24:1
   |
22 |     INVALID_OPENROUTER_TEMPERATURE = "OPENROUTER_TEMPERATURE must be between 0.0 and 2.0"
23 |     INVALID_OPENROUTER_MAX_TOKENS = "OPENROUTER_MAX_TOKENS must be between 1 and 8000"
24 |     
   | ^^^^
25 |     # User Limits
26 |     INVALID_FREE_MESSAGES_LIMIT = "FREE_MESSAGES_LIMIT must be positive"
   |
help: Remove whitespace from blank line

E501 Line too long (89 > 88)
  --> app\constants.py:28:89
   |
26 |     INVALID_FREE_MESSAGES_LIMIT = "FREE_MESSAGES_LIMIT must be positive"
27 |     INVALID_PREMIUM_PRICE = "PREMIUM_PRICE must be positive"
28 |     INVALID_FREE_MESSAGES_LIMIT_NON_NEGATIVE = "FREE_MESSAGES_LIMIT must be non-negative"
   |                                                                                         ^
29 |     
30 |     # Admin
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:29:1
   |
27 |     INVALID_PREMIUM_PRICE = "PREMIUM_PRICE must be positive"
28 |     INVALID_FREE_MESSAGES_LIMIT_NON_NEGATIVE = "FREE_MESSAGES_LIMIT must be non-negative"
29 |     
   | ^^^^
30 |     # Admin
31 |     INVALID_ADMIN_USER_ID = "ADMIN_USER_ID must be positive"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:33:1
   |
31 |     INVALID_ADMIN_USER_ID = "ADMIN_USER_ID must be positive"
32 |     INVALID_ADMIN_USER_ID_POSITIVE = "ADMIN_USER_ID must be a positive integer"
33 |     
   | ^^^^
34 |     # Payment
35 |     INVALID_PAYMENT_PROVIDER = "PAYMENT_PROVIDER must be one of: ['telegram_stars', 'yookassa']"
   |
help: Remove whitespace from blank line

E501 Line too long (96 > 88)
  --> app\constants.py:35:89
   |
34 |     # Payment
35 |     INVALID_PAYMENT_PROVIDER = "PAYMENT_PROVIDER must be one of: ['telegram_stars', 'yookassa']"
   |                                                                                         ^^^^^^^^
36 |     
37 |     # Cache
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:36:1
   |
34 |     # Payment
35 |     INVALID_PAYMENT_PROVIDER = "PAYMENT_PROVIDER must be one of: ['telegram_stars', 'yookassa']"
36 |     
   | ^^^^
37 |     # Cache
38 |     INVALID_CACHE_TTL = "CACHE_TTL must be positive"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:39:1
   |
37 |     # Cache
38 |     INVALID_CACHE_TTL = "CACHE_TTL must be positive"
39 |     
   | ^^^^
40 |     # Rate Limit
41 |     INVALID_RATE_LIMIT_VALUE = "Rate limit values must be positive"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:42:1
   |
40 |     # Rate Limit
41 |     INVALID_RATE_LIMIT_VALUE = "Rate limit values must be positive"
42 |     
   | ^^^^
43 |     # Logging
44 |     INVALID_LOG_LEVEL = "LOG_LEVEL must be one of: ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']"
   |
help: Remove whitespace from blank line

E501 Line too long (101 > 88)
  --> app\constants.py:44:89
   |
43 |     # Logging
44 |     INVALID_LOG_LEVEL = "LOG_LEVEL must be one of: ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']"
   |                                                                                         ^^^^^^^^^^^^^
45 |     
46 |     # Security
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:45:1
   |
43 |     # Logging
44 |     INVALID_LOG_LEVEL = "LOG_LEVEL must be one of: ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']"
45 |     
   | ^^^^
46 |     # Security
47 |     INVALID_SECRET_KEY = "SECRET_KEY must be set to a secure random string"
   |
help: Remove whitespace from blank line

S105 Possible hardcoded password assigned to: "INVALID_SECRET_KEY"
  --> app\constants.py:47:26
   |
46 |     # Security
47 |     INVALID_SECRET_KEY = "SECRET_KEY must be set to a secure random string"
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |     SECRET_KEY_TOO_SHORT = "SECRET_KEY must be at least 32 characters long"
   |

S105 Possible hardcoded password assigned to: "SECRET_KEY_TOO_SHORT"
  --> app\constants.py:48:28
   |
46 |     # Security
47 |     INVALID_SECRET_KEY = "SECRET_KEY must be set to a secure random string"
48 |     SECRET_KEY_TOO_SHORT = "SECRET_KEY must be at least 32 characters long"
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |     
50 |     # AI Provider
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:49:1
   |
47 |     INVALID_SECRET_KEY = "SECRET_KEY must be set to a secure random string"
48 |     SECRET_KEY_TOO_SHORT = "SECRET_KEY must be at least 32 characters long"
49 |     
   | ^^^^
50 |     # AI Provider
51 |     INVALID_AI_PROVIDER = "Provider must be one of: ['deepseek', 'openrouter']"
   |
help: Remove whitespace from blank line

E501 Line too long (118 > 88)
  --> app\constants.py:52:89
   |
50 |     # AI Provider
51 |     INVALID_AI_PROVIDER = "Provider must be one of: ['deepseek', 'openrouter']"
52 |     INVALID_AI_PROVIDER_RETRIES_FORMAT = "AI_MAX_RETRIES_PER_PROVIDER must be between {min_retries} and {max_retries}"
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
53 |
54 | # Магические значения для конфигурации
   |

W293 [*] Blank line contains whitespace
  --> app\constants.py:57:1
   |
55 | class ConfigMagicValues:
56 |     """Магические значения, используемые в конфигурации."""
57 |     
   | ^^^^
58 |     # DeepSeek
59 |     DEEPSEEK_DEFAULT_TEMPERATURE = 0.7
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:66:1
   |
64 |     DEEPSEEK_MIN_MAX_TOKENS = 1
65 |     DEEPSEEK_MAX_MAX_TOKENS_DEEPSEEK = 4000
66 |     
   | ^^^^
67 |     # Database
68 |     DATABASE_DEFAULT_POOL_SIZE = 10
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:71:1
   |
69 |     DATABASE_DEFAULT_TIMEOUT = 30
70 |     DATABASE_DEFAULT_PORT = 5432
71 |     
   | ^^^^
72 |     # OpenRouter
73 |     OPENROUTER_DEFAULT_TIMEOUT = 30
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:80:1
   |
78 |     OPENROUTER_MIN_MAX_TOKENS = 1
79 |     DEEPSEEK_MAX_MAX_TOKENS_OPENROUTER = 8000
80 |     
   | ^^^^
81 |     # User Limits
82 |     DEFAULT_FREE_MESSAGES_LIMIT = 10
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:86:1
   |
84 |     DEFAULT_PREMIUM_DURATION_DAYS = 30
85 |     DEFAULT_ADMIN_USER_ID = 123456789
86 |     
   | ^^^^
87 |     # Cache
88 |     DEFAULT_CACHE_TTL = 3600
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:89:1
   |
87 |     # Cache
88 |     DEFAULT_CACHE_TTL = 3600
89 |     
   | ^^^^
90 |     # Rate Limit
91 |     DEFAULT_RATE_LIMIT_PER_MINUTE = 60
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:93:1
   |
91 |     DEFAULT_RATE_LIMIT_PER_MINUTE = 60
92 |     DEFAULT_RATE_LIMIT_BLOCK_TIME = 300
93 |     
   | ^^^^
94 |     # Security
95 |     MIN_SECRET_KEY_LENGTH = 32
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> app\constants.py:96:1
   |
94 |     # Security
95 |     MIN_SECRET_KEY_LENGTH = 32
96 |     
   | ^^^^
97 |     # AI Provider
98 |     AI_PROVIDER_MAX_RETRIES = 3
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> app\constants.py:100:1
    |
 98 |     AI_PROVIDER_MAX_RETRIES = 3
 99 |     AI_PROVIDER_TIMEOUT = 30
100 |     
    | ^^^^
101 |     # Validation
102 |     AI_PROVIDER_MAX_RETRIES_MIN = 1
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> app\constants.py:103:37
    |
101 |     # Validation
102 |     AI_PROVIDER_MAX_RETRIES_MIN = 1
103 |     AI_PROVIDER_MAX_RETRIES_MAX = 10
    |                                     ^
    |
help: Add trailing newline

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\database.py:3:51
  |
1 | """
2 | @file: database.py
3 | @description: Настройка подключения к базе данных с использованием SQLAlchemy async
  |                                                   ^
4 | @dependencies: sqlalchemy, asyncpg, loguru
5 | @created: 2025-09-12
  |

E501 Line too long (137 > 88)
  --> app\database.py:64:88
   |
63 | …
64 | ….database.database_url.split('@')[1] if '@' in config.database.database_url else 'скрыт'}"
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
65 | …
66 | …
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\database.py:126:39
    |
124 |         logger.error(f"❌ Ошибка при создании базы данных: {e}")
125 |         # Не поднимаем исключение, возможно БД уже существует
126 |         logger.warning("⚠️ Продолжаем с существующей конфигурацией БД")
    |                                      ^
    |

E501 Line too long (102 > 88)
   --> app\database.py:138:89
    |
136 |             result = await session.execute(
137 |                 text(
138 |                     "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'users')"
    |                                                                                         ^^^^^^^^^^^^^^
139 |                 )
140 |             )
    |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> app\database.py:151:29
    |
150 |     except Exception as e:
151 |         logger.warning(f"⚠️ Не удалось проверить таблицы, создаем заново: {e}")
    |                            ^
152 |         await create_tables()
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\database.py:151:30
    |
150 |     except Exception as e:
151 |         logger.warning(f"⚠️ Не удалось проверить таблицы, создаем заново: {e}")
    |                             ^
152 |         await create_tables()
    |

PLW0603 Using the global statement to update `_engine` is discouraged
   --> app\database.py:157:12
    |
155 | async def init_db() -> None:
156 |     """Инициализация базы данных."""
157 |     global _engine, _session_factory
    |            ^^^^^^^
158 |
159 |     try:
    |

PLW0603 Using the global statement to update `_session_factory` is discouraged
   --> app\database.py:157:21
    |
155 | async def init_db() -> None:
156 |     """Инициализация базы данных."""
157 |     global _engine, _session_factory
    |                     ^^^^^^^^^^^^^^^^
158 |
159 |     try:
    |

PLW0603 Using the global statement to update `_engine` is discouraged
   --> app\database.py:184:12
    |
182 | async def close_db() -> None:
183 |     """Закрытие подключения к базе данных."""
184 |     global _engine, _session_factory
    |            ^^^^^^^
185 |
186 |     if _engine:
    |

PLW0603 Using the global statement to update `_session_factory` is discouraged
   --> app\database.py:184:21
    |
182 | async def close_db() -> None:
183 |     """Закрытие подключения к базе данных."""
184 |     global _engine, _session_factory
    |                     ^^^^^^^^^^^^^^^^
185 |
186 |     if _engine:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\database.py:210:15
    |
208 |       """Получение экземпляра движка базы данных."""
209 |       if _engine is None:
210 |           raise RuntimeError(
    |  _______________^
211 | |             "База данных не инициализирована. Вызовите init_db() сначала."
212 | |         )
    | |_________^
213 |       return _engine
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\database.py:211:13
    |
209 |     if _engine is None:
210 |         raise RuntimeError(
211 |             "База данных не инициализирована. Вызовите init_db() сначала."
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
212 |         )
213 |     return _engine
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> app\database.py:219:15
    |
217 |       """Получение фабрики сессий."""
218 |       if _session_factory is None:
219 |           raise RuntimeError(
    |  _______________^
220 | |             "База данных не инициализирована. Вызовите init_db() сначала."
221 | |         )
    | |_________^
222 |       return _session_factory
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\database.py:220:13
    |
218 |     if _session_factory is None:
219 |         raise RuntimeError(
220 |             "База данных не инициализирована. Вызовите init_db() сначала."
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
221 |         )
222 |     return _session_factory
    |
help: Assign to variable; remove string literal

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\database.py:233:26
    |
231 |         async with get_session() as session:
232 |             user = await session.get(User, user_id)
233 |             # ... работа с базой данных
    |                          ^
234 |             await session.commit()
235 |     """
    |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\database.py:269:24
    |
267 |             await conn.run_sync(Base.metadata.create_all)
268 |
269 |         logger.info("✅ Все таблицы созданы успешно")
    |                         ^
270 |
271 |     except Exception as e:
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\database.py:269:25
    |
267 |             await conn.run_sync(Base.metadata.create_all)
268 |
269 |         logger.info("✅ Все таблицы созданы успешно")
    |                          ^
270 |
271 |     except Exception as e:
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\database.py:269:26
    |
267 |             await conn.run_sync(Base.metadata.create_all)
268 |
269 |         logger.info("✅ Все таблицы созданы успешно")
    |                           ^
270 |
271 |     except Exception as e:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\database.py:281:15
    |
280 |     if not config.debug:
281 |         raise RuntimeError("Удаление таблиц разрешено только в debug режиме!")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |
283 |     logger.warning("⚠️ Удаление всех таблиц из базы данных...")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\database.py:281:28
    |
280 |     if not config.debug:
281 |         raise RuntimeError("Удаление таблиц разрешено только в debug режиме!")
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |
283 |     logger.warning("⚠️ Удаление всех таблиц из базы данных...")
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\database.py:290:28
    |
288 |             await conn.run_sync(Base.metadata.drop_all)
289 |
290 |         logger.warning("🗑️ Все таблицы удалены")
    |                           ^
291 |
292 |     except Exception as e:
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\database.py:290:29
    |
288 |             await conn.run_sync(Base.metadata.drop_all)
289 |
290 |         logger.warning("🗑️ Все таблицы удалены")
    |                            ^
291 |
292 |     except Exception as e:
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\database.py:290:30
    |
288 |             await conn.run_sync(Base.metadata.drop_all)
289 |
290 |         logger.warning("🗑️ Все таблицы удалены")
    |                             ^
291 |
292 |     except Exception as e:
    |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> app\handlers\callbacks.py:36:36
   |
34 |     try:
35 |         await callback.message.edit_text(
36 |             "🏠 **Главное меню**\n\nВыберите действие:",
   |                                     ^
37 |             reply_markup=create_main_menu_keyboard(),
38 |             parse_mode="Markdown",
   |

RUF001 String contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
  --> app\handlers\callbacks.py:36:38
   |
34 |     try:
35 |         await callback.message.edit_text(
36 |             "🏠 **Главное меню**\n\nВыберите действие:",
   |                                       ^
37 |             reply_markup=create_main_menu_keyboard(),
38 |             parse_mode="Markdown",
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> app\handlers\callbacks.py:36:39
   |
34 |     try:
35 |         await callback.message.edit_text(
36 |             "🏠 **Главное меню**\n\nВыберите действие:",
   |                                        ^
37 |             reply_markup=create_main_menu_keyboard(),
38 |             parse_mode="Markdown",
   |

RUF001 String contains ambiguous `р` (CYRILLIC SMALL LETTER ER). Did you mean `p` (LATIN SMALL LETTER P)?
  --> app\handlers\callbacks.py:36:40
   |
34 |     try:
35 |         await callback.message.edit_text(
36 |             "🏠 **Главное меню**\n\nВыберите действие:",
   |                                         ^
37 |             reply_markup=create_main_menu_keyboard(),
38 |             parse_mode="Markdown",
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> app\handlers\callbacks.py:36:43
   |
34 |     try:
35 |         await callback.message.edit_text(
36 |             "🏠 **Главное меню**\n\nВыберите действие:",
   |                                            ^
37 |             reply_markup=create_main_menu_keyboard(),
38 |             parse_mode="Markdown",
   |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\handlers\callbacks.py:48:22
   |
46 | @callback_router.callback_query(F.data == "start_chat")
47 | async def start_chat(callback: CallbackQuery) -> None:
48 |     """Начать диалог с ботом."""
   |                      ^
49 |     try:
50 |         await callback.message.edit_text(
   |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\handlers\callbacks.py:54:39
   |
52 |             "Теперь просто напишите мне сообщение, и я отвечу вам. "
53 |             "Я готов выслушать вас и оказать эмоциональную поддержку.\n\n"
54 |             "✨ *Что вас беспокоит или о чём хотели бы поговорить?*",
   |                                        ^
55 |             reply_markup=create_back_button("main_menu"),
56 |             parse_mode="Markdown",
   |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
  --> app\handlers\callbacks.py:69:36
   |
67 |     try:
68 |         if not callback.from_user:
69 |             await callback.answer("Не удалось получить данные пользователя.")
   |                                    ^
70 |             return
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> app\handlers\callbacks.py:69:37
   |
67 |     try:
68 |         if not callback.from_user:
69 |             await callback.answer("Не удалось получить данные пользователя.")
   |                                     ^
70 |             return
   |

PLC0415 `import` should be at the top-level of a file
  --> app\handlers\callbacks.py:73:13
   |
72 |         async with get_session() as session:
73 |             from sqlalchemy import select
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
74 |
75 |             # Получаем пользователя
   |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\handlers\callbacks.py:98:21
    |
 96 | …         f"📈 **Использование:**\n"
 97 | …         f"💬 Сообщений сегодня: {user.daily_message_count}\n"
 98 | …         f"📊 Всего сообщений: {user.total_messages}\n"
    |                ^
 99 | …         f"📅 Последняя активность: {user.last_activity_at.strftime('%d.%m.%Y %H:%M') if user.last_activity_at else 'Неизвестно'}\n"
100 | …     )
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\callbacks.py:98:22
    |
 96 | …         f"📈 **Использование:**\n"
 97 | …         f"💬 Сообщений сегодня: {user.daily_message_count}\n"
 98 | …         f"📊 Всего сообщений: {user.total_messages}\n"
    |                 ^
 99 | …         f"📅 Последняя активность: {user.last_activity_at.strftime('%d.%m.%Y %H:%M') if user.last_activity_at else 'Неизвестно'}\n"
100 | …     )
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\callbacks.py:98:23
    |
 96 | …         f"📈 **Использование:**\n"
 97 | …         f"💬 Сообщений сегодня: {user.daily_message_count}\n"
 98 | …         f"📊 Всего сообщений: {user.total_messages}\n"
    |                  ^
 99 | …         f"📅 Последняя активность: {user.last_activity_at.strftime('%d.%m.%Y %H:%M') if user.last_activity_at else 'Неизвестно'}\n"
100 | …     )
    |

RUF001 String contains ambiguous `г` (CYRILLIC SMALL LETTER GHE). Did you mean `r` (LATIN SMALL LETTER R)?
   --> app\handlers\callbacks.py:98:24
    |
 96 | …         f"📈 **Использование:**\n"
 97 | …         f"💬 Сообщений сегодня: {user.daily_message_count}\n"
 98 | …         f"📊 Всего сообщений: {user.total_messages}\n"
    |                   ^
 99 | …         f"📅 Последняя активность: {user.last_activity_at.strftime('%d.%m.%Y %H:%M') if user.last_activity_at else 'Неизвестно'}\n"
100 | …     )
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\callbacks.py:98:25
    |
 96 | …         f"📈 **Использование:**\n"
 97 | …         f"💬 Сообщений сегодня: {user.daily_message_count}\n"
 98 | …         f"📊 Всего сообщений: {user.total_messages}\n"
    |                    ^
 99 | …         f"📅 Последняя активность: {user.last_activity_at.strftime('%d.%m.%Y %H:%M') if user.last_activity_at else 'Неизвестно'}\n"
100 | …     )
    |

E501 Line too long (139 > 88)
   --> app\handlers\callbacks.py:99:88
    |
 97 | …ly_message_count}\n"
 98 | …_messages}\n"
 99 | …last_activity_at.strftime('%d.%m.%Y %H:%M') if user.last_activity_at else 'Неизвестно'}\n"
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 | …
    |

RUF002 Docstring contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\callbacks.py:116:28
    |
114 | @callback_router.callback_query(F.data == "premium_info")
115 | async def show_premium_info(callback: CallbackQuery) -> None:
116 |     """Показать информацию о премиуме."""
    |                            ^
117 |     try:
118 |         config = get_config()
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\callbacks.py:147:55
    |
146 |     except Exception as e:
147 |         logger.error(f"❌ Ошибка при показе информации о премиуме: {e}")
    |                                                        ^
148 |         await callback.answer("Произошла ошибка. Попробуйте еще раз.")
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\callbacks.py:185:30
    |
183 |     try:
184 |         features_text = (
185 |             "💎 **Подробности о премиум функциях**\n\n"
    |                               ^
186 |             "🚀 **Безлимитные сообщения:**\n"
187 |             "• Отправляйте сколько угодно сообщений в день\n"
    |

RUF001 String contains ambiguous `ℹ` (INFORMATION SOURCE). Did you mean `i` (LATIN SMALL LETTER I)?
   --> app\handlers\callbacks.py:221:14
    |
219 |     try:
220 |         help_text = (
221 |             "ℹ️ **Справка и помощь**\n\n"
    |              ^
222 |             "🤖 **О боте:**\n"
223 |             "Я - ваш AI-компаньон для эмоциональной поддержки. "
    |

RUF001 String contains ambiguous `О` (CYRILLIC CAPITAL LETTER O). Did you mean `O` (LATIN CAPITAL LETTER O)?
   --> app\handlers\callbacks.py:222:18
    |
220 | …     help_text = (
221 | …         "ℹ️ **Справка и помощь**\n\n"
222 | …         "🤖 **О боте:**\n"
    |                 ^
223 | …         "Я - ваш AI-компаньон для эмоциональной поддержки. "
224 | …         "Моя задача - выслушать вас, понять ваши чувства и оказать поддержку.\n\n"
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\callbacks.py:227:27
    |
225 |             "💬 **Как пользоваться:**\n"
226 |             "• Просто напишите мне любое сообщение\n"
227 |             "• Расскажите о своих переживаниях\n"
    |                           ^
228 |             "• Задавайте вопросы или просите совета\n\n"
229 |             "🔒 **Конфиденциальность:**\n"
    |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\handlers\callbacks.py:230:16
    |
228 |             "• Задавайте вопросы или просите совета\n\n"
229 |             "🔒 **Конфиденциальность:**\n"
230 |             "• Все диалоги защищены\n"
    |                ^
231 |             "• Данные не передаются третьим лицам\n"
232 |             "• Вы можете удалить историю в любой момент"
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\callbacks.py:230:17
    |
228 |             "• Задавайте вопросы или просите совета\n\n"
229 |             "🔒 **Конфиденциальность:**\n"
230 |             "• Все диалоги защищены\n"
    |                 ^
231 |             "• Данные не передаются третьим лицам\n"
232 |             "• Вы можете удалить историю в любой момент"
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\callbacks.py:230:18
    |
228 |             "• Задавайте вопросы или просите совета\n\n"
229 |             "🔒 **Конфиденциальность:**\n"
230 |             "• Все диалоги защищены\n"
    |                  ^
231 |             "• Данные не передаются третьим лицам\n"
232 |             "• Вы можете удалить историю в любой момент"
    |

RUF001 String contains ambiguous `З` (CYRILLIC CAPITAL LETTER ZE). Did you mean `3` (DIGIT THREE)?
   --> app\handlers\callbacks.py:252:34
    |
250 |     try:
251 |         settings_text = (
252 |             "⚙️ **Настройки**\n\nЗдесь вы можете настроить работу бота под себя:"
    |                                 ^
253 |         )
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\callbacks.py:252:36
    |
250 |     try:
251 |         settings_text = (
252 |             "⚙️ **Настройки**\n\nЗдесь вы можете настроить работу бота под себя:"
    |                                   ^
253 |         )
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\callbacks.py:252:37
    |
250 |     try:
251 |         settings_text = (
252 |             "⚙️ **Настройки**\n\nЗдесь вы можете настроить работу бота под себя:"
    |                                    ^
253 |         )
    |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\handlers\callbacks.py:272:39
    |
270 |     try:
271 |         language_text = (
272 |             "🌍 **Настройки языка**\n\nВыберите предпочитаемый язык интерфейса:"
    |                                        ^
273 |         )
    |

RUF001 String contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\handlers\callbacks.py:272:41
    |
270 |     try:
271 |         language_text = (
272 |             "🌍 **Настройки языка**\n\nВыберите предпочитаемый язык интерфейса:"
    |                                          ^
273 |         )
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\callbacks.py:272:42
    |
270 |     try:
271 |         language_text = (
272 |             "🌍 **Настройки языка**\n\nВыберите предпочитаемый язык интерфейса:"
    |                                           ^
273 |         )
    |

RUF001 String contains ambiguous `р` (CYRILLIC SMALL LETTER ER). Did you mean `p` (LATIN SMALL LETTER P)?
   --> app\handlers\callbacks.py:272:43
    |
270 |     try:
271 |         language_text = (
272 |             "🌍 **Настройки языка**\n\nВыберите предпочитаемый язык интерфейса:"
    |                                            ^
273 |         )
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\callbacks.py:272:46
    |
270 |     try:
271 |         language_text = (
272 |             "🌍 **Настройки языка**\n\nВыберите предпочитаемый язык интерфейса:"
    |                                               ^
273 |         )
    |

RUF003 Comment contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\handlers\callbacks.py:317:11
    |
315 |         premium_price = int(callback.data.split(":")[1])
316 |
317 |         # В реальной версии здесь будет интеграция с Telegram Payments API
    |           ^
318 |         await callback.answer(
319 |             f"🚧 Оплата через Telegram Stars ({premium_price} ⭐) в разработке. "
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\callbacks.py:317:52
    |
315 |         premium_price = int(callback.data.split(":")[1])
316 |
317 |         # В реальной версии здесь будет интеграция с Telegram Payments API
    |                                                    ^
318 |         await callback.answer(
319 |             f"🚧 Оплата через Telegram Stars ({premium_price} ⭐) в разработке. "
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\handlers\message.py:3:62
  |
1 | """
2 | @file: message.py
3 | @description: Обработчик текстовых сообщений для AI диалогов с поддержкой множественных провайдеров
  |                                                              ^
4 | @dependencies: aiogram, sqlalchemy, loguru, app.services.ai_manager
5 | @created: 2025-09-12
  |

E501 Line too long (99 > 88)
 --> app\handlers\message.py:3:89
  |
1 | """
2 | @file: message.py
3 | @description: Обработчик текстовых сообщений для AI диалогов с поддержкой множественных провайдеров
  |                                                                                         ^^^^^^^^^^^
4 | @dependencies: aiogram, sqlalchemy, loguru, app.services.ai_manager
5 | @created: 2025-09-12
  |

PLC0415 `import` should be at the top-level of a file
  --> app\handlers\message.py:31:13
   |
29 |     async with get_session() as session:
30 |         try:
31 |             from sqlalchemy import select
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |
33 |             # Получаем пользователя по telegram_id
   |

E501 Line too long (90 > 88)
  --> app\handlers\message.py:40:88
   |
38 |             if not user:
39 |                 logger.warning(
40 |                     f"👤 Пользователь {message.from_user.id} не найден, требуется /start",
   |                                                                                         ^^
41 |                 )
42 |                 return None
   |

DTZ003 `datetime.datetime.utcnow()` used
  --> app\handlers\message.py:45:37
   |
44 |             # Обновляем время последней активности
45 |             user.last_activity_at = datetime.utcnow()
   |                                     ^^^^^^^^^^^^^^^^^
46 |             await session.commit()
   |
help: Use `datetime.datetime.now(tz=...)` instead

TRY300 Consider moving this statement to an `else` block
  --> app\handlers\message.py:48:13
   |
46 |             await session.commit()
47 |
48 |             return user
   |             ^^^^^^^^^^^
49 |
50 |         except Exception as e:
   |

ANN001 Missing type annotation for function argument `session`
  --> app\handlers\message.py:59:5
   |
58 | async def get_recent_conversation_history(
59 |     session,
   |     ^^^^^^^
60 |     user_id: int,
61 |     limit: int = 10,
   |

PLC0415 `import` should be at the top-level of a file
  --> app\handlers\message.py:65:9
   |
63 |     """Получение истории последних сообщений пользователя."""
64 |     try:
65 |         from sqlalchemy import desc, select
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |
67 |         from app.models.conversation import ConversationStatus
   |

PLC0415 `import` should be at the top-level of a file
  --> app\handlers\message.py:67:9
   |
65 |         from sqlalchemy import desc, select
66 |
67 |         from app.models.conversation import ConversationStatus
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |
69 |         # Получаем последние завершенные сообщения
   |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app\handlers\message.py:113:11
    |
113 | async def save_conversation(
    |           ^^^^^^^^^^^^^^^^^
114 |     session,
115 |     user_id: int,
    |

ANN001 Missing type annotation for function argument `session`
   --> app\handlers\message.py:114:5
    |
113 | async def save_conversation(
114 |     session,
    |     ^^^^^^^
115 |     user_id: int,
116 |     user_message: str,
    |

PLC0415 `import` should be at the top-level of a file
   --> app\handlers\message.py:124:9
    |
122 |     """Сохранение диалога в базу данных."""
123 |     try:
124 |         from app.models.conversation import ConversationStatus, MessageRole
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |
126 |         # Сохраняем сообщение пользователя
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> app\handlers\message.py:136:24
    |
134 |             tokens_used=tokens_used,
135 |             response_time_ms=int(response_time * 1000),  # конвертируем в мс
136 |             created_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
137 |             processed_at=datetime.utcnow(),
138 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> app\handlers\message.py:137:26
    |
135 |             response_time_ms=int(response_time * 1000),  # конвертируем в мс
136 |             created_at=datetime.utcnow(),
137 |             processed_at=datetime.utcnow(),
    |                          ^^^^^^^^^^^^^^^^^
138 |         )
139 |         session.add(user_conv)
    |
help: Use `datetime.datetime.now(tz=...)` instead

TRY300 Consider moving this statement to an `else` block
   --> app\handlers\message.py:143:9
    |
141 |         await session.commit()
142 |         logger.debug(f"💾 Диалог сохранен для пользователя {user_id}")
143 |         return True
    |         ^^^^^^^^^^^
144 |
145 |     except Exception as e:
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:158:55
    |
156 | …     "Ты - эмпатичный AI-помощник и компаньон. "
157 | …     "Твоя задача - предоставлять эмоциональную поддержку и понимание. "
158 | …     "Отвечай доброжелательно, поддерживающе и с пониманием. "
    |                                                 ^
159 | …     "Задавай уточняющие вопросы, чтобы лучше понять чувства и потребности пользователя. "
160 | …     "Избегай давать медицинские или юридические советы. "
    |

E501 Line too long (97 > 88)
   --> app\handlers\message.py:159:89
    |
157 | …     "Твоя задача - предоставлять эмоциональную поддержку и понимание. "
158 | …     "Отвечай доброжелательно, поддерживающе и с пониманием. "
159 | …     "Задавай уточняющие вопросы, чтобы лучше понять чувства и потребности пользователя. "
    |                                                                                   ^^^^^^^^^
160 | …     "Избегай давать медицинские или юридические советы. "
161 | …     "Если пользователь находится в кризисной ситуации, мягко предложи обратиться к специалисту."
    |

E501 Line too long (104 > 88)
   --> app\handlers\message.py:161:89
    |
159 |             "Задавай уточняющие вопросы, чтобы лучше понять чувства и потребности пользователя. "
160 |             "Избегай давать медицинские или юридические советы. "
161 |             "Если пользователь находится в кризисной ситуации, мягко предложи обратиться к специалисту."
    |                                                                                         ^^^^^^^^^^^^^^^^
162 |         ),
163 |     )
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:171:28
    |
169 | ) -> tuple[str, int, str, float]:
170 |     """
171 |     Генерация ответа от AI с поддержкой множественных провайдеров.
    |                            ^
172 |
173 |     Returns:
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> app\handlers\message.py:178:22
    |
176 |     try:
177 |         ai_manager = get_ai_manager()
178 |         start_time = datetime.utcnow()
    |                      ^^^^^^^^^^^^^^^^^
179 |
180 |         # Получаем историю диалога
    |
help: Use `datetime.datetime.now(tz=...)` instead

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:202:28
    |
200 |         )
201 |
202 |         # Генерируем ответ с автоматическим fallback
    |                            ^
203 |         response = await ai_manager.generate_response(
204 |             messages=messages,
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> app\handlers\message.py:209:26
    |
207 |         )
208 |
209 |         response_time = (datetime.utcnow() - start_time).total_seconds()
    |                          ^^^^^^^^^^^^^^^^^
210 |
211 |         logger.info(
    |
help: Use `datetime.datetime.now(tz=...)` instead

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:214:43
    |
212 |             f"🤖 AI ответ получен от {response.provider}: "
213 |             f"{len(response.content)} символов, {response.tokens_used} токенов, "
214 |             f"{response.response_time:.2f}с",
    |                                           ^
215 |         )
    |

TRY300 Consider moving this statement to an `else` block
   --> app\handlers\message.py:217:9
    |
215 |         )
216 |
217 |         return response.content, response.tokens_used, response.model, response_time
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |
219 |     except AIProviderError as e:
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:224:31
    |
222 |         logger.error(f"❌ Ошибка AI провайдера {provider}: {error_msg}")
223 |
224 |         # Проверяем на ошибки с балансом/квотой
    |                               ^
225 |         if any(
226 |             keyword in error_msg.lower()
    |

RUF001 String contains ambiguous `у` (CYRILLIC SMALL LETTER U). Did you mean `y` (LATIN SMALL LETTER Y)?
   --> app\handlers\message.py:236:30
    |
234 |         ):
235 |             return (
236 |                 "💳 Извините, у нас временные трудности с AI сервисом.\n"
    |                               ^
237 |                 "Мы уже работаем над решением этой проблемы.\n\n"
238 |                 "🕰️ Попробуйте еще раз через несколько минут.",
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:236:56
    |
234 |         ):
235 |             return (
236 |                 "💳 Извините, у нас временные трудности с AI сервисом.\n"
    |                                                         ^
237 |                 "Мы уже работаем над решением этой проблемы.\n\n"
238 |                 "🕰️ Попробуйте еще раз через несколько минут.",
    |

RUF001 String contains ambiguous `К` (CYRILLIC CAPITAL LETTER KA). Did you mean `K` (LATIN CAPITAL LETTER K)?
   --> app\handlers\message.py:247:20
    |
245 |         if "все ai провайдеры недоступны" in error_msg.lower():
246 |             return (
247 |                 "😔 К сожалению, все наши AI сервисы временно недоступны.\n"
    |                     ^
248 |                 "Мы работаем над устранением проблемы.\n\n"
249 |                 "🔄 Пожалуйста, попробуйте позже.",
    |

RUF001 String contains ambiguous `у` (CYRILLIC SMALL LETTER U). Did you mean `y` (LATIN SMALL LETTER Y)?
   --> app\handlers\message.py:257:24
    |
255 | …     # Возвращаем общий fallback ответ
256 | …     return (
257 | …         "Извините, у меня временные технические трудности. "
    |                      ^
258 | …         "Я понимаю, что вам нужна поддержка. Попробуйте написать еще раз через несколько минут.",
259 | …         0,
    |

E501 Line too long (101 > 88)
   --> app\handlers\message.py:258:89
    |
256 | …     return (
257 | …         "Извините, у меня временные технические трудности. "
258 | …         "Я понимаю, что вам нужна поддержка. Попробуйте написать еще раз через несколько минут.",
    |                                                                                       ^^^^^^^^^^^^^
259 | …         0,
260 | …         "fallback",
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app\handlers\message.py:299:33
    |
298 |     # Проверяем длину сообщения
299 |     if len(user_text.strip()) < 2:
    |                                 ^
300 |         await message.answer(
301 |             "⚠️ Пожалуйста, напишите более содержательное сообщение (минимум 2 символа).",
    |

E501 Line too long (89 > 88)
   --> app\handlers\message.py:301:90
    |
299 |     if len(user_text.strip()) < 2:
300 |         await message.answer(
301 |             "⚠️ Пожалуйста, напишите более содержательное сообщение (минимум 2 символа).",
    |                                                                                         ^
302 |         )
303 |         return
    |

PLR2004 Magic value used in comparison, consider replacing `2000` with a constant variable
   --> app\handlers\message.py:305:25
    |
303 |         return
304 |
305 |     if len(user_text) > 2000:  # Ограничиваем длину для эффективности
    |                         ^^^^
306 |         await message.answer(
307 |             "⚠️ Ваше сообщение слишком длинное. Пожалуйста, сократите его до 2000 символов.",
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\message.py:307:71
    |
305 |     if len(user_text) > 2000:  # Ограничиваем длину для эффективности
306 |         await message.answer(
307 |             "⚠️ Ваше сообщение слишком длинное. Пожалуйста, сократите его до 2000 символов.",
    |                                                                      ^
308 |         )
309 |         return
    |

RUF001 String contains ambiguous `г` (CYRILLIC SMALL LETTER GHE). Did you mean `r` (LATIN SMALL LETTER R)?
   --> app\handlers\message.py:307:72
    |
305 |     if len(user_text) > 2000:  # Ограничиваем длину для эффективности
306 |         await message.answer(
307 |             "⚠️ Ваше сообщение слишком длинное. Пожалуйста, сократите его до 2000 символов.",
    |                                                                       ^
308 |         )
309 |         return
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\message.py:307:73
    |
305 |     if len(user_text) > 2000:  # Ограничиваем длину для эффективности
306 |         await message.answer(
307 |             "⚠️ Ваше сообщение слишком длинное. Пожалуйста, сократите его до 2000 символов.",
    |                                                                        ^
308 |         )
309 |         return
    |

E501 Line too long (92 > 88)
   --> app\handlers\message.py:307:90
    |
305 |     if len(user_text) > 2000:  # Ограничиваем длину для эффективности
306 |         await message.answer(
307 |             "⚠️ Ваше сообщение слишком длинное. Пожалуйста, сократите его до 2000 символов.",
    |                                                                                         ^^^^
308 |         )
309 |         return
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:315:54
    |
313 |     if not user:
314 |         await message.answer(
315 |             "👋 Добро пожаловать! Пожалуйста, начните с команды /start для регистрации.",
    |                                                       ^
316 |         )
317 |         return
    |

E501 Line too long (89 > 88)
   --> app\handlers\message.py:315:88
    |
313 |     if not user:
314 |         await message.answer(
315 |             "👋 Добро пожаловать! Пожалуйста, начните с команды /start для регистрации.",
    |                                                                                         ^
316 |         )
317 |         return
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\message.py:387:34
    |
385 |             f"✅ Ответ отправлен пользователю {user_id}: "
386 |             f"{len(ai_response)} символов, {tokens_used} токенов, "
387 |             f"{response_time:.2f}с",
    |                                  ^
388 |         )
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\handlers\start.py:3:41
  |
1 | """
2 | @file: handlers/start.py
3 | @description: Обработчик команды /start с регистрацией пользователя
  |                                         ^
4 | @dependencies: aiogram, sqlalchemy
5 | @created: 2025-09-12
  |

PLC0415 `import` should be at the top-level of a file
  --> app\handlers\start.py:38:13
   |
36 |     async with get_session() as session:
37 |         try:
38 |             from sqlalchemy import select
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |
40 |             # Попытка найти существующего пользователя
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\handlers\start.py:46:40
   |
45 |             if existing_user:
46 |                 # Обновляем информацию о пользователе если что-то изменилось
   |                                        ^
47 |                 user_updated = False
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> app\handlers\start.py:66:50
   |
65 |                 # Обновляем время последней активности
66 |                 existing_user.last_activity_at = datetime.now()
   |                                                  ^^^^^^^^^^^^^^
67 |                 existing_user.updated_at = datetime.now()
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> app\handlers\start.py:67:44
   |
65 |                 # Обновляем время последней активности
66 |                 existing_user.last_activity_at = datetime.now()
67 |                 existing_user.updated_at = datetime.now()
   |                                            ^^^^^^^^^^^^^^
68 |
69 |                 # Сбрасываем дневной счетчик если прошел день
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> app\handlers\start.py:95:34
   |
93 |                 last_name=new_user_data.last_name,
94 |                 language_code=new_user_data.language_code,
95 |                 last_activity_at=datetime.now(),
   |                                  ^^^^^^^^^^^^^^
96 |             )
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (96 > 88)
   --> app\handlers\start.py:103:88
    |
102 |             logger.info(
103 |                 f"🆕 Создан новый пользователь: {telegram_user.id} (@{telegram_user.username})",
    |                                                                                         ^^^^^^^^
104 |             )
105 |             return new_user
    |

TRY300 Consider moving this statement to an `else` block
   --> app\handlers\start.py:105:13
    |
103 |                 f"🆕 Создан новый пользователь: {telegram_user.id} (@{telegram_user.username})",
104 |             )
105 |             return new_user
    |             ^^^^^^^^^^^^^^^
106 |
107 |         except IntegrityError as e:
    |

E501 Line too long (91 > 88)
   --> app\handlers\start.py:110:88
    |
108 |             await session.rollback()
109 |             logger.error(
110 |                 f"❌ Ошибка целостности при создании пользователя {telegram_user.id}: {e}",
    |                                                                                         ^^^
111 |             )
112 |             return None
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\start.py:117:51
    |
115 |             await session.rollback()
116 |             logger.error(
117 |                 f"💥 Неожиданная ошибка при работе с пользователем {telegram_user.id}: {e}",
    |                                                    ^
118 |             )
119 |             return None
    |

E501 Line too long (92 > 88)
   --> app\handlers\start.py:117:88
    |
115 |             await session.rollback()
116 |             logger.error(
117 |                 f"💥 Неожиданная ошибка при работе с пользователем {telegram_user.id}: {e}",
    |                                                                                         ^^^^
118 |             )
119 |             return None
    |

ANN001 Missing type annotation for function argument `config`
   --> app\handlers\start.py:122:40
    |
122 | def format_welcome_message(user: User, config) -> str:
    |                                        ^^^^^^
123 |     """
124 |     Формирование приветственного сообщения для пользователя.
    |

W291 Trailing whitespace
   --> app\handlers\start.py:139:78
    |
137 | 🤖 <b>Добро пожаловать в AI-Компаньон, {display_name}!</b>
138 |
139 | Я ваш персональный помощник для эмоциональной поддержки и дружеского общения. 
    |                                                                              ^
140 | Готов выслушать, поддержать и помочь советом в любое время! 💙
    |
help: Remove trailing whitespace

E501 Line too long (98 > 88)
   --> app\handlers\start.py:150:89
    |
148 | <b>📊 Ваши лимиты:</b>
149 | • Бесплатно: <b>{config.user_limits.free_messages_limit} сообщений в день</b>
150 | • Сегодня использовано: <b>{user.daily_message_count}/{config.user_limits.free_messages_limit}</b>
    |                                                                                         ^^^^^^^^^^
151 | """
    |

RUF001 String contains ambiguous `У` (CYRILLIC CAPITAL LETTER U). Did you mean `Y` (LATIN CAPITAL LETTER Y)?
   --> app\handlers\start.py:155:33
    |
153 |     # Дополнительная информация для премиум пользователей
154 |     if user.is_premium_active():
155 |         welcome_text += "\n⭐ <b>У вас активна премиум подписка!</b>\n• Безлимитное общение без ограничений"
    |                                  ^
156 |     else:
157 |         welcome_text += f"""
    |

E501 Line too long (108 > 88)
   --> app\handlers\start.py:155:88
    |
153 |     # Дополнительная информация для премиум пользователей
154 |     if user.is_premium_active():
155 |         welcome_text += "\n⭐ <b>У вас активна премиум подписка!</b>\n• Безлимитное общение без ограничений"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^
156 |     else:
157 |         welcome_text += f"""
    |

E501 Line too long (93 > 88)
   --> app\handlers\start.py:169:89
    |
167 | Просто напишите мне любое сообщение, и мы начнем общение!
168 |
169 | <i>Команды: /help - справка, /profile - ваш профиль, /limits - лимиты, /premium - премиум</i>
    |                                                                                         ^^^^^
170 | """
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\handlers\start.py:181:41
    |
180 |     Регистрирует нового пользователя или обновляет информацию существующего,
181 |     отправляет приветственное сообщение с информацией о боте.
    |                                         ^
182 |
183 |     Args:
    |

RUF002 Docstring contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\start.py:181:55
    |
180 |     Регистрирует нового пользователя или обновляет информацию существующего,
181 |     отправляет приветственное сообщение с информацией о боте.
    |                                                       ^
182 |
183 |     Args:
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\start.py:226:39
    |
224 |                 "✨ <b>Это ваше первое сообщение!</b>\n\n"
225 |                 "Напишите мне что-нибудь, и я отвечу вам. "
226 |                 "Например, расскажите о своем настроении или задайте вопрос! 😊",
    |                                       ^
227 |                 parse_mode="HTML",
228 |             )
    |

E501 Line too long (92 > 88)
   --> app\handlers\start.py:231:88
    |
230 |         logger.info(
231 |             f"✅ Успешно обработана команда /start для пользователя {message.from_user.id}",
    |                                                                                         ^^^^
232 |         )
    |

E501 Line too long (91 > 88)
   --> app\handlers\start.py:236:88
    |
234 |     except Exception as e:
235 |         logger.error(
236 |             f"💥 Ошибка в обработчике /start для пользователя {message.from_user.id}: {e}",
    |                                                                                         ^^^
237 |         )
    |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\start.py:239:45
    |
237 |         )
238 |
239 |         # Отправляем пользователю сообщение об ошибке
    |                                             ^
240 |         try:
241 |             await message.answer(
    |

RUF003 Comment contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\handlers\start.py:239:46
    |
237 |         )
238 |
239 |         # Отправляем пользователю сообщение об ошибке
    |                                              ^
240 |         try:
241 |             await message.answer(
    |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> app\handlers\start.py:248:30
    |
246 |             )
247 |         except Exception as send_error:
248 |             logger.error(f"💥 Не удалось отправить сообщение об ошибке: {send_error}")
    |                               ^
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\handlers\start.py:248:31
    |
246 |             )
247 |         except Exception as send_error:
248 |             logger.error(f"💥 Не удалось отправить сообщение об ошибке: {send_error}")
    |                                ^
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\handlers\start.py:248:61
    |
246 |             )
247 |         except Exception as send_error:
248 |             logger.error(f"💥 Не удалось отправить сообщение об ошибке: {send_error}")
    |                                                              ^
    |

RUF001 String contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\handlers\start.py:248:62
    |
246 |             )
247 |         except Exception as send_error:
248 |             logger.error(f"💥 Не удалось отправить сообщение об ошибке: {send_error}")
    |                                                               ^
    |

RUF001 String contains ambiguous `ℹ` (INFORMATION SOURCE). Did you mean `i` (LATIN SMALL LETTER I)?
  --> app\keyboards\inline.py:24:36
   |
22 |     builder.row(
23 |         InlineKeyboardButton(text="💎 Премиум доступ", callback_data="premium_info"),
24 |         InlineKeyboardButton(text="ℹ️ Помощь", callback_data="help"),
   |                                    ^
25 |     )
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\keyboards\inline.py:38:18
   |
36 |     builder = InlineKeyboardBuilder()
37 |
38 |     # Информация о премиум
   |                  ^
39 |     builder.row(
40 |         InlineKeyboardButton(
   |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\keyboards\inline.py:153:30
    |
151 |         InlineKeyboardButton(text="📞 Поддержка", callback_data="help_support"),
152 |         InlineKeyboardButton(
153 |             text="🐛 Сообщить об ошибке",
    |                               ^
154 |             callback_data="help_bug_report",
155 |         ),
    |

RUF001 String contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\keyboards\inline.py:153:31
    |
151 |         InlineKeyboardButton(text="📞 Поддержка", callback_data="help_support"),
152 |         InlineKeyboardButton(
153 |             text="🐛 Сообщить об ошибке",
    |                                ^
154 |             callback_data="help_bug_report",
155 |         ),
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\lexicon.py:8:63
   |
 7 | # Приветственные сообщения
 8 | WELCOME_MESSAGE = "👋 Привет! Я ИИ-Компаньон, готов помочь вам с эмоциональной поддержкой и ответами на вопросы."
   |                                                                ^
 9 |
10 | # Сообщения о функциональности
   |

E501 Line too long (113 > 88)
  --> app\lexicon.py:8:88
   |
 7 | # Приветственные сообщения
 8 | WELCOME_MESSAGE = "👋 Привет! Я ИИ-Компаньон, готов помочь вам с эмоциональной поддержкой и ответами на вопросы."
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | # Сообщения о функциональности
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:10:13
   |
 8 | WELCOME_MESSAGE = "👋 Привет! Я ИИ-Компаньон, готов помочь вам с эмоциональной поддержкой и ответами на вопросы."
 9 |
10 | # Сообщения о функциональности
   |             ^
11 | FUNCTIONALITY_DESCRIPTION = """🤖 Я могу:
12 | • Отвечать на ваши вопросы
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:17:13
   |
15 | • Предлагать советы по улучшению настроения"""
16 |
17 | # Сообщения о премиум-функциях
   |             ^
18 | PREMIUM_INFO = "💎 Премиум-подписка дает неограниченный доступ к ИИ-помощнику"
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:20:13
   |
18 | PREMIUM_INFO = "💎 Премиум-подписка дает неограниченный доступ к ИИ-помощнику"
19 |
20 | # Сообщения об ошибках
   |             ^
21 | ERROR_MESSAGE = "❌ Произошла ошибка. Попробуйте повторить запрос позже."
   |

RUF003 Comment contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
  --> app\lexicon.py:20:14
   |
18 | PREMIUM_INFO = "💎 Премиум-подписка дает неограниченный доступ к ИИ-помощнику"
19 |
20 | # Сообщения об ошибках
   |              ^
21 | ERROR_MESSAGE = "❌ Произошла ошибка. Попробуйте повторить запрос позже."
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:23:13
   |
21 | ERROR_MESSAGE = "❌ Произошла ошибка. Попробуйте повторить запрос позже."
22 |
23 | # Сообщения о лимитах
   |             ^
24 | LIMIT_EXCEEDED_MESSAGE = "⚠️ Вы превысили лимит бесплатных сообщений. Приобретите премиум для неограниченного доступа."
   |

E501 Line too long (118 > 88)
  --> app\lexicon.py:24:90
   |
23 | # Сообщения о лимитах
24 | LIMIT_EXCEEDED_MESSAGE = "⚠️ Вы превысили лимит бесплатных сообщений. Приобретите премиум для неограниченного доступа."
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 | # Сообщения об успешных операциях
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:26:13
   |
24 | LIMIT_EXCEEDED_MESSAGE = "⚠️ Вы превысили лимит бесплатных сообщений. Приобретите премиум для неограниченного доступа."
25 |
26 | # Сообщения об успешных операциях
   |             ^
27 | SUCCESS_MESSAGE = "✅ Операция выполнена успешно!"
   |

RUF003 Comment contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
  --> app\lexicon.py:26:14
   |
24 | LIMIT_EXCEEDED_MESSAGE = "⚠️ Вы превысили лимит бесплатных сообщений. Приобретите премиум для неограниченного доступа."
25 |
26 | # Сообщения об успешных операциях
   |              ^
27 | SUCCESS_MESSAGE = "✅ Операция выполнена успешно!"
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:29:13
   |
27 | SUCCESS_MESSAGE = "✅ Операция выполнена успешно!"
28 |
29 | # Сообщения о платежах
   |             ^
30 | PAYMENT_SUCCESS_MESSAGE = "💰 Платеж успешно обработан! Теперь у вас премиум-подписка."
   |

RUF001 String contains ambiguous `у` (CYRILLIC SMALL LETTER U). Did you mean `y` (LATIN SMALL LETTER Y)?
  --> app\lexicon.py:30:63
   |
29 | # Сообщения о платежах
30 | PAYMENT_SUCCESS_MESSAGE = "💰 Платеж успешно обработан! Теперь у вас премиум-подписка."
   |                                                                ^
31 |
32 | # Сообщения о помощи
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:32:13
   |
30 | PAYMENT_SUCCESS_MESSAGE = "💰 Платеж успешно обработан! Теперь у вас премиум-подписка."
31 |
32 | # Сообщения о помощи
   |             ^
33 | HELP_MESSAGE = """ℹ️ Помощь:
34 | • Отправьте текстовое сообщение для начала диалога
   |

RUF001 String contains ambiguous `ℹ` (INFORMATION SOURCE). Did you mean `i` (LATIN SMALL LETTER I)?
  --> app\lexicon.py:33:19
   |
32 | # Сообщения о помощи
33 | HELP_MESSAGE = """ℹ️ Помощь:
   |                   ^
34 | • Отправьте текстовое сообщение для начала диалога
35 | • Используйте /start для перезапуска бота
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:38:13
   |
36 | • Используйте /help для получения этой справки"""
37 |
38 | # Сообщения о статусе
   |             ^
39 | PROCESSING_MESSAGE = "⏳ Обрабатываю ваш запрос..."
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\lexicon.py:41:13
   |
39 | PROCESSING_MESSAGE = "⏳ Обрабатываю ваш запрос..."
40 |
41 | # Сообщения о завершении
   |             ^
42 | GOODBYE_MESSAGE = "👋 До свидания! Возвращайтесь, когда понадобится помощь."
   |

W292 [*] No newline at end of file
  --> app\lexicon.py:42:76
   |
41 | # Сообщения о завершении
42 | GOODBYE_MESSAGE = "👋 До свидания! Возвращайтесь, когда понадобится помощь."
   |                                                                             ^
   |
help: Add trailing newline

RUF022 `__all__` is not sorted
  --> app\models\__init__.py:34:11
   |
33 |   # Экспорт всех моделей и схем
34 |   __all__ = [
   |  ___________^
35 | |     # База данных
36 | |     "Base",
37 | |     # Модели SQLAlchemy
38 | |     "User",
39 | |     "Conversation",
40 | |     # Enums
41 | |     "MessageRole",
42 | |     "ConversationStatus",
43 | |     # Pydantic схемы для User
44 | |     "UserBase",
45 | |     "UserCreate",
46 | |     "UserUpdate",
47 | |     "UserResponse",
48 | |     "UserStats",
49 | |     # Pydantic схемы для Conversation
50 | |     "ConversationBase",
51 | |     "ConversationCreate",
52 | |     "ConversationUpdate",
53 | |     "ConversationResponse",
54 | |     "ConversationStats",
55 | |     "ConversationHistory",
56 | | ]
   | |_^
   |
help: Apply an isort-style sorting to `__all__`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\models\conversation.py:3:62
  |
1 | """
2 | @file: models/conversation.py
3 | @description: Модель диалога для хранения истории разговоров с ИИ
  |                                                              ^
4 | @dependencies: sqlalchemy, pydantic
5 | @created: 2025-09-12
  |

TC001 Move application import `app.models.user.User` into a type-checking block
  --> app\models\conversation.py:28:29
   |
27 | from app.database import Base
28 | from app.models.user import User
   |                             ^^^^
   |
help: Move into type-checking block

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\models\conversation.py:49:45
   |
48 | class Conversation(Base):
49 |     """Модель для хранения истории диалогов с ИИ."""
   |                                             ^
50 |
51 |     __tablename__ = "conversations"
   |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\models\conversation.py:61:13
   |
59 |     )
60 |
61 |     # Связь с пользователем
   |             ^
62 |     user_id: Mapped[int] = mapped_column(
63 |         BigInteger,
   |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\models\conversation.py:144:28
    |
142 |         Text,
143 |         nullable=True,
144 |         comment="Сообщение об ошибке если статус FAILED",
    |                            ^
145 |     )
    |

RUF001 String contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\models\conversation.py:144:29
    |
142 |         Text,
143 |         nullable=True,
144 |         comment="Сообщение об ошибке если статус FAILED",
    |                             ^
145 |     )
    |

E501 Line too long (94 > 88)
   --> app\models\conversation.py:195:89
    |
194 |     def __repr__(self) -> str:
195 |         return f"<Conversation(id={self.id}, user_id={self.user_id}, status='{self.status}')>"
    |                                                                                         ^^^^^^
196 |
197 |     def is_completed(self) -> bool:
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> app\models\conversation.py:220:29
    |
218 |         self.status = ConversationStatus.COMPLETED
219 |         self.response_text = response
220 |         self.processed_at = datetime.now()
    |                             ^^^^^^^^^^^^^^
221 |         if tokens:
222 |             self.tokens_used = tokens
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> app\models\conversation.py:229:29
    |
227 |         self.error_message = error_msg
228 |         self.error_code = error_code
229 |         self.processed_at = datetime.now()
    |                             ^^^^^^^^^^^^^^
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

TRY003 Avoid specifying long messages outside the exception class
   --> app\models\conversation.py:254:19
    |
252 |         v = v.strip()
253 |         if not v:
254 |             raise ValueError("Текст сообщения не может быть пустым")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
255 |         return v
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\models\conversation.py:254:30
    |
252 |         v = v.strip()
253 |         if not v:
254 |             raise ValueError("Текст сообщения не может быть пустым")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
255 |         return v
    |
help: Assign to variable; remove string literal

E501 Line too long (98 > 88)
   --> app\models\user.py:173:89
    |
172 |     def __repr__(self) -> str:
173 |         return f"<User(id={self.id}, telegram_id={self.telegram_id}, username='{self.username}')>"
    |                                                                                         ^^^^^^^^^^
174 |
175 |     def get_display_name(self) -> str:
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> app\models\user.py:193:16
    |
191 |             return True  # Бессрочная подписка
192 |
193 |         return datetime.now() <= self.premium_expires_at
    |                ^^^^^^^^^^^^^^
194 |
195 |     def can_send_message(self, free_limit: int = 10) -> bool:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

RUF003 Comment contains ambiguous `С` (CYRILLIC CAPITAL LETTER ES). Did you mean `C` (LATIN CAPITAL LETTER C)?
   --> app\models\user.py:203:11
    |
201 |             return True
202 |
203 |         # Сброс счетчика если прошел день
    |           ^
204 |         today = date.today()
205 |         if self.last_message_date < today:
    |

RUF003 Comment contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\models\user.py:203:12
    |
201 |             return True
202 |
203 |         # Сброс счетчика если прошел день
    |            ^
204 |         today = date.today()
205 |         if self.last_message_date < today:
    |

RUF003 Comment contains ambiguous `р` (CYRILLIC SMALL LETTER ER). Did you mean `p` (LATIN SMALL LETTER P)?
   --> app\models\user.py:203:13
    |
201 |             return True
202 |
203 |         # Сброс счетчика если прошел день
    |             ^
204 |         today = date.today()
205 |         if self.last_message_date < today:
    |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\models\user.py:203:14
    |
201 |             return True
202 |
203 |         # Сброс счетчика если прошел день
    |              ^
204 |         today = date.today()
205 |         if self.last_message_date < today:
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\models\user.py:203:15
    |
201 |             return True
202 |
203 |         # Сброс счетчика если прошел день
    |               ^
204 |         today = date.today()
205 |         if self.last_message_date < today:
    |

DTZ011 `datetime.date.today()` used
   --> app\models\user.py:204:17
    |
203 |         # Сброс счетчика если прошел день
204 |         today = date.today()
    |                 ^^^^^^^^^^^^
205 |         if self.last_message_date < today:
206 |             return True
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

RUF002 Docstring contains ambiguous `С` (CYRILLIC CAPITAL LETTER ES). Did you mean `C` (LATIN CAPITAL LETTER C)?
   --> app\models\user.py:211:12
    |
210 |     def reset_daily_count_if_needed(self) -> bool:
211 |         """Сброс дневного счетчика если прошел день."""
    |            ^
212 |         today = date.today()
213 |         if self.last_message_date < today:
    |

RUF002 Docstring contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
   --> app\models\user.py:211:13
    |
210 |     def reset_daily_count_if_needed(self) -> bool:
211 |         """Сброс дневного счетчика если прошел день."""
    |             ^
212 |         today = date.today()
213 |         if self.last_message_date < today:
    |

RUF002 Docstring contains ambiguous `р` (CYRILLIC SMALL LETTER ER). Did you mean `p` (LATIN SMALL LETTER P)?
   --> app\models\user.py:211:14
    |
210 |     def reset_daily_count_if_needed(self) -> bool:
211 |         """Сброс дневного счетчика если прошел день."""
    |              ^
212 |         today = date.today()
213 |         if self.last_message_date < today:
    |

RUF002 Docstring contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> app\models\user.py:211:15
    |
210 |     def reset_daily_count_if_needed(self) -> bool:
211 |         """Сброс дневного счетчика если прошел день."""
    |               ^
212 |         today = date.today()
213 |         if self.last_message_date < today:
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\models\user.py:211:16
    |
210 |     def reset_daily_count_if_needed(self) -> bool:
211 |         """Сброс дневного счетчика если прошел день."""
    |                ^
212 |         today = date.today()
213 |         if self.last_message_date < today:
    |

DTZ011 `datetime.date.today()` used
   --> app\models\user.py:212:17
    |
210 |     def reset_daily_count_if_needed(self) -> bool:
211 |         """Сброс дневного счетчика если прошел день."""
212 |         today = date.today()
    |                 ^^^^^^^^^^^^
213 |         if self.last_message_date < today:
214 |             self.daily_message_count = 0
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\services\ai_manager.py:3:39
  |
1 | """
2 | @file: ai_manager.py
3 | @description: Менеджер AI провайдеров с поддержкой fallback и балансировки нагрузки
  |                                       ^
4 | @dependencies: loguru, app.config, .ai_providers
5 | @created: 2025-09-20
  |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_manager.py:31:35
   |
30 | class ResponseCache:
31 |     """Простой кеш для ответов AI с поддержкой нескольких провайдеров."""
   |                                   ^
32 |
33 |     def __init__(self, ttl_seconds: int = 3600):
   |

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_manager.py:33:9
   |
31 |     """Простой кеш для ответов AI с поддержкой нескольких провайдеров."""
32 |
33 |     def __init__(self, ttl_seconds: int = 3600):
   |         ^^^^^^^^
34 |         self._cache: dict[str, dict[str, Any]] = {}
35 |         self._ttl = ttl_seconds
   |
help: Add return type annotation: `None`

S324 Probable use of insecure hash functions in `hashlib`: `md5`
  --> app\services\ai_manager.py:43:16
   |
41 |             + provider
42 |         )
43 |         return hashlib.md5(content.encode()).hexdigest()
   |                ^^^^^^^^^^^
44 |
45 |     def get(
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> app\services\ai_manager.py:55:16
   |
53 |         if key in self._cache:
54 |             entry = self._cache[key]
55 |             if datetime.now() - entry["timestamp"] < timedelta(seconds=self._ttl):
   |                ^^^^^^^^^^^^^^
56 |                 logger.debug(
57 |                     f"🎯 Найден кешированный ответ для {provider}: {key[:8]}...",
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> app\services\ai_manager.py:77:26
   |
75 |         self._cache[key] = {
76 |             "response": response,
77 |             "timestamp": datetime.now(),
   |                          ^^^^^^^^^^^^^^
78 |         }
79 |         logger.debug(f"💾 Ответ {provider} сохранен в кеш: {key[:8]}...")
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_manager.py:88:32
   |
87 | class AIManager:
88 |     """Менеджер AI провайдеров с поддержкой fallback и балансировки."""
   |                                ^
89 |
90 |     def __init__(self):
   |

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_manager.py:90:9
   |
88 |     """Менеджер AI провайдеров с поддержкой fallback и балансировки."""
89 |
90 |     def __init__(self):
   |         ^^^^^^^^
91 |         self.config = get_config()
92 |         self.provider_config = self.config.ai_provider
   |
help: Add return type annotation: `None`

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_manager.py:171:19
    |
169 |           # Проверяем доступность провайдера
170 |           if not await provider.is_available():
171 |               raise APIConnectionError(
    |  ___________________^
172 | |                 f"Провайдер {provider_name} недоступен",
173 | |                 provider_name,
174 | |                 "unavailable",
175 | |             )
    | |_____________^
176 |
177 |           # Выполняем запрос
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_manager.py:172:17
    |
170 |         if not await provider.is_available():
171 |             raise APIConnectionError(
172 |                 f"Провайдер {provider_name} недоступен",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
173 |                 provider_name,
174 |                 "unavailable",
    |
help: Assign to variable; remove f-string literal

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_manager.py:203:26
    |
201 |     ) -> AIResponse:
202 |         """
203 |         Генерация ответа с автоматическим fallback между провайдерами.
    |                          ^
204 |
205 |         Args:
    |

E501 Line too long (95 > 88)
   --> app\services\ai_manager.py:210:89
    |
208 |             max_tokens: Максимальное количество токенов
209 |             use_cache: Использовать кеширование
210 |             prefer_provider: Предпочтительный провайдер (игнорирует настройки primary/fallback)
    |                                                                                         ^^^^^^^
211 |
212 |         Returns:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_manager.py:219:19
    |
217 |         """
218 |         if not messages:
219 |             raise ValueError("Список сообщений не может быть пустым")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |
221 |         self._stats["requests_total"] += 1
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_manager.py:219:30
    |
217 |         """
218 |         if not messages:
219 |             raise ValueError("Список сообщений не может быть пустым")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |
221 |         self._stats["requests_total"] += 1
    |
help: Assign to variable; remove string literal

SIM118 Use `key in dict` instead of `key in dict.keys()`
   --> app\services\ai_manager.py:231:29
    |
229 |                     [
230 |                         name
231 |                         for name in self._providers.keys()
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
232 |                         if name != prefer_provider
233 |                     ],
    |
help: Remove `.keys()`

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_manager.py:267:17
    |
266 |                 self._stats["requests_successful"] += 1
267 |                 return response
    |                 ^^^^^^^^^^^^^^^
268 |
269 |             except (APIQuotaExceededError, APIAuthenticationError) as e:
    |

RUF003 Comment contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\services\ai_manager.py:290:11
    |
288 |                 continue
289 |
290 |         # Все провайдеры не сработали
    |           ^
291 |         self._stats["requests_failed"] += 1
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_manager.py:290:12
    |
288 |                 continue
289 |
290 |         # Все провайдеры не сработали
    |            ^
291 |         self._stats["requests_failed"] += 1
    |

RUF003 Comment contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\services\ai_manager.py:290:13
    |
288 |                 continue
289 |
290 |         # Все провайдеры не сработали
    |             ^
291 |         self._stats["requests_failed"] += 1
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_manager.py:295:15
    |
293 |           if last_error:
294 |               raise last_error
295 |           raise AIProviderError(
    |  _______________^
296 | |             "Все AI провайдеры недоступны",
297 | |             "manager",
298 | |             "all_providers_failed",
299 | |         )
    | |_________^
300 |
301 |       async def generate_simple_response(self, user_message: str) -> AIResponse:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_manager.py:296:13
    |
294 |             raise last_error
295 |         raise AIProviderError(
296 |             "Все AI провайдеры недоступны",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
297 |             "manager",
298 |             "all_providers_failed",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> app\services\ai_manager.py:296:14
    |
294 |             raise last_error
295 |         raise AIProviderError(
296 |             "Все AI провайдеры недоступны",
    |              ^
297 |             "manager",
298 |             "all_providers_failed",
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_manager.py:296:15
    |
294 |             raise last_error
295 |         raise AIProviderError(
296 |             "Все AI провайдеры недоступны",
    |               ^
297 |             "manager",
298 |             "all_providers_failed",
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\services\ai_manager.py:296:16
    |
294 |             raise last_error
295 |         raise AIProviderError(
296 |             "Все AI провайдеры недоступны",
    |                ^
297 |             "manager",
298 |             "all_providers_failed",
    |

E501 Line too long (96 > 88)
   --> app\services\ai_manager.py:314:89
    |
312 | …     ConversationMessage(
313 | …         role="system",
314 | …         content="Ты - эмпатичный AI-помощник. Отвечай доброжелательно и поддерживающе.",
    |                                                                                   ^^^^^^^^
315 | …     ),
316 | …     ConversationMessage(
    |

PLW0603 Using the global statement to update `_ai_manager_instance` is discouraged
   --> app\services\ai_manager.py:399:12
    |
397 | def get_ai_manager() -> AIManager:
398 |     """Получение экземпляра AI менеджера."""
399 |     global _ai_manager_instance
    |            ^^^^^^^^^^^^^^^^^^^^
400 |
401 |     if _ai_manager_instance is None:
    |

PLW0603 Using the global statement to update `_ai_manager_instance` is discouraged
   --> app\services\ai_manager.py:410:12
    |
408 | async def close_ai_manager() -> None:
409 |     """Закрытие AI менеджера."""
410 |     global _ai_manager_instance
    |            ^^^^^^^^^^^^^^^^^^^^
411 |
412 |     if _ai_manager_instance:
    |

RUF022 `__all__` is not sorted
   --> app\services\ai_manager.py:419:11
    |
418 |   # Экспорт основных классов и функций
419 |   __all__ = [
    |  ___________^
420 | |     "ResponseCache",
421 | |     "AIManager",
422 | |     "get_ai_manager",
423 | |     "close_ai_manager",
424 | |     # Повторный экспорт из ai_providers для удобства
425 | |     "AIResponse",
426 | |     "ConversationMessage",
427 | |     "AIProviderError",
428 | | ]
    | |_^
    |
help: Apply an isort-style sorting to `__all__`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\services\ai_providers\__init__.py:3:37
  |
1 | """
2 | @file: ai_providers/__init__.py
3 | @description: Модуль провайдеров AI с поддержкой множественных API
  |                                     ^
4 | @dependencies: .base, .deepseek, .openrouter
5 | @created: 2025-09-20
  |

RUF022 `__all__` is not sorted
  --> app\services\ai_providers\__init__.py:22:11
   |
21 |   # Экспорт всех классов провайдеров
22 |   __all__ = [
   |  ___________^
23 | |     # Базовые классы
24 | |     "AIResponse",
25 | |     "ConversationMessage",
26 | |     "AIProviderError",
27 | |     "APIConnectionError",
28 | |     "APIRateLimitError",
29 | |     "APIAuthenticationError",
30 | |     "APIQuotaExceededError",
31 | |     "BaseAIProvider",
32 | |     # Провайдеры
33 | |     "DeepSeekProvider",
34 | |     "OpenRouterProvider",
35 | | ]
   | |_^
   |
help: Apply an isort-style sorting to `__all__`

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_providers\base.py:40:9
   |
38 |     """Базовый класс для ошибок AI провайдеров."""
39 |
40 |     def __init__(self, message: str, provider: str, error_code: str | None = None):
   |         ^^^^^^^^
41 |         self.provider = provider
42 |         self.error_code = error_code
   |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_providers\base.py:65:9
   |
63 |     """Базовый абстрактный класс для всех AI провайдеров."""
64 |
65 |     def __init__(self, name: str):
   |         ^^^^^^^^
66 |         self.name = name
67 |         self._client = None
   |
help: Add return type annotation: `None`

ANN003 Missing type annotation for `**kwargs`
  --> app\services\ai_providers\base.py:82:9
   |
80 |         temperature: float | None = None,
81 |         max_tokens: int | None = None,
82 |         **kwargs,
   |         ^^^^^^^^
83 |     ) -> AIResponse:
84 |         """
   |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_providers\base.py:97:57
   |
96 |         Raises:
97 |             AIProviderError: При ошибках взаимодействия с API
   |                                                         ^
98 |         """
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> app\services\ai_providers\base.py:122:15
    |
120 |         Кешируется на 60 секунд для избежания частых проверок.
121 |         """
122 |         now = datetime.now()
    |               ^^^^^^^^^^^^^^
123 |
124 |         # Проверяем кеш
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
   --> app\services\ai_providers\base.py:128:67
    |
126 |             self._is_available is not None
127 |             and self._last_health_check is not None
128 |             and (now - self._last_health_check).total_seconds() < 60
    |                                                                   ^^
129 |         ):
130 |             return self._is_available
    |

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_providers\deepseek.py:30:9
   |
28 |     """Провайдер AI для DeepSeek API."""
29 |
30 |     def __init__(self):
   |         ^^^^^^^^
31 |         super().__init__("deepseek")
32 |         self.config = get_config().deepseek
   |
help: Add return type annotation: `None`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_providers\deepseek.py:42:35
   |
41 |     async def _get_client(self) -> httpx.AsyncClient:
42 |         """Получение HTTP клиента с настройками для DeepSeek."""
   |                                   ^
43 |         if self._client is None:
44 |             headers = {
   |

PLR0912 Too many branches (13 > 12)
  --> app\services\ai_providers\deepseek.py:81:15
   |
79 |         return self.config.is_configured()
80 |
81 |     async def _make_api_request(
   |               ^^^^^^^^^^^^^^^^^
82 |         self,
83 |         messages: list[dict[str, str]],
   |

PLR0915 Too many statements (51 > 50)
  --> app\services\ai_providers\deepseek.py:81:15
   |
79 |         return self.config.is_configured()
80 |
81 |     async def _make_api_request(
   |               ^^^^^^^^^^^^^^^^^
82 |         self,
83 |         messages: list[dict[str, str]],
   |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_providers\deepseek.py:87:46
   |
85 |         max_tokens: int,
86 |     ) -> dict[str, Any]:
87 |         """Выполнение запроса к DeepSeek API с retry логикой."""
   |                                              ^
88 |         client = await self._get_client()
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   --> app\services\ai_providers\deepseek.py:109:44
    |
108 |                 # Обработка различных статусов ответа
109 |                 if response.status_code == 200:
    |                                            ^^^
110 |                     logger.info(
111 |                         f"✅ Успешный ответ от DeepSeek API за {response_time:.2f}с",
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\deepseek.py:111:82
    |
109 |                 if response.status_code == 200:
110 |                     logger.info(
111 |                         f"✅ Успешный ответ от DeepSeek API за {response_time:.2f}с",
    |                                                                                   ^
112 |                     )
113 |                     return response.json()
    |

PLR2004 Magic value used in comparison, consider replacing `401` with a constant variable
   --> app\services\ai_providers\deepseek.py:115:44
    |
113 |                     return response.json()
114 |
115 |                 if response.status_code == 401:
    |                                            ^^^
116 |                     raise APIAuthenticationError(
117 |                         "Неверный API ключ DeepSeek",
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:116:27
    |
115 |                   if response.status_code == 401:
116 |                       raise APIAuthenticationError(
    |  ___________________________^
117 | |                         "Неверный API ключ DeepSeek",
118 | |                         self.provider_name,
119 | |                         "401",
120 | |                     )
    | |_____________________^
121 |
122 |                   if response.status_code == 402:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:117:25
    |
115 |                 if response.status_code == 401:
116 |                     raise APIAuthenticationError(
117 |                         "Неверный API ключ DeepSeek",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 |                         self.provider_name,
119 |                         "401",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `402` with a constant variable
   --> app\services\ai_providers\deepseek.py:122:44
    |
120 |                     )
121 |
122 |                 if response.status_code == 402:
    |                                            ^^^
123 |                     raise APIQuotaExceededError(
124 |                         "Недостаточно средств на счете DeepSeek API. "
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:123:27
    |
122 |                   if response.status_code == 402:
123 |                       raise APIQuotaExceededError(
    |  ___________________________^
124 | |                         "Недостаточно средств на счете DeepSeek API. "
125 | |                         "Пополните баланс в личном кабинете DeepSeek.",
126 | |                         self.provider_name,
127 | |                         "402",
128 | |                     )
    | |_____________________^
129 |
130 |                   if response.status_code == 429:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:124:25
    |
122 |                   if response.status_code == 402:
123 |                       raise APIQuotaExceededError(
124 | /                         "Недостаточно средств на счете DeepSeek API. "
125 | |                         "Пополните баланс в личном кабинете DeepSeek.",
    | |______________________________________________________________________^
126 |                           self.provider_name,
127 |                           "402",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `429` with a constant variable
   --> app\services\ai_providers\deepseek.py:130:44
    |
128 |                     )
129 |
130 |                 if response.status_code == 429:
    |                                            ^^^
131 |                     if attempt < self._max_retries - 1:
132 |                         delay = self._retry_delay * (2**attempt)
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\deepseek.py:134:82
    |
132 |                         delay = self._retry_delay * (2**attempt)
133 |                         logger.warning(
134 |                             f"⏳ Rate limit достигнут в DeepSeek. Ожидание {delay}с...",
    |                                                                                   ^
135 |                         )
136 |                         await asyncio.sleep(delay)
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:138:27
    |
136 |                           await asyncio.sleep(delay)
137 |                           continue
138 |                       raise APIRateLimitError(
    |  ___________________________^
139 | |                         "Превышен лимит запросов к DeepSeek API",
140 | |                         self.provider_name,
141 | |                         "429",
142 | |                     )
    | |_____________________^
143 |
144 |                   if response.status_code >= 500:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:139:25
    |
137 |                         continue
138 |                     raise APIRateLimitError(
139 |                         "Превышен лимит запросов к DeepSeek API",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
140 |                         self.provider_name,
141 |                         "429",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   --> app\services\ai_providers\deepseek.py:144:44
    |
142 |                     )
143 |
144 |                 if response.status_code >= 500:
    |                                            ^^^
145 |                     if attempt < self._max_retries - 1:
146 |                         delay = self._retry_delay * (attempt + 1)
    |

E501 Line too long (107 > 88)
   --> app\services\ai_providers\deepseek.py:148:88
    |
146 |                         delay = self._retry_delay * (attempt + 1)
147 |                         logger.warning(
148 |                             f"🔄 Ошибка сервера DeepSeek {response.status_code}. Повтор через {delay}с...",
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
149 |                         )
150 |                         await asyncio.sleep(delay)
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\deepseek.py:148:101
    |
146 |                         delay = self._retry_delay * (attempt + 1)
147 |                         logger.warning(
148 |                             f"🔄 Ошибка сервера DeepSeek {response.status_code}. Повтор через {delay}с...",
    |                                                                                                      ^
149 |                         )
150 |                         await asyncio.sleep(delay)
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:152:27
    |
150 |                           await asyncio.sleep(delay)
151 |                           continue
152 |                       raise APIConnectionError(
    |  ___________________________^
153 | |                         f"Ошибка сервера DeepSeek: {response.status_code}",
154 | |                         self.provider_name,
155 | |                         str(response.status_code),
156 | |                     )
    | |_____________________^
157 |
158 |                   # Обработка других ошибок
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:153:25
    |
151 |                         continue
152 |                     raise APIConnectionError(
153 |                         f"Ошибка сервера DeepSeek: {response.status_code}",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
154 |                         self.provider_name,
155 |                         str(response.status_code),
    |
help: Assign to variable; remove f-string literal

E722 Do not use bare `except`
   --> app\services\ai_providers\deepseek.py:163:17
    |
161 |                     error_data = response.json()
162 |                     error_text = error_data.get("error", {}).get("message", "")
163 |                 except:
    |                 ^^^^^^
164 |                     error_text = response.text
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:166:23
    |
164 |                       error_text = response.text
165 |
166 |                   raise APIConnectionError(
    |  _______________________^
167 | |                     f"Неожиданный статус ответа DeepSeek: {response.status_code}. {error_text}",
168 | |                     self.provider_name,
169 | |                     str(response.status_code),
170 | |                 )
    | |_________________^
171 |
172 |               except httpx.TimeoutException:
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:167:21
    |
166 |                 raise APIConnectionError(
167 |                     f"Неожиданный статус ответа DeepSeek: {response.status_code}. {error_text}",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |                     self.provider_name,
169 |                     str(response.status_code),
    |
help: Assign to variable; remove f-string literal

E501 Line too long (96 > 88)
   --> app\services\ai_providers\deepseek.py:167:89
    |
166 |                 raise APIConnectionError(
167 |                     f"Неожиданный статус ответа DeepSeek: {response.status_code}. {error_text}",
    |                                                                                         ^^^^^^^^
168 |                     self.provider_name,
169 |                     str(response.status_code),
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\deepseek.py:176:77
    |
174 |                     delay = self._retry_delay * (attempt + 1)
175 |                     logger.warning(
176 |                         f"⏰ Timeout запроса к DeepSeek. Повтор через {delay}с...",
    |                                                                              ^
177 |                     )
178 |                     await asyncio.sleep(delay)
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_providers\deepseek.py:180:17
    |
178 |                       await asyncio.sleep(delay)
179 |                       continue
180 | /                 raise APIConnectionError(
181 | |                     "Timeout при обращении к DeepSeek API",
182 | |                     self.provider_name,
183 | |                     "timeout",
184 | |                 )
    | |_________________^
185 |
186 |               except httpx.ConnectError:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:180:23
    |
178 |                       await asyncio.sleep(delay)
179 |                       continue
180 |                   raise APIConnectionError(
    |  _______________________^
181 | |                     "Timeout при обращении к DeepSeek API",
182 | |                     self.provider_name,
183 | |                     "timeout",
184 | |                 )
    | |_________________^
185 |
186 |               except httpx.ConnectError:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:181:21
    |
179 |                     continue
180 |                 raise APIConnectionError(
181 |                     "Timeout при обращении к DeepSeek API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
182 |                     self.provider_name,
183 |                     "timeout",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\deepseek.py:190:80
    |
188 |                     delay = self._retry_delay * (attempt + 1)
189 |                     logger.warning(
190 |                         f"🌐 Ошибка подключения к DeepSeek. Повтор через {delay}с...",
    |                                                                                 ^
191 |                     )
192 |                     await asyncio.sleep(delay)
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_providers\deepseek.py:194:17
    |
192 |                       await asyncio.sleep(delay)
193 |                       continue
194 | /                 raise APIConnectionError(
195 | |                     "Не удалось подключиться к DeepSeek API",
196 | |                     self.provider_name,
197 | |                     "connection_error",
198 | |                 )
    | |_________________^
199 |
200 |           raise APIConnectionError(
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:194:23
    |
192 |                       await asyncio.sleep(delay)
193 |                       continue
194 |                   raise APIConnectionError(
    |  _______________________^
195 | |                     "Не удалось подключиться к DeepSeek API",
196 | |                     self.provider_name,
197 | |                     "connection_error",
198 | |                 )
    | |_________________^
199 |
200 |           raise APIConnectionError(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:195:21
    |
193 |                     continue
194 |                 raise APIConnectionError(
195 |                     "Не удалось подключиться к DeepSeek API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
196 |                     self.provider_name,
197 |                     "connection_error",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> app\services\ai_providers\deepseek.py:195:22
    |
193 |                     continue
194 |                 raise APIConnectionError(
195 |                     "Не удалось подключиться к DeepSeek API",
    |                      ^
196 |                     self.provider_name,
197 |                     "connection_error",
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\services\ai_providers\deepseek.py:195:23
    |
193 |                     continue
194 |                 raise APIConnectionError(
195 |                     "Не удалось подключиться к DeepSeek API",
    |                       ^
196 |                     self.provider_name,
197 |                     "connection_error",
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:200:15
    |
198 |                   )
199 |
200 |           raise APIConnectionError(
    |  _______________^
201 | |             "Исчерпаны все попытки подключения к DeepSeek API",
202 | |             self.provider_name,
203 | |             "max_retries_exceeded",
204 | |         )
    | |_________^
205 |
206 |       async def generate_response(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:201:13
    |
200 |         raise APIConnectionError(
201 |             "Исчерпаны все попытки подключения к DeepSeek API",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
202 |             self.provider_name,
203 |             "max_retries_exceeded",
    |
help: Assign to variable; remove string literal

ANN003 Missing type annotation for `**kwargs`
   --> app\services\ai_providers\deepseek.py:211:9
    |
209 |         temperature: float | None = None,
210 |         max_tokens: int | None = None,
211 |         **kwargs,
    |         ^^^^^^^^
212 |     ) -> AIResponse:
213 |         """Генерация ответа от DeepSeek AI."""
    |

ARG002 Unused method argument: `kwargs`
   --> app\services\ai_providers\deepseek.py:211:11
    |
209 |         temperature: float | None = None,
210 |         max_tokens: int | None = None,
211 |         **kwargs,
    |           ^^^^^^
212 |     ) -> AIResponse:
213 |         """Генерация ответа от DeepSeek AI."""
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:215:19
    |
213 |         """Генерация ответа от DeepSeek AI."""
214 |         if not messages:
215 |             raise ValueError("Список сообщений не может быть пустым")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |
217 |         if not self.is_configured():
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:215:30
    |
213 |         """Генерация ответа от DeepSeek AI."""
214 |         if not messages:
215 |             raise ValueError("Список сообщений не может быть пустым")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |
217 |         if not self.is_configured():
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:218:19
    |
217 |           if not self.is_configured():
218 |               raise APIAuthenticationError(
    |  ___________________^
219 | |                 "DeepSeek API не настроен. Проверьте DEEPSEEK_API_KEY в .env",
220 | |                 self.provider_name,
221 | |                 "not_configured",
222 | |             )
    | |_____________^
223 |
224 |           # Используем значения по умолчанию если не указаны
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:219:17
    |
217 |         if not self.is_configured():
218 |             raise APIAuthenticationError(
219 |                 "DeepSeek API не настроен. Проверьте DEEPSEEK_API_KEY в .env",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |                 self.provider_name,
221 |                 "not_configured",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
   --> app\services\ai_providers\deepseek.py:229:38
    |
228 |         # Валидация параметров
229 |         if not 0.0 <= temperature <= 2.0:
    |                                      ^^^
230 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:230:19
    |
228 |         # Валидация параметров
229 |         if not 0.0 <= temperature <= 2.0:
230 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
231 |
232 |         if not 1 <= max_tokens <= 4000:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:230:30
    |
228 |         # Валидация параметров
229 |         if not 0.0 <= temperature <= 2.0:
230 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
231 |
232 |         if not 1 <= max_tokens <= 4000:
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `4000` with a constant variable
   --> app\services\ai_providers\deepseek.py:232:35
    |
230 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
231 |
232 |         if not 1 <= max_tokens <= 4000:
    |                                   ^^^^
233 |             raise ValueError("max_tokens должно быть от 1 до 4000")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:233:19
    |
232 |         if not 1 <= max_tokens <= 4000:
233 |             raise ValueError("max_tokens должно быть от 1 до 4000")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
234 |
235 |         try:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:233:30
    |
232 |         if not 1 <= max_tokens <= 4000:
233 |             raise ValueError("max_tokens должно быть от 1 до 4000")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
234 |
235 |         try:
    |
help: Assign to variable; remove string literal

TRY301 Abstract `raise` to an inner function
   --> app\services\ai_providers\deepseek.py:250:17
    |
248 |               # Извлекаем ответ
249 |               if "choices" not in data or not data["choices"]:
250 | /                 raise APIConnectionError(
251 | |                     "Некорректный формат ответа от DeepSeek API",
252 | |                     self.provider_name,
253 | |                     "invalid_response",
254 | |                 )
    | |_________________^
255 |
256 |               choice = data["choices"][0]
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:250:23
    |
248 |               # Извлекаем ответ
249 |               if "choices" not in data or not data["choices"]:
250 |                   raise APIConnectionError(
    |  _______________________^
251 | |                     "Некорректный формат ответа от DeepSeek API",
252 | |                     self.provider_name,
253 | |                     "invalid_response",
254 | |                 )
    | |_________________^
255 |
256 |               choice = data["choices"][0]
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:251:21
    |
249 |             if "choices" not in data or not data["choices"]:
250 |                 raise APIConnectionError(
251 |                     "Некорректный формат ответа от DeepSeek API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
252 |                     self.provider_name,
253 |                     "invalid_response",
    |
help: Assign to variable; remove string literal

TRY301 Abstract `raise` to an inner function
   --> app\services\ai_providers\deepseek.py:260:17
    |
259 |               if not content:
260 | /                 raise APIConnectionError(
261 | |                     "Пустой ответ от DeepSeek API",
262 | |                     self.provider_name,
263 | |                     "empty_response",
264 | |                 )
    | |_________________^
265 |
266 |               # Подсчитываем токены
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:260:23
    |
259 |               if not content:
260 |                   raise APIConnectionError(
    |  _______________________^
261 | |                     "Пустой ответ от DeepSeek API",
262 | |                     self.provider_name,
263 | |                     "empty_response",
264 | |                 )
    | |_________________^
265 |
266 |               # Подсчитываем токены
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:261:21
    |
259 |             if not content:
260 |                 raise APIConnectionError(
261 |                     "Пустой ответ от DeepSeek API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
262 |                     self.provider_name,
263 |                     "empty_response",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\deepseek.py:292:61
    |
290 |             logger.info(
291 |                 f"🤖 DeepSeek ответ: {len(content)} символов, "
292 |                 f"{tokens_used} токенов, {response_time:.2f}с",
    |                                                             ^
293 |             )
294 |             return ai_response
    |

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_providers\deepseek.py:294:13
    |
292 |                 f"{tokens_used} токенов, {response_time:.2f}с",
293 |             )
294 |             return ai_response
    |             ^^^^^^^^^^^^^^^^^^
295 |
296 |         except Exception as e:
    |

UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   --> app\services\ai_providers\deepseek.py:297:16
    |
296 |           except Exception as e:
297 |               if isinstance(
    |  ________________^
298 | |                 e,
299 | |                 (
300 | |                     APIConnectionError,
301 | |                     APIRateLimitError,
302 | |                     APIAuthenticationError,
303 | |                     APIQuotaExceededError,
304 | |                 ),
305 | |             ):
    | |_____________^
306 |                   raise
    |
help: Convert to `X | Y`

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_providers\deepseek.py:309:13
    |
308 |               logger.exception("💥 Неожиданная ошибка при генерации ответа DeepSeek")
309 | /             raise APIConnectionError(
310 | |                 f"Неожиданная ошибка DeepSeek: {e!s}",
311 | |                 self.provider_name,
312 | |                 "unexpected_error",
313 | |             )
    | |_____________^
314 |
315 |       async def health_check(self) -> dict[str, Any]:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\deepseek.py:309:19
    |
308 |               logger.exception("💥 Неожиданная ошибка при генерации ответа DeepSeek")
309 |               raise APIConnectionError(
    |  ___________________^
310 | |                 f"Неожиданная ошибка DeepSeek: {e!s}",
311 | |                 self.provider_name,
312 | |                 "unexpected_error",
313 | |             )
    | |_____________^
314 |
315 |       async def health_check(self) -> dict[str, Any]:
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_providers\deepseek.py:310:17
    |
308 |             logger.exception("💥 Неожиданная ошибка при генерации ответа DeepSeek")
309 |             raise APIConnectionError(
310 |                 f"Неожиданная ошибка DeepSeek: {e!s}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
311 |                 self.provider_name,
312 |                 "unexpected_error",
    |
help: Assign to variable; remove f-string literal

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_providers\deepseek.py:333:13
    |
331 |               response_time = self._calculate_response_time(start_time)
332 |
333 | /             return {
334 | |                 "status": "healthy",
335 | |                 "provider": self.provider_name,
336 | |                 "model": self.config.deepseek_model,
337 | |                 "response_time": response_time,
338 | |                 "tokens_used": response.tokens_used,
339 | |             }
    | |_____________^
340 |
341 |           except Exception as e:
    |

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_providers\openrouter.py:30:9
   |
28 |     """Провайдер AI для OpenRouter API."""
29 |
30 |     def __init__(self):
   |         ^^^^^^^^
31 |         super().__init__("openrouter")
32 |         self.config = get_config().openrouter
   |
help: Add return type annotation: `None`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_providers\openrouter.py:42:35
   |
41 |     async def _get_client(self) -> httpx.AsyncClient:
42 |         """Получение HTTP клиента с настройками для OpenRouter."""
   |                                   ^
43 |         if self._client is None:
44 |             headers = {
   |

PLR0912 Too many branches (13 > 12)
  --> app\services\ai_providers\openrouter.py:82:15
   |
80 |         return self.config.is_configured()
81 |
82 |     async def _make_api_request(
   |               ^^^^^^^^^^^^^^^^^
83 |         self,
84 |         messages: list[dict[str, str]],
   |

PLR0915 Too many statements (51 > 50)
  --> app\services\ai_providers\openrouter.py:82:15
   |
80 |         return self.config.is_configured()
81 |
82 |     async def _make_api_request(
   |               ^^^^^^^^^^^^^^^^^
83 |         self,
84 |         messages: list[dict[str, str]],
   |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\services\ai_providers\openrouter.py:88:48
   |
86 |         max_tokens: int,
87 |     ) -> dict[str, Any]:
88 |         """Выполнение запроса к OpenRouter API с retry логикой."""
   |                                                ^
89 |         client = await self._get_client()
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   --> app\services\ai_providers\openrouter.py:110:44
    |
109 |                 # Обработка различных статусов ответа
110 |                 if response.status_code == 200:
    |                                            ^^^
111 |                     logger.info(
112 |                         f"✅ Успешный ответ от OpenRouter API за {response_time:.2f}с",
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\openrouter.py:112:84
    |
110 |                 if response.status_code == 200:
111 |                     logger.info(
112 |                         f"✅ Успешный ответ от OpenRouter API за {response_time:.2f}с",
    |                                                                                     ^
113 |                     )
114 |                     return response.json()
    |

PLR2004 Magic value used in comparison, consider replacing `401` with a constant variable
   --> app\services\ai_providers\openrouter.py:116:44
    |
114 |                     return response.json()
115 |
116 |                 if response.status_code == 401:
    |                                            ^^^
117 |                     raise APIAuthenticationError(
118 |                         "Неверный API ключ OpenRouter",
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:117:27
    |
116 |                   if response.status_code == 401:
117 |                       raise APIAuthenticationError(
    |  ___________________________^
118 | |                         "Неверный API ключ OpenRouter",
119 | |                         self.provider_name,
120 | |                         "401",
121 | |                     )
    | |_____________________^
122 |
123 |                   if response.status_code == 402:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:118:25
    |
116 |                 if response.status_code == 401:
117 |                     raise APIAuthenticationError(
118 |                         "Неверный API ключ OpenRouter",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
119 |                         self.provider_name,
120 |                         "401",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `402` with a constant variable
   --> app\services\ai_providers\openrouter.py:123:44
    |
121 |                     )
122 |
123 |                 if response.status_code == 402:
    |                                            ^^^
124 |                     raise APIQuotaExceededError(
125 |                         "Недостаточно средств на счете OpenRouter API. "
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:124:27
    |
123 |                   if response.status_code == 402:
124 |                       raise APIQuotaExceededError(
    |  ___________________________^
125 | |                         "Недостаточно средств на счете OpenRouter API. "
126 | |                         "Пополните баланс в личном кабинете OpenRouter.",
127 | |                         self.provider_name,
128 | |                         "402",
129 | |                     )
    | |_____________________^
130 |
131 |                   if response.status_code == 429:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:125:25
    |
123 |                   if response.status_code == 402:
124 |                       raise APIQuotaExceededError(
125 | /                         "Недостаточно средств на счете OpenRouter API. "
126 | |                         "Пополните баланс в личном кабинете OpenRouter.",
    | |________________________________________________________________________^
127 |                           self.provider_name,
128 |                           "402",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `429` with a constant variable
   --> app\services\ai_providers\openrouter.py:131:44
    |
129 |                     )
130 |
131 |                 if response.status_code == 429:
    |                                            ^^^
132 |                     if attempt < self._max_retries - 1:
133 |                         delay = self._retry_delay * (2**attempt)
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\openrouter.py:135:84
    |
133 |                         delay = self._retry_delay * (2**attempt)
134 |                         logger.warning(
135 |                             f"⏳ Rate limit достигнут в OpenRouter. Ожидание {delay}с...",
    |                                                                                     ^
136 |                         )
137 |                         await asyncio.sleep(delay)
    |

E501 Line too long (90 > 88)
   --> app\services\ai_providers\openrouter.py:135:88
    |
133 |                         delay = self._retry_delay * (2**attempt)
134 |                         logger.warning(
135 |                             f"⏳ Rate limit достигнут в OpenRouter. Ожидание {delay}с...",
    |                                                                                         ^^
136 |                         )
137 |                         await asyncio.sleep(delay)
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:139:27
    |
137 |                           await asyncio.sleep(delay)
138 |                           continue
139 |                       raise APIRateLimitError(
    |  ___________________________^
140 | |                         "Превышен лимит запросов к OpenRouter API",
141 | |                         self.provider_name,
142 | |                         "429",
143 | |                     )
    | |_____________________^
144 |
145 |                   if response.status_code >= 500:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:140:25
    |
138 |                         continue
139 |                     raise APIRateLimitError(
140 |                         "Превышен лимит запросов к OpenRouter API",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
141 |                         self.provider_name,
142 |                         "429",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   --> app\services\ai_providers\openrouter.py:145:44
    |
143 |                     )
144 |
145 |                 if response.status_code >= 500:
    |                                            ^^^
146 |                     if attempt < self._max_retries - 1:
147 |                         delay = self._retry_delay * (attempt + 1)
    |

E501 Line too long (109 > 88)
   --> app\services\ai_providers\openrouter.py:149:88
    |
147 | …     delay = self._retry_delay * (attempt + 1)
148 | …     logger.warning(
149 | …         f"🔄 Ошибка сервера OpenRouter {response.status_code}. Повтор через {delay}с...",
    |                                                                       ^^^^^^^^^^^^^^^^^^^^^
150 | …     )
151 | …     await asyncio.sleep(delay)
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\openrouter.py:149:103
    |
147 | …     delay = self._retry_delay * (attempt + 1)
148 | …     logger.warning(
149 | …         f"🔄 Ошибка сервера OpenRouter {response.status_code}. Повтор через {delay}с...",
    |                                                                                      ^
150 | …     )
151 | …     await asyncio.sleep(delay)
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:153:27
    |
151 |                           await asyncio.sleep(delay)
152 |                           continue
153 |                       raise APIConnectionError(
    |  ___________________________^
154 | |                         f"Ошибка сервера OpenRouter: {response.status_code}",
155 | |                         self.provider_name,
156 | |                         str(response.status_code),
157 | |                     )
    | |_____________________^
158 |
159 |                   # Обработка других ошибок
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:154:25
    |
152 |                         continue
153 |                     raise APIConnectionError(
154 |                         f"Ошибка сервера OpenRouter: {response.status_code}",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
155 |                         self.provider_name,
156 |                         str(response.status_code),
    |
help: Assign to variable; remove f-string literal

E722 Do not use bare `except`
   --> app\services\ai_providers\openrouter.py:164:17
    |
162 |                     error_data = response.json()
163 |                     error_text = error_data.get("error", {}).get("message", "")
164 |                 except:
    |                 ^^^^^^
165 |                     error_text = response.text
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:167:23
    |
165 |                       error_text = response.text
166 |
167 |                   raise APIConnectionError(
    |  _______________________^
168 | |                     f"Неожиданный статус ответа OpenRouter: {response.status_code}. {error_text}",
169 | |                     self.provider_name,
170 | |                     str(response.status_code),
171 | |                 )
    | |_________________^
172 |
173 |               except httpx.TimeoutException:
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:168:21
    |
167 |                 raise APIConnectionError(
168 |                     f"Неожиданный статус ответа OpenRouter: {response.status_code}. {error_text}",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |                     self.provider_name,
170 |                     str(response.status_code),
    |
help: Assign to variable; remove f-string literal

E501 Line too long (98 > 88)
   --> app\services\ai_providers\openrouter.py:168:89
    |
167 |                 raise APIConnectionError(
168 |                     f"Неожиданный статус ответа OpenRouter: {response.status_code}. {error_text}",
    |                                                                                         ^^^^^^^^^^
169 |                     self.provider_name,
170 |                     str(response.status_code),
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\openrouter.py:177:79
    |
175 |                     delay = self._retry_delay * (attempt + 1)
176 |                     logger.warning(
177 |                         f"⏰ Timeout запроса к OpenRouter. Повтор через {delay}с...",
    |                                                                                ^
178 |                     )
179 |                     await asyncio.sleep(delay)
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_providers\openrouter.py:181:17
    |
179 |                       await asyncio.sleep(delay)
180 |                       continue
181 | /                 raise APIConnectionError(
182 | |                     "Timeout при обращении к OpenRouter API",
183 | |                     self.provider_name,
184 | |                     "timeout",
185 | |                 )
    | |_________________^
186 |
187 |               except httpx.ConnectError:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:181:23
    |
179 |                       await asyncio.sleep(delay)
180 |                       continue
181 |                   raise APIConnectionError(
    |  _______________________^
182 | |                     "Timeout при обращении к OpenRouter API",
183 | |                     self.provider_name,
184 | |                     "timeout",
185 | |                 )
    | |_________________^
186 |
187 |               except httpx.ConnectError:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:182:21
    |
180 |                     continue
181 |                 raise APIConnectionError(
182 |                     "Timeout при обращении к OpenRouter API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |                     self.provider_name,
184 |                     "timeout",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\openrouter.py:191:82
    |
189 |                     delay = self._retry_delay * (attempt + 1)
190 |                     logger.warning(
191 |                         f"🌐 Ошибка подключения к OpenRouter. Повтор через {delay}с...",
    |                                                                                   ^
192 |                     )
193 |                     await asyncio.sleep(delay)
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_providers\openrouter.py:195:17
    |
193 |                       await asyncio.sleep(delay)
194 |                       continue
195 | /                 raise APIConnectionError(
196 | |                     "Не удалось подключиться к OpenRouter API",
197 | |                     self.provider_name,
198 | |                     "connection_error",
199 | |                 )
    | |_________________^
200 |
201 |           raise APIConnectionError(
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:195:23
    |
193 |                       await asyncio.sleep(delay)
194 |                       continue
195 |                   raise APIConnectionError(
    |  _______________________^
196 | |                     "Не удалось подключиться к OpenRouter API",
197 | |                     self.provider_name,
198 | |                     "connection_error",
199 | |                 )
    | |_________________^
200 |
201 |           raise APIConnectionError(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:196:21
    |
194 |                     continue
195 |                 raise APIConnectionError(
196 |                     "Не удалось подключиться к OpenRouter API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 |                     self.provider_name,
198 |                     "connection_error",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> app\services\ai_providers\openrouter.py:196:22
    |
194 |                     continue
195 |                 raise APIConnectionError(
196 |                     "Не удалось подключиться к OpenRouter API",
    |                      ^
197 |                     self.provider_name,
198 |                     "connection_error",
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\services\ai_providers\openrouter.py:196:23
    |
194 |                     continue
195 |                 raise APIConnectionError(
196 |                     "Не удалось подключиться к OpenRouter API",
    |                       ^
197 |                     self.provider_name,
198 |                     "connection_error",
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:201:15
    |
199 |                   )
200 |
201 |           raise APIConnectionError(
    |  _______________^
202 | |             "Исчерпаны все попытки подключения к OpenRouter API",
203 | |             self.provider_name,
204 | |             "max_retries_exceeded",
205 | |         )
    | |_________^
206 |
207 |       async def generate_response(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:202:13
    |
201 |         raise APIConnectionError(
202 |             "Исчерпаны все попытки подключения к OpenRouter API",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
203 |             self.provider_name,
204 |             "max_retries_exceeded",
    |
help: Assign to variable; remove string literal

ANN003 Missing type annotation for `**kwargs`
   --> app\services\ai_providers\openrouter.py:212:9
    |
210 |         temperature: float | None = None,
211 |         max_tokens: int | None = None,
212 |         **kwargs,
    |         ^^^^^^^^
213 |     ) -> AIResponse:
214 |         """Генерация ответа от OpenRouter AI."""
    |

ARG002 Unused method argument: `kwargs`
   --> app\services\ai_providers\openrouter.py:212:11
    |
210 |         temperature: float | None = None,
211 |         max_tokens: int | None = None,
212 |         **kwargs,
    |           ^^^^^^
213 |     ) -> AIResponse:
214 |         """Генерация ответа от OpenRouter AI."""
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:216:19
    |
214 |         """Генерация ответа от OpenRouter AI."""
215 |         if not messages:
216 |             raise ValueError("Список сообщений не может быть пустым")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |
218 |         if not self.is_configured():
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:216:30
    |
214 |         """Генерация ответа от OpenRouter AI."""
215 |         if not messages:
216 |             raise ValueError("Список сообщений не может быть пустым")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |
218 |         if not self.is_configured():
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:219:19
    |
218 |           if not self.is_configured():
219 |               raise APIAuthenticationError(
    |  ___________________^
220 | |                 "OpenRouter API не настроен. Проверьте OPENROUTER_API_KEY в .env",
221 | |                 self.provider_name,
222 | |                 "not_configured",
223 | |             )
    | |_____________^
224 |
225 |           # Используем значения по умолчанию если не указаны
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:220:17
    |
218 |         if not self.is_configured():
219 |             raise APIAuthenticationError(
220 |                 "OpenRouter API не настроен. Проверьте OPENROUTER_API_KEY в .env",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
221 |                 self.provider_name,
222 |                 "not_configured",
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
   --> app\services\ai_providers\openrouter.py:230:38
    |
229 |         # Валидация параметров
230 |         if not 0.0 <= temperature <= 2.0:
    |                                      ^^^
231 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:231:19
    |
229 |         # Валидация параметров
230 |         if not 0.0 <= temperature <= 2.0:
231 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
232 |
233 |         if not 1 <= max_tokens <= 8000:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:231:30
    |
229 |         # Валидация параметров
230 |         if not 0.0 <= temperature <= 2.0:
231 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
232 |
233 |         if not 1 <= max_tokens <= 8000:
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `8000` with a constant variable
   --> app\services\ai_providers\openrouter.py:233:35
    |
231 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
232 |
233 |         if not 1 <= max_tokens <= 8000:
    |                                   ^^^^
234 |             raise ValueError("max_tokens должно быть от 1 до 8000")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:234:19
    |
233 |         if not 1 <= max_tokens <= 8000:
234 |             raise ValueError("max_tokens должно быть от 1 до 8000")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
235 |
236 |         try:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:234:30
    |
233 |         if not 1 <= max_tokens <= 8000:
234 |             raise ValueError("max_tokens должно быть от 1 до 8000")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
235 |
236 |         try:
    |
help: Assign to variable; remove string literal

TRY301 Abstract `raise` to an inner function
   --> app\services\ai_providers\openrouter.py:251:17
    |
249 |               # Извлекаем ответ
250 |               if "choices" not in data or not data["choices"]:
251 | /                 raise APIConnectionError(
252 | |                     "Некорректный формат ответа от OpenRouter API",
253 | |                     self.provider_name,
254 | |                     "invalid_response",
255 | |                 )
    | |_________________^
256 |
257 |               choice = data["choices"][0]
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:251:23
    |
249 |               # Извлекаем ответ
250 |               if "choices" not in data or not data["choices"]:
251 |                   raise APIConnectionError(
    |  _______________________^
252 | |                     "Некорректный формат ответа от OpenRouter API",
253 | |                     self.provider_name,
254 | |                     "invalid_response",
255 | |                 )
    | |_________________^
256 |
257 |               choice = data["choices"][0]
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:252:21
    |
250 |             if "choices" not in data or not data["choices"]:
251 |                 raise APIConnectionError(
252 |                     "Некорректный формат ответа от OpenRouter API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
253 |                     self.provider_name,
254 |                     "invalid_response",
    |
help: Assign to variable; remove string literal

TRY301 Abstract `raise` to an inner function
   --> app\services\ai_providers\openrouter.py:261:17
    |
260 |               if not content:
261 | /                 raise APIConnectionError(
262 | |                     "Пустой ответ от OpenRouter API",
263 | |                     self.provider_name,
264 | |                     "empty_response",
265 | |                 )
    | |_________________^
266 |
267 |               # Подсчитываем токены
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:261:23
    |
260 |               if not content:
261 |                   raise APIConnectionError(
    |  _______________________^
262 | |                     "Пустой ответ от OpenRouter API",
263 | |                     self.provider_name,
264 | |                     "empty_response",
265 | |                 )
    | |_________________^
266 |
267 |               # Подсчитываем токены
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:262:21
    |
260 |             if not content:
261 |                 raise APIConnectionError(
262 |                     "Пустой ответ от OpenRouter API",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
263 |                     self.provider_name,
264 |                     "empty_response",
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_providers\openrouter.py:293:61
    |
291 |             logger.info(
292 |                 f"🤖 OpenRouter ответ: {len(content)} символов, "
293 |                 f"{tokens_used} токенов, {response_time:.2f}с",
    |                                                             ^
294 |             )
295 |             return ai_response
    |

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_providers\openrouter.py:295:13
    |
293 |                 f"{tokens_used} токенов, {response_time:.2f}с",
294 |             )
295 |             return ai_response
    |             ^^^^^^^^^^^^^^^^^^
296 |
297 |         except Exception as e:
    |

UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   --> app\services\ai_providers\openrouter.py:298:16
    |
297 |           except Exception as e:
298 |               if isinstance(
    |  ________________^
299 | |                 e,
300 | |                 (
301 | |                     APIConnectionError,
302 | |                     APIRateLimitError,
303 | |                     APIAuthenticationError,
304 | |                     APIQuotaExceededError,
305 | |                 ),
306 | |             ):
    | |_____________^
307 |                   raise
    |
help: Convert to `X | Y`

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_providers\openrouter.py:310:13
    |
309 |               logger.exception("💥 Неожиданная ошибка при генерации ответа OpenRouter")
310 | /             raise APIConnectionError(
311 | |                 f"Неожиданная ошибка OpenRouter: {e!s}",
312 | |                 self.provider_name,
313 | |                 "unexpected_error",
314 | |             )
    | |_____________^
315 |
316 |       async def health_check(self) -> dict[str, Any]:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_providers\openrouter.py:310:19
    |
309 |               logger.exception("💥 Неожиданная ошибка при генерации ответа OpenRouter")
310 |               raise APIConnectionError(
    |  ___________________^
311 | |                 f"Неожиданная ошибка OpenRouter: {e!s}",
312 | |                 self.provider_name,
313 | |                 "unexpected_error",
314 | |             )
    | |_____________^
315 |
316 |       async def health_check(self) -> dict[str, Any]:
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_providers\openrouter.py:311:17
    |
309 |             logger.exception("💥 Неожиданная ошибка при генерации ответа OpenRouter")
310 |             raise APIConnectionError(
311 |                 f"Неожиданная ошибка OpenRouter: {e!s}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
312 |                 self.provider_name,
313 |                 "unexpected_error",
    |
help: Assign to variable; remove f-string literal

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_providers\openrouter.py:334:13
    |
332 |               response_time = self._calculate_response_time(start_time)
333 |
334 | /             return {
335 | |                 "status": "healthy",
336 | |                 "provider": self.provider_name,
337 | |                 "model": self.config.openrouter_model,
338 | |                 "response_time": response_time,
339 | |                 "tokens_used": response.tokens_used,
340 | |             }
    | |_____________^
341 |
342 |           except Exception as e:
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> app\services\ai_service.py:3:37
  |
1 | """
2 | @file: ai_service.py
3 | @description: Сервис для интеграции с DeepSeek API для генерации ответов ИИ
  |                                     ^
4 | @dependencies: httpx, asyncio, loguru, typing
5 | @created: 2025-09-12
  |

ANN204 Missing return type annotation for special method `__init__`
  --> app\services\ai_service.py:60:9
   |
58 |     """Простой кеш для ответов AI."""
59 |
60 |     def __init__(self, ttl_seconds: int = 3600):
   |         ^^^^^^^^
61 |         self._cache: dict[str, dict[str, Any]] = {}
62 |         self._ttl = ttl_seconds
   |
help: Add return type annotation: `None`

S324 Probable use of insecure hash functions in `hashlib`: `md5`
  --> app\services\ai_service.py:70:16
   |
68 |             + model
69 |         )
70 |         return hashlib.md5(content.encode()).hexdigest()
   |                ^^^^^^^^^^^
71 |
72 |     def get(self, messages: list[ConversationMessage], model: str) -> AIResponse | None:
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> app\services\ai_service.py:78:16
   |
76 |         if key in self._cache:
77 |             entry = self._cache[key]
78 |             if datetime.now() - entry["timestamp"] < timedelta(seconds=self._ttl):
   |                ^^^^^^^^^^^^^^
79 |                 logger.debug(f"🎯 Найден кешированный ответ для ключа: {key[:8]}...")
80 |                 response = entry["response"]
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> app\services\ai_service.py:98:26
    |
 96 |         self._cache[key] = {
 97 |             "response": response,
 98 |             "timestamp": datetime.now(),
    |                          ^^^^^^^^^^^^^^
 99 |         }
100 |         logger.debug(f"💾 Ответ сохранен в кеш с ключом: {key[:8]}...")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:100:47
    |
 98 |             "timestamp": datetime.now(),
 99 |         }
100 |         logger.debug(f"💾 Ответ сохранен в кеш с ключом: {key[:8]}...")
    |                                                ^
101 |
102 |     def clear(self) -> None:
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:109:26
    |
108 | class AIService:
109 |     """Сервис для работы с DeepSeek API."""
    |                          ^
110 |
111 |     def __init__(self):
    |

ANN204 Missing return type annotation for special method `__init__`
   --> app\services\ai_service.py:111:9
    |
109 |     """Сервис для работы с DeepSeek API."""
110 |
111 |     def __init__(self):
    |         ^^^^^^^^
112 |         self.config = get_config()
113 |         self._client: httpx.AsyncClient | None = None
    |
help: Add return type annotation: `None`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:124:35
    |
123 |     async def _get_client(self) -> httpx.AsyncClient:
124 |         """Получение HTTP клиента с настройками."""
    |                                   ^
125 |         if self._client is None:
126 |             headers = {
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:182:37
    |
180 |         max_tokens: int,
181 |     ) -> dict[str, Any]:
182 |         """Выполнение запроса к API с retry логикой."""
    |                                     ^
183 |         client = await self._get_client()
    |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   --> app\services\ai_service.py:205:44
    |
204 |                 # Обработка различных статусов ответа
205 |                 if response.status_code == 200:
    |                                            ^^^
206 |                     logger.info(
207 |                         f"✅ Успешный ответ от DeepSeek API за {response_time:.2f}с",
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:207:82
    |
205 |                 if response.status_code == 200:
206 |                     logger.info(
207 |                         f"✅ Успешный ответ от DeepSeek API за {response_time:.2f}с",
    |                                                                                   ^
208 |                     )
209 |                     data = response.json()
    |

RET504 Unnecessary assignment to `data` before `return` statement
   --> app\services\ai_service.py:210:28
    |
208 |                     )
209 |                     data = response.json()
210 |                     return data
    |                            ^^^^
211 |
212 |                 if response.status_code == 401:
    |
help: Remove unnecessary assignment

PLR2004 Magic value used in comparison, consider replacing `401` with a constant variable
   --> app\services\ai_service.py:212:44
    |
210 |                     return data
211 |
212 |                 if response.status_code == 401:
    |                                            ^^^
213 |                     raise APIAuthenticationError("Неверный API ключ DeepSeek")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:213:27
    |
212 |                 if response.status_code == 401:
213 |                     raise APIAuthenticationError("Неверный API ключ DeepSeek")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
214 |
215 |                 if response.status_code == 402:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:213:50
    |
212 |                 if response.status_code == 401:
213 |                     raise APIAuthenticationError("Неверный API ключ DeepSeek")
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
214 |
215 |                 if response.status_code == 402:
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `402` with a constant variable
   --> app\services\ai_service.py:215:44
    |
213 |                     raise APIAuthenticationError("Неверный API ключ DeepSeek")
214 |
215 |                 if response.status_code == 402:
    |                                            ^^^
216 |                     raise APIAuthenticationError(
217 |                         "Недостаточно средств на счете DeepSeek API. "
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:216:27
    |
215 |                   if response.status_code == 402:
216 |                       raise APIAuthenticationError(
    |  ___________________________^
217 | |                         "Недостаточно средств на счете DeepSeek API. "
218 | |                         "Пополните баланс в личном кабинете DeepSeek.",
219 | |                     )
    | |_____________________^
220 |
221 |                   if response.status_code == 429:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:217:25
    |
215 |                   if response.status_code == 402:
216 |                       raise APIAuthenticationError(
217 | /                         "Недостаточно средств на счете DeepSeek API. "
218 | |                         "Пополните баланс в личном кабинете DeepSeek.",
    | |______________________________________________________________________^
219 |                       )
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `429` with a constant variable
   --> app\services\ai_service.py:221:44
    |
219 |                     )
220 |
221 |                 if response.status_code == 429:
    |                                            ^^^
222 |                     if attempt < self._max_retries - 1:
223 |                         delay = self._retry_delay * (2**attempt)  # Exponential backoff
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:224:82
    |
222 |                     if attempt < self._max_retries - 1:
223 |                         delay = self._retry_delay * (2**attempt)  # Exponential backoff
224 |                         logger.warning(f"⏳ Rate limit достигнут. Ожидание {delay}с...")
    |                                                                                   ^
225 |                         await asyncio.sleep(delay)
226 |                         continue
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:227:27
    |
225 |                         await asyncio.sleep(delay)
226 |                         continue
227 |                     raise APIRateLimitError("Превышен лимит запросов к DeepSeek API")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
228 |
229 |                 if response.status_code >= 500:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:227:45
    |
225 |                         await asyncio.sleep(delay)
226 |                         continue
227 |                     raise APIRateLimitError("Превышен лимит запросов к DeepSeek API")
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
228 |
229 |                 if response.status_code >= 500:
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   --> app\services\ai_service.py:229:44
    |
227 |                     raise APIRateLimitError("Превышен лимит запросов к DeepSeek API")
228 |
229 |                 if response.status_code >= 500:
    |                                            ^^^
230 |                     if attempt < self._max_retries - 1:
231 |                         delay = self._retry_delay * (attempt + 1)
    |

E501 Line too long (98 > 88)
   --> app\services\ai_service.py:233:88
    |
231 |                         delay = self._retry_delay * (attempt + 1)
232 |                         logger.warning(
233 |                             f"🔄 Ошибка сервера {response.status_code}. Повтор через {delay}с...",
    |                                                                                         ^^^^^^^^^^
234 |                         )
235 |                         await asyncio.sleep(delay)
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:233:92
    |
231 |                         delay = self._retry_delay * (attempt + 1)
232 |                         logger.warning(
233 |                             f"🔄 Ошибка сервера {response.status_code}. Повтор через {delay}с...",
    |                                                                                             ^
234 |                         )
235 |                         await asyncio.sleep(delay)
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:237:27
    |
235 |                           await asyncio.sleep(delay)
236 |                           continue
237 |                       raise APIConnectionError(
    |  ___________________________^
238 | |                         f"Ошибка сервера DeepSeek: {response.status_code}",
239 | |                     )
    | |_____________________^
240 |
241 |                   raise APIConnectionError(
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_service.py:238:25
    |
236 |                         continue
237 |                     raise APIConnectionError(
238 |                         f"Ошибка сервера DeepSeek: {response.status_code}",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
239 |                     )
    |
help: Assign to variable; remove f-string literal

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:241:23
    |
239 |                       )
240 |
241 |                   raise APIConnectionError(
    |  _______________________^
242 | |                     f"Неожиданный статус ответа: {response.status_code}",
243 | |                 )
    | |_________________^
244 |
245 |               except httpx.TimeoutException:
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_service.py:242:21
    |
241 |                 raise APIConnectionError(
242 |                     f"Неожиданный статус ответа: {response.status_code}",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
243 |                 )
    |
help: Assign to variable; remove f-string literal

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:248:77
    |
246 |                 if attempt < self._max_retries - 1:
247 |                     delay = self._retry_delay * (attempt + 1)
248 |                     logger.warning(f"⏰ Timeout запроса. Повтор через {delay}с...")
    |                                                                              ^
249 |                     await asyncio.sleep(delay)
250 |                     continue
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_service.py:251:17
    |
249 |                     await asyncio.sleep(delay)
250 |                     continue
251 |                 raise APIConnectionError("Timeout при обращении к DeepSeek API")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
252 |
253 |             except httpx.ConnectError:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:251:23
    |
249 |                     await asyncio.sleep(delay)
250 |                     continue
251 |                 raise APIConnectionError("Timeout при обращении к DeepSeek API")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
252 |
253 |             except httpx.ConnectError:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:251:42
    |
249 |                     await asyncio.sleep(delay)
250 |                     continue
251 |                 raise APIConnectionError("Timeout при обращении к DeepSeek API")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
252 |
253 |             except httpx.ConnectError:
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\services\ai_service.py:256:80
    |
254 |                 if attempt < self._max_retries - 1:
255 |                     delay = self._retry_delay * (attempt + 1)
256 |                     logger.warning(f"🌐 Ошибка подключения. Повтор через {delay}с...")
    |                                                                                 ^
257 |                     await asyncio.sleep(delay)
258 |                     continue
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_service.py:259:17
    |
257 |                     await asyncio.sleep(delay)
258 |                     continue
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:259:23
    |
257 |                     await asyncio.sleep(delay)
258 |                     continue
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:259:42
    |
257 |                     await asyncio.sleep(delay)
258 |                     continue
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |
help: Assign to variable; remove string literal

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> app\services\ai_service.py:259:43
    |
257 |                     await asyncio.sleep(delay)
258 |                     continue
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
    |                                           ^
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> app\services\ai_service.py:259:44
    |
257 |                     await asyncio.sleep(delay)
258 |                     continue
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
    |                                            ^
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:261:15
    |
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
262 |
263 |     async def generate_response(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:261:34
    |
259 |                 raise APIConnectionError("Не удалось подключиться к DeepSeek API")
260 |
261 |         raise APIConnectionError("Исчерпаны все попытки подключения к API")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
262 |
263 |     async def generate_response(
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:283:19
    |
281 |         """
282 |         if not messages:
283 |             raise ValueError("Список сообщений не может быть пустым")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
284 |
285 |         # Используем значения по умолчанию если не указаны
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:283:30
    |
281 |         """
282 |         if not messages:
283 |             raise ValueError("Список сообщений не может быть пустым")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
284 |
285 |         # Используем значения по умолчанию если не указаны
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
   --> app\services\ai_service.py:290:38
    |
289 |         # Валидация параметров
290 |         if not 0.0 <= temperature <= 2.0:
    |                                      ^^^
291 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:291:19
    |
289 |         # Валидация параметров
290 |         if not 0.0 <= temperature <= 2.0:
291 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
292 |
293 |         if not 1 <= max_tokens <= 4000:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:291:30
    |
289 |         # Валидация параметров
290 |         if not 0.0 <= temperature <= 2.0:
291 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
292 |
293 |         if not 1 <= max_tokens <= 4000:
    |
help: Assign to variable; remove string literal

PLR2004 Magic value used in comparison, consider replacing `4000` with a constant variable
   --> app\services\ai_service.py:293:35
    |
291 |             raise ValueError("Temperature должна быть от 0.0 до 2.0")
292 |
293 |         if not 1 <= max_tokens <= 4000:
    |                                   ^^^^
294 |             raise ValueError("max_tokens должно быть от 1 до 4000")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:294:19
    |
293 |         if not 1 <= max_tokens <= 4000:
294 |             raise ValueError("max_tokens должно быть от 1 до 4000")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
295 |
296 |         # Проверяем кеш
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:294:30
    |
293 |         if not 1 <= max_tokens <= 4000:
294 |             raise ValueError("max_tokens должно быть от 1 до 4000")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
295 |
296 |         # Проверяем кеш
    |
help: Assign to variable; remove string literal

TRY301 Abstract `raise` to an inner function
   --> app\services\ai_service.py:320:17
    |
318 |             # Извлекаем ответ
319 |             if "choices" not in data or not data["choices"]:
320 |                 raise APIConnectionError("Некорректный формат ответа от DeepSeek API")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
321 |
322 |             choice = data["choices"][0]
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:320:23
    |
318 |             # Извлекаем ответ
319 |             if "choices" not in data or not data["choices"]:
320 |                 raise APIConnectionError("Некорректный формат ответа от DeepSeek API")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
321 |
322 |             choice = data["choices"][0]
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:320:42
    |
318 |             # Извлекаем ответ
319 |             if "choices" not in data or not data["choices"]:
320 |                 raise APIConnectionError("Некорректный формат ответа от DeepSeek API")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
321 |
322 |             choice = data["choices"][0]
    |
help: Assign to variable; remove string literal

TRY301 Abstract `raise` to an inner function
   --> app\services\ai_service.py:326:17
    |
325 |             if not content:
326 |                 raise APIConnectionError("Пустой ответ от DeepSeek API")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
327 |
328 |             # Подсчитываем токены (приблизительно)
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:326:23
    |
325 |             if not content:
326 |                 raise APIConnectionError("Пустой ответ от DeepSeek API")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
327 |
328 |             # Подсчитываем токены (приблизительно)
    |

EM101 Exception must not use a string literal, assign to variable first
   --> app\services\ai_service.py:326:42
    |
325 |             if not content:
326 |                 raise APIConnectionError("Пустой ответ от DeepSeek API")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
327 |
328 |             # Подсчитываем токены (приблизительно)
    |
help: Assign to variable; remove string literal

E501 Line too long (89 > 88)
   --> app\services\ai_service.py:352:88
    |
351 |             logger.info(
352 |                 f"🤖 Сгенерирован ответ: {len(content)} символов, {tokens_used} токенов",
    |                                                                                         ^
353 |             )
354 |             return ai_response
    |

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_service.py:354:13
    |
352 |                 f"🤖 Сгенерирован ответ: {len(content)} символов, {tokens_used} токенов",
353 |             )
354 |             return ai_response
    |             ^^^^^^^^^^^^^^^^^^
355 |
356 |         except AIServiceError:
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app\services\ai_service.py:362:13
    |
360 |         except Exception as e:
361 |             logger.exception("💥 Неожиданная ошибка при генерации ответа AI")
362 |             raise AIServiceError(f"Неожиданная ошибка: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
363 |
364 |     async def generate_simple_response(self, user_message: str) -> AIResponse:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> app\services\ai_service.py:362:19
    |
360 |         except Exception as e:
361 |             logger.exception("💥 Неожиданная ошибка при генерации ответа AI")
362 |             raise AIServiceError(f"Неожиданная ошибка: {e!s}")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
363 |
364 |     async def generate_simple_response(self, user_message: str) -> AIResponse:
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> app\services\ai_service.py:362:34
    |
360 |         except Exception as e:
361 |             logger.exception("💥 Неожиданная ошибка при генерации ответа AI")
362 |             raise AIServiceError(f"Неожиданная ошибка: {e!s}")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
363 |
364 |     async def generate_simple_response(self, user_message: str) -> AIResponse:
    |
help: Assign to variable; remove f-string literal

E501 Line too long (96 > 88)
   --> app\services\ai_service.py:377:89
    |
375 | …     ConversationMessage(
376 | …         role="system",
377 | …         content="Ты - эмпатичный AI-помощник. Отвечай доброжелательно и поддерживающе.",
    |                                                                                   ^^^^^^^^
378 | …     ),
379 | …     ConversationMessage(
    |

TRY300 Consider moving this statement to an `else` block
   --> app\services\ai_service.py:402:13
    |
400 |               response_time = asyncio.get_event_loop().time() - start_time
401 |
402 | /             return {
403 | |                 "status": "healthy",
404 | |                 "model": self.config.deepseek.deepseek_model,
405 | |                 "response_time": response_time,
406 | |                 "tokens_used": response.tokens_used,
407 | |                 "cache_enabled": True,
408 | |             }
    | |_____________^
409 |
410 |           except Exception as e:
    |

PLW0603 Using the global statement to update `_ai_service_instance` is discouraged
   --> app\services\ai_service.py:424:12
    |
422 | def get_ai_service() -> AIService:
423 |     """Получение экземпляра AI сервиса."""
424 |     global _ai_service_instance
    |            ^^^^^^^^^^^^^^^^^^^^
425 |
426 |     if _ai_service_instance is None:
    |

PLW0603 Using the global statement to update `_ai_service_instance` is discouraged
   --> app\services\ai_service.py:435:12
    |
433 | async def close_ai_service() -> None:
434 |     """Закрытие AI сервиса."""
435 |     global _ai_service_instance
    |            ^^^^^^^^^^^^^^^^^^^^
436 |
437 |     if _ai_service_instance:
    |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> app\utils\logging.py:44:28
   |
42 |         log_entry["extra"] = record["extra"]
43 |
44 |     # Добавляем информацию об исключении если есть
   |                            ^
45 |     if record["exception"]:
46 |         log_entry["exception"] = {
   |

RUF003 Comment contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
  --> app\utils\logging.py:44:29
   |
42 |         log_entry["extra"] = record["extra"]
43 |
44 |     # Добавляем информацию об исключении если есть
   |                             ^
45 |     if record["exception"]:
46 |         log_entry["exception"] = {
   |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> app\utils\logging.py:57:38
   |
55 | def console_formatter(record: dict[str, Any]) -> str:
56 |     """
57 |     Форматирование логов для консоли с эмодзи и цветами.
   |                                      ^
58 |
59 |     Args:
   |

RUF001 String contains ambiguous `ℹ` (INFORMATION SOURCE). Did you mean `i` (LATIN SMALL LETTER I)?
  --> app\utils\logging.py:69:18
   |
67 |         "TRACE": "🔍",
68 |         "DEBUG": "🐛",
69 |         "INFO": "ℹ️",
   |                  ^
70 |         "SUCCESS": "✅",
71 |         "WARNING": "⚠️",
   |

E501 Line too long (91 > 88)
   --> app\utils\logging.py:209:88
    |
207 |     logger.debug(f"📋 Консольный вывод: {'включен' if enable_console else 'отключен'}")
208 |     logger.debug(
209 |         f"🌐 Логирование запросов: {'включено' if enable_request_logging else 'отключено'}"
    |                                                                                         ^^^
210 |     )
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> app\utils\logging.py:228:32
    |
226 | def log_function_call(func_name: str, **kwargs: Any) -> None:
227 |     """
228 |     Логирование вызова функции с параметрами.
    |                                ^
229 |
230 |     Args:
    |

E402 Module level import not at top of file
  --> clear_webhook.py:16:1
   |
14 | sys.path.insert(0, str(project_root))
15 |
16 | import httpx
   | ^^^^^^^^^^^^
17 | from loguru import logger
   |

E402 Module level import not at top of file
  --> clear_webhook.py:17:1
   |
16 | import httpx
17 | from loguru import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
18 |
19 | from app.config import get_config
   |

E402 Module level import not at top of file
  --> clear_webhook.py:19:1
   |
17 | from loguru import logger
18 |
19 | from app.config import get_config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

PLR0912 Too many branches (14 > 12)
  --> clear_webhook.py:22:11
   |
22 | async def clear_webhook():
   |           ^^^^^^^^^^^^^
23 |     """Очистка webhook для решения конфликтов."""
24 |     logger.info("🔧 Начинаем очистку webhook...")
   |

ANN201 Missing return type annotation for public function `clear_webhook`
  --> clear_webhook.py:22:11
   |
22 | async def clear_webhook():
   |           ^^^^^^^^^^^^^
23 |     """Очистка webhook для решения конфликтов."""
24 |     logger.info("🔧 Начинаем очистку webhook...")
   |
help: Add return type annotation: `bool`

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> clear_webhook.py:34:34
   |
33 |         bot_token = config.telegram.bot_token
34 |         logger.info(f"🤖 Работаем с ботом: ...{bot_token[-10:]}")
   |                                   ^
35 |
36 |         async with httpx.AsyncClient(timeout=30.0) as client:
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> clear_webhook.py:37:43
   |
36 |         async with httpx.AsyncClient(timeout=30.0) as client:
37 |             # Получаем текущую информацию о webhook
   |                                           ^
38 |             info_url = f"https://api.telegram.org/bot{bot_token}/getWebhookInfo"
39 |             logger.info("📋 Получаем информацию о текущем webhook...")
   |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> clear_webhook.py:39:48
   |
37 |             # Получаем текущую информацию о webhook
38 |             info_url = f"https://api.telegram.org/bot{bot_token}/getWebhookInfo"
39 |             logger.info("📋 Получаем информацию о текущем webhook...")
   |                                                 ^
40 |
41 |             info_response = await client.get(info_url)
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
  --> clear_webhook.py:42:45
   |
41 |             info_response = await client.get(info_url)
42 |             if info_response.status_code == 200:
   |                                             ^^^
43 |                 info_data = info_response.json()
44 |                 if info_data.get("ok"):
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
  --> clear_webhook.py:69:47
   |
67 |             )
68 |
69 |             if delete_response.status_code == 200:
   |                                               ^^^
70 |                 delete_data = delete_response.json()
71 |                 if delete_data.get("ok"):
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
  --> clear_webhook.py:76:54
   |
74 |                     # Проверяем результат
75 |                     check_response = await client.get(info_url)
76 |                     if check_response.status_code == 200:
   |                                                      ^^^
77 |                         check_data = check_response.json()
78 |                         if check_data.get("ok"):
   |

E501 Line too long (90 > 88)
  --> clear_webhook.py:88:88
   |
86 |             else:
87 |                 logger.error(
88 |                     f"❌ HTTP ошибка при удалении webhook: {delete_response.status_code}",
   |                                                                                         ^^
89 |                 )
   |

ANN201 Missing return type annotation for public function `wait_for_conflict_resolution`
   --> clear_webhook.py:99:11
    |
 99 | async def wait_for_conflict_resolution():
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |     """Ожидание разрешения конфликта."""
101 |     logger.info("⏳ Ждем разрешения конфликта (30 секунд)...")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `main`
   --> clear_webhook.py:106:11
    |
106 | async def main():
    |           ^^^^
107 |     """Основная функция."""
108 |     logger.add("webhook_clear.log", rotation="1 MB", retention="1 week")
    |
help: Add return type annotation: `None`

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> clear_webhook.py:123:25
    |
121 |         logger.info("💡 Выполните: uv run python main.py")
122 |     else:
123 |         logger.error("😞 Не удалось очистить webhook")
    |                          ^
124 |         logger.info("💡 Рекомендации:")
125 |         logger.info("   1. Проверьте токен бота в .env")
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> clear_webhook.py:123:26
    |
121 |         logger.info("💡 Выполните: uv run python main.py")
122 |     else:
123 |         logger.error("😞 Не удалось очистить webhook")
    |                           ^
124 |         logger.info("💡 Рекомендации:")
125 |         logger.info("   1. Проверьте токен бота в .env")
    |

E402 Module level import not at top of file
  --> force_stop_bot.py:18:1
   |
16 | sys.path.insert(0, str(project_root))
17 |
18 | import httpx
   | ^^^^^^^^^^^^
19 | from loguru import logger
   |

E402 Module level import not at top of file
  --> force_stop_bot.py:19:1
   |
18 | import httpx
19 | from loguru import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |
21 | from app.config import get_config
   |

E402 Module level import not at top of file
  --> force_stop_bot.py:21:1
   |
19 | from loguru import logger
20 |
21 | from app.config import get_config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `kill_python_processes`
  --> force_stop_bot.py:24:5
   |
24 | def kill_python_processes():
   |     ^^^^^^^^^^^^^^^^^^^^^
25 |     """Принудительное завершение всех процессов Python."""
26 |     logger.info("🔪 Принудительное завершение всех процессов Python...")
   |
help: Add return type annotation: `None`

S607 Starting a process with a partial executable path
  --> force_stop_bot.py:31:13
   |
29 |         # Windows команда для завершения процессов Python
30 |         result = subprocess.run(
31 |             ["taskkill", "/F", "/IM", "python.exe"],
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |             check=False,
33 |             capture_output=True,
   |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> force_stop_bot.py:39:31
   |
38 |         if result.returncode == 0:
39 |             logger.success("✅ Все процессы Python завершены")
   |                                ^
40 |         else:
41 |             logger.warning(f"⚠️ Команда taskkill вернула код: {result.returncode}")
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> force_stop_bot.py:39:32
   |
38 |         if result.returncode == 0:
39 |             logger.success("✅ Все процессы Python завершены")
   |                                 ^
40 |         else:
41 |             logger.warning(f"⚠️ Команда taskkill вернула код: {result.returncode}")
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> force_stop_bot.py:39:33
   |
38 |         if result.returncode == 0:
39 |             logger.success("✅ Все процессы Python завершены")
   |                                  ^
40 |         else:
41 |             logger.warning(f"⚠️ Команда taskkill вернула код: {result.returncode}")
   |

ANN201 Missing return type annotation for public function `clear_webhook_completely`
  --> force_stop_bot.py:50:11
   |
50 | async def clear_webhook_completely():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^
51 |     """Полная очистка webhook с несколькими попытками."""
52 |     logger.info("🧹 Полная очистка webhook...")
   |
help: Add return type annotation: `bool`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> force_stop_bot.py:51:31
   |
50 | async def clear_webhook_completely():
51 |     """Полная очистка webhook с несколькими попытками."""
   |                               ^
52 |     logger.info("🧹 Полная очистка webhook...")
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
  --> force_stop_bot.py:78:48
   |
76 |                     )
77 |
78 |                     if response.status_code == 200:
   |                                                ^^^
79 |                         data = response.json()
80 |                         if data.get("ok"):
   |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
  --> force_stop_bot.py:91:30
   |
90 |                 # Пауза между попытками
91 |                 if attempt < 2:
   |                              ^
92 |                     await asyncio.sleep(2)
   |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   --> force_stop_bot.py:99:49
    |
 97 |                 info_response = await client.get(info_url)
 98 |
 99 |                 if info_response.status_code == 200:
    |                                                 ^^^
100 |                     info_data = info_response.json()
101 |                     if info_data.get("ok"):
    |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> force_stop_bot.py:116:37
    |
115 |             except Exception as e:
116 |                 logger.warning(f"⚠️ Не удалось проверить статус webhook: {e}")
    |                                    ^
117 |
118 |     except Exception as e:
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> force_stop_bot.py:116:38
    |
115 |             except Exception as e:
116 |                 logger.warning(f"⚠️ Не удалось проверить статус webhook: {e}")
    |                                     ^
117 |
118 |     except Exception as e:
    |

ANN201 Missing return type annotation for public function `wait_for_system_stabilization`
   --> force_stop_bot.py:124:5
    |
124 | def wait_for_system_stabilization():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |     """Ожидание стабилизации системы."""
126 |     logger.info("⏳ Ожидание стабилизации системы (60 секунд)...")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_bot_readiness`
   --> force_stop_bot.py:135:11
    |
135 | async def test_bot_readiness():
    |           ^^^^^^^^^^^^^^^^^^
136 |     """Тест готовности бота к запуску."""
137 |     logger.info("🧪 Тестирование готовности бота...")
    |
help: Add return type annotation: `bool`

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   --> force_stop_bot.py:153:40
    |
151 |             response = await client.get(me_url)
152 |
153 |             if response.status_code == 200:
    |                                        ^^^
154 |                 data = response.json()
155 |                 if data.get("ok"):
    |

ANN201 Missing return type annotation for public function `main`
   --> force_stop_bot.py:170:11
    |
170 | async def main():
    |           ^^^^
171 |     """Основная функция принудительной остановки."""
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
    |
help: Add return type annotation: `None`

RUF001 String contains ambiguous `О` (CYRILLIC CAPITAL LETTER O). Did you mean `O` (LATIN CAPITAL LETTER O)?
   --> force_stop_bot.py:174:35
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                    ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `С` (CYRILLIC CAPITAL LETTER ES). Did you mean `C` (LATIN CAPITAL LETTER C)?
   --> force_stop_bot.py:174:36
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                     ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `Т` (CYRILLIC CAPITAL LETTER TE). Did you mean `T` (LATIN CAPITAL LETTER T)?
   --> force_stop_bot.py:174:37
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                      ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `А` (CYRILLIC CAPITAL LETTER A). Did you mean `A` (LATIN CAPITAL LETTER A)?
   --> force_stop_bot.py:174:38
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                       ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> force_stop_bot.py:174:39
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                        ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `О` (CYRILLIC CAPITAL LETTER O). Did you mean `O` (LATIN CAPITAL LETTER O)?
   --> force_stop_bot.py:174:40
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                         ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> force_stop_bot.py:174:41
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                          ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `К` (CYRILLIC CAPITAL LETTER KA). Did you mean `K` (LATIN CAPITAL LETTER K)?
   --> force_stop_bot.py:174:42
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                           ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `А` (CYRILLIC CAPITAL LETTER A). Did you mean `A` (LATIN CAPITAL LETTER A)?
   --> force_stop_bot.py:174:43
    |
172 |     logger.add("force_stop.log", rotation="1 MB", retention="1 week")
173 |
174 |     logger.info("🛑 ПРИНУДИТЕЛЬНАЯ ОСТАНОВКА БОТА")
    |                                            ^
175 |     logger.info("=" * 60)
    |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> force_stop_bot.py:206:25
    |
204 |         logger.info("   uv run python main.py")
205 |     else:
206 |         logger.error("😞 Не все проблемы решены")
    |                          ^
207 |         logger.info("💡 Рекомендации:")
208 |         if not webhook_cleared:
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> force_stop_bot.py:206:26
    |
204 |         logger.info("   uv run python main.py")
205 |     else:
206 |         logger.error("😞 Не все проблемы решены")
    |                           ^
207 |         logger.info("💡 Рекомендации:")
208 |         if not webhook_cleared:
    |

ANN204 Missing return type annotation for special method `__init__`
  --> main.py:31:9
   |
29 |     """Основной класс Telegram бота AI-Компаньон."""
30 |
31 |     def __init__(self):
   |         ^^^^^^^^
32 |         self.config = get_config()
33 |         self.bot: Bot | None = None
   |
help: Add return type annotation: `None`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> main.py:38:37
   |
37 |     def create_bot(self) -> Bot:
38 |         """Создание экземпляра бота с настройками."""
   |                                     ^
39 |         return Bot(
40 |             token=self.config.telegram.bot_token
   |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> main.py:50:32
   |
49 |     def create_dispatcher(self) -> Dispatcher:
50 |         """Создание диспетчера с middleware и обработчиками."""
   |                                ^
51 |         dp = Dispatcher()
   |

ERA001 Found commented-out code
  --> main.py:54:9
   |
53 |         # Регистрация middleware будет здесь
54 |         # self.register_middleware(dp)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |
56 |         # Регистрация обработчиков
   |
help: Remove commented-out code

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> main.py:74:70
   |
73 |         commands = [
74 |             BotCommand(command="start", description="🚀 Начать работу с ботом"),
   |                                                                       ^
75 |             BotCommand(command="help", description="❓ Справка по командам"),
76 |             BotCommand(command="profile", description="👤 Мой профиль"),
   |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> main.py:97:36
   |
95 |             self.dp = self.create_dispatcher()
96 |
97 |             # Получение информации о боте
   |                                    ^
98 |             bot_info = await self.bot.get_me()
99 |             logger.info(f"🤖 Бот запущен: @{bot_info.username} ({bot_info.full_name})")
   |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:115:36
    |
114 |         try:
115 |             # Остановка диспетчера с таймаутом
    |                                    ^
116 |             if self.dp:
117 |                 try:
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:123:36
    |
121 |                     logger.warning("⚠️ Таймаут при остановке polling")
122 |
123 |             # Закрытие сессии бота с таймаутом
    |                                    ^
124 |             if self.bot:
125 |                 try:
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:131:41
    |
129 |                     logger.warning("⚠️ Таймаут при закрытии сессии бота")
130 |
131 |             # Закрытие подключения к БД с таймаутом
    |                                         ^
132 |             try:
133 |                 await asyncio.wait_for(close_db(), timeout=5.0)
    |

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:138:37
    |
136 |                 logger.warning("⚠️ Таймаут при закрытии БД")
137 |
138 |             # Закрытие AI менеджера с таймаутом
    |                                     ^
139 |             try:
140 |                 await asyncio.wait_for(close_ai_manager(), timeout=5.0)
    |

ANN202 Missing return type annotation for private function `_signal_handler`
   --> main.py:160:9
    |
158 |             signal.signal(signal.SIGINT, self._signal_handler)
159 |
160 |     def _signal_handler(self, signum, frame):
    |         ^^^^^^^^^^^^^^^
161 |         """Обработчик сигналов завершения."""
162 |         logger.info(f"📡 Получен сигнал {signum}, инициирую завершение работы...")
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `signum`
   --> main.py:160:31
    |
158 |             signal.signal(signal.SIGINT, self._signal_handler)
159 |
160 |     def _signal_handler(self, signum, frame):
    |                               ^^^^^^
161 |         """Обработчик сигналов завершения."""
162 |         logger.info(f"📡 Получен сигнал {signum}, инициирую завершение работы...")
    |

ANN001 Missing type annotation for function argument `frame`
   --> main.py:160:39
    |
158 |             signal.signal(signal.SIGINT, self._signal_handler)
159 |
160 |     def _signal_handler(self, signum, frame):
    |                                       ^^^^^
161 |         """Обработчик сигналов завершения."""
162 |         logger.info(f"📡 Получен сигнал {signum}, инициирую завершение работы...")
    |

ARG002 Unused method argument: `frame`
   --> main.py:160:39
    |
158 |             signal.signal(signal.SIGINT, self._signal_handler)
159 |
160 |     def _signal_handler(self, signum, frame):
    |                                       ^^^^^
161 |         """Обработчик сигналов завершения."""
162 |         logger.info(f"📡 Получен сигнал {signum}, инициирую завершение работы...")
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:166:41
    |
165 |     async def run_polling(self) -> None:
166 |         """Запуск бота в режиме polling с поддержкой graceful shutdown."""
    |                                         ^
167 |         if not self.dp or not self.bot:
168 |             raise RuntimeError("Бот или диспетчер не инициализированы")
    |

TRY003 Avoid specifying long messages outside the exception class
   --> main.py:168:19
    |
166 |         """Запуск бота в режиме polling с поддержкой graceful shutdown."""
167 |         if not self.dp or not self.bot:
168 |             raise RuntimeError("Бот или диспетчер не инициализированы")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |
170 |         logger.info("📡 Запуск в режиме polling...")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> main.py:168:32
    |
166 |         """Запуск бота в режиме polling с поддержкой graceful shutdown."""
167 |         if not self.dp or not self.bot:
168 |             raise RuntimeError("Бот или диспетчер не инициализированы")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |
170 |         logger.info("📡 Запуск в режиме polling...")
    |
help: Assign to variable; remove string literal

SIM105 Use `contextlib.suppress(asyncio.CancelledError)` instead of `try`-`except`-`pass`
   --> main.py:194:17
    |
192 |               for task in pending:
193 |                   task.cancel()
194 | /                 try:
195 | |                     await task
196 | |                 except asyncio.CancelledError:
197 | |                     pass
    | |________________________^
198 |
199 |               # Если polling завершился с ошибкой, проверим это
    |
help: Replace with `contextlib.suppress(asyncio.CancelledError)`

RUF003 Comment contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:199:39
    |
197 |                     pass
198 |
199 |             # Если polling завершился с ошибкой, проверим это
    |                                       ^
200 |             if polling_task in done:
201 |                 try:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> main.py:214:19
    |
212 |         """Запуск бота в режиме webhook (для продакшена)."""
213 |         if not self.config.telegram or not self.config.telegram.webhook_url:
214 |             raise ValueError("WEBHOOK_URL не настроен для режима webhook")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
215 |
216 |         if not self.bot or not self.dp:
    |

EM101 Exception must not use a string literal, assign to variable first
   --> main.py:214:30
    |
212 |         """Запуск бота в режиме webhook (для продакшена)."""
213 |         if not self.config.telegram or not self.config.telegram.webhook_url:
214 |             raise ValueError("WEBHOOK_URL не настроен для режима webhook")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
215 |
216 |         if not self.bot or not self.dp:
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> main.py:217:19
    |
216 |         if not self.bot or not self.dp:
217 |             raise RuntimeError("Бот или диспетчер не инициализированы")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |
219 |         logger.info(f"🌐 Запуск в режиме webhook: {self.config.telegram.webhook_url}")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> main.py:217:32
    |
216 |         if not self.bot or not self.dp:
217 |             raise RuntimeError("Бот или диспетчер не инициализированы")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |
219 |         logger.info(f"🌐 Запуск в режиме webhook: {self.config.telegram.webhook_url}")
    |
help: Assign to variable; remove string literal

RUF003 Comment contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> main.py:245:19
    |
243 |             else:
244 |                 await self.run_webhook()
245 |                 # В режиме webhook нужно поддерживать приложение активным
    |                   ^
246 |                 await self._shutdown_event.wait()
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> main.py:251:49
    |
250 |         except KeyboardInterrupt:
251 |             logger.info("⌨️ Получено прерывание с клавиатуры")
    |                                                ^
252 |         except Exception as e:
253 |             logger.error(f"💥 Критическая ошибка: {e}")
    |

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> main.py:291:13
    |
289 |           logger.error(f"💥 Критическая ошибка при запуске: {e}")
290 |           if bot_app:
291 | /             try:
292 | |                 await bot_app.shutdown()
293 | |             except Exception:
294 | |                 pass
    | |____________________^
295 |           sys.exit(1)
296 |       finally:
    |
help: Replace with `contextlib.suppress(Exception)`

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> main.py:293:13
    |
291 |               try:
292 |                   await bot_app.shutdown()
293 | /             except Exception:
294 | |                 pass
    | |____________________^
295 |           sys.exit(1)
296 |       finally:
    |

T201 `print` found
   --> main.py:309:9
    |
307 |         asyncio.run(main())
308 |     except KeyboardInterrupt:
309 |         print("\n👋 Завершение по Ctrl+C")
    |         ^^^^^
310 |     except Exception as e:
311 |         print(f"\n💥 Критическая ошибка: {e}")
    |
help: Remove `print`

T201 `print` found
   --> main.py:311:9
    |
309 |         print("\n👋 Завершение по Ctrl+C")
310 |     except Exception as e:
311 |         print(f"\n💥 Критическая ошибка: {e}")
    |         ^^^^^
312 |         sys.exit(1)
    |
help: Remove `print`

E402 Module level import not at top of file
  --> scripts\checks\test_config_simple.py:16:1
   |
14 | sys.path.insert(0, str(project_root))
15 |
16 | from loguru import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `test_env_file`
  --> scripts\checks\test_config_simple.py:19:5
   |
19 | def test_env_file():
   |     ^^^^^^^^^^^^^
20 |     """Тестирование наличия и содержимого .env файла."""
21 |     env_path = Path(".env")
   |
help: Add return type annotation: `bool`

PTH123 `open()` should be replaced by `Path.open()`
  --> scripts\checks\test_config_simple.py:30:10
   |
29 |     # Читаем содержимое
30 |     with open(env_path, encoding="utf-8") as f:
   |          ^^^^
31 |         content = f.read()
   |

ANN201 Missing return type annotation for public function `test_basic_config`
  --> scripts\checks\test_config_simple.py:56:5
   |
56 | def test_basic_config():
   |     ^^^^^^^^^^^^^^^^^
57 |     """Тестирование базовой загрузки конфигурации."""
58 |     try:
   |
help: Add return type annotation: `bool | None`

PLC0415 `import` should be at the top-level of a file
  --> scripts\checks\test_config_simple.py:59:9
   |
57 |     """Тестирование базовой загрузки конфигурации."""
58 |     try:
59 |         from app.config import DatabaseConfig, TelegramConfig
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
60 |
61 |         # Тестируем DatabaseConfig
   |

TRY300 Consider moving this statement to an `else` block
  --> scripts\checks\test_config_simple.py:71:9
   |
69 |         logger.info(f"✅ Bot token: {tg_config.bot_token[:10]}...")
70 |
71 |         return True
   |         ^^^^^^^^^^^
72 |
73 |     except Exception as e:
   |

ANN201 Missing return type annotation for public function `main`
  --> scripts\checks\test_config_simple.py:78:5
   |
78 | def main():
   |     ^^^^
79 |     """Главная функция тестирования."""
80 |     logger.remove()
   |
help: Add return type annotation: `None`

E501 Line too long (102 > 88)
  --> scripts\checks\test_config_simple.py:83:89
   |
81 |     logger.add(
82 |         sys.stdout,
83 |         format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{message}</cyan>",
   |                                                                                         ^^^^^^^^^^^^^^
84 |         level="INFO",
85 |     )
   |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
   --> scripts\checks\test_config_simple.py:103:27
    |
102 |     if config_ok:
103 |         logger.success("🎉 Все тесты пройдены!")
    |                            ^
104 |     else:
105 |         logger.error("💔 Тест конфигурации провален")
    |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> scripts\checks\test_config_simple.py:103:28
    |
102 |     if config_ok:
103 |         logger.success("🎉 Все тесты пройдены!")
    |                             ^
104 |     else:
105 |         logger.error("💔 Тест конфигурации провален")
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> scripts\checks\test_config_simple.py:103:29
    |
102 |     if config_ok:
103 |         logger.success("🎉 Все тесты пройдены!")
    |                              ^
104 |     else:
105 |         logger.error("💔 Тест конфигурации провален")
    |

E402 Module level import not at top of file
  --> scripts\checks\test_db_connection.py:17:1
   |
15 | sys.path.insert(0, str(project_root))
16 |
17 | from loguru import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
18 |
19 | from app.config import get_config
   |

E402 Module level import not at top of file
  --> scripts\checks\test_db_connection.py:19:1
   |
17 | from loguru import logger
18 |
19 | from app.config import get_config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 | from app.database import check_connection, close_db, init_db
   |

E402 Module level import not at top of file
  --> scripts\checks\test_db_connection.py:20:1
   |
19 | from app.config import get_config
20 | from app.database import check_connection, close_db, init_db
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

E501 Line too long (129 > 88)
  --> scripts\checks\test_db_connection.py:32:88
   |
30 | …     logger.info("✅ Конфигурация загружена успешно")
31 | …     logger.info(
32 | …         f"📊 DATABASE_URL: {config.database.database_url.split('@')[1] if '@' in config.database.database_url else 'скрыт'}",
   |                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 | …     )
   |

PLC0415 `import` should be at the top-level of a file
  --> scripts\checks\test_db_connection.py:65:9
   |
64 |     try:
65 |         from app.models import Base, Conversation, User
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |         from app.models.conversation import ConversationCreate, MessageRole
67 |         from app.models.user import UserCreate, UserResponse
   |

F401 `app.models.Conversation` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> scripts\checks\test_db_connection.py:65:38
   |
64 |     try:
65 |         from app.models import Base, Conversation, User
   |                                      ^^^^^^^^^^^^
66 |         from app.models.conversation import ConversationCreate, MessageRole
67 |         from app.models.user import UserCreate, UserResponse
   |
help: Remove unused import

F401 `app.models.User` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> scripts\checks\test_db_connection.py:65:52
   |
64 |     try:
65 |         from app.models import Base, Conversation, User
   |                                                    ^^^^
66 |         from app.models.conversation import ConversationCreate, MessageRole
67 |         from app.models.user import UserCreate, UserResponse
   |
help: Remove unused import

PLC0415 `import` should be at the top-level of a file
  --> scripts\checks\test_db_connection.py:66:9
   |
64 |     try:
65 |         from app.models import Base, Conversation, User
66 |         from app.models.conversation import ConversationCreate, MessageRole
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |         from app.models.user import UserCreate, UserResponse
   |

F401 `app.models.conversation.ConversationCreate` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> scripts\checks\test_db_connection.py:66:45
   |
64 |     try:
65 |         from app.models import Base, Conversation, User
66 |         from app.models.conversation import ConversationCreate, MessageRole
   |                                             ^^^^^^^^^^^^^^^^^^
67 |         from app.models.user import UserCreate, UserResponse
   |
help: Remove unused import

F401 `app.models.conversation.MessageRole` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> scripts\checks\test_db_connection.py:66:65
   |
64 |     try:
65 |         from app.models import Base, Conversation, User
66 |         from app.models.conversation import ConversationCreate, MessageRole
   |                                                                 ^^^^^^^^^^^
67 |         from app.models.user import UserCreate, UserResponse
   |
help: Remove unused import

PLC0415 `import` should be at the top-level of a file
  --> scripts\checks\test_db_connection.py:67:9
   |
65 |         from app.models import Base, Conversation, User
66 |         from app.models.conversation import ConversationCreate, MessageRole
67 |         from app.models.user import UserCreate, UserResponse
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |
69 |         logger.info("✅ Все модели успешно импортированы")
   |

F401 `app.models.user.UserCreate` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> scripts\checks\test_db_connection.py:67:37
   |
65 |         from app.models import Base, Conversation, User
66 |         from app.models.conversation import ConversationCreate, MessageRole
67 |         from app.models.user import UserCreate, UserResponse
   |                                     ^^^^^^^^^^
68 |
69 |         logger.info("✅ Все модели успешно импортированы")
   |
help: Remove unused import

F401 `app.models.user.UserResponse` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> scripts\checks\test_db_connection.py:67:49
   |
65 |         from app.models import Base, Conversation, User
66 |         from app.models.conversation import ConversationCreate, MessageRole
67 |         from app.models.user import UserCreate, UserResponse
   |                                                 ^^^^^^^^^^^^
68 |
69 |         logger.info("✅ Все модели успешно импортированы")
   |
help: Remove unused import

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> scripts\checks\test_db_connection.py:69:24
   |
67 |         from app.models.user import UserCreate, UserResponse
68 |
69 |         logger.info("✅ Все модели успешно импортированы")
   |                         ^
70 |         logger.info("📋 Доступные модели: User, Conversation")
71 |         logger.info(f"🔧 Базовый класс: {Base}")
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_db_connection.py:69:25
   |
67 |         from app.models.user import UserCreate, UserResponse
68 |
69 |         logger.info("✅ Все модели успешно импортированы")
   |                          ^
70 |         logger.info("📋 Доступные модели: User, Conversation")
71 |         logger.info(f"🔧 Базовый класс: {Base}")
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> scripts\checks\test_db_connection.py:69:26
   |
67 |         from app.models.user import UserCreate, UserResponse
68 |
69 |         logger.info("✅ Все модели успешно импортированы")
   |                           ^
70 |         logger.info("📋 Доступные модели: User, Conversation")
71 |         logger.info(f"🔧 Базовый класс: {Base}")
   |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> scripts\checks\test_db_connection.py:94:31
   |
93 |         if db_ok:
94 |             logger.success("🎯 Все тесты пройдены успешно!")
   |                                ^
95 |             logger.info("✨ База данных готова к использованию")
96 |         else:
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_db_connection.py:94:32
   |
93 |         if db_ok:
94 |             logger.success("🎯 Все тесты пройдены успешно!")
   |                                 ^
95 |             logger.info("✨ База данных готова к использованию")
96 |         else:
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> scripts\checks\test_db_connection.py:94:33
   |
93 |         if db_ok:
94 |             logger.success("🎯 Все тесты пройдены успешно!")
   |                                  ^
95 |             logger.info("✨ База данных готова к использованию")
96 |         else:
   |

E501 Line too long (102 > 88)
   --> scripts\checks\test_db_connection.py:109:89
    |
107 |     logger.add(
108 |         sys.stdout,
109 |         format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{message}</cyan>",
    |                                                                                         ^^^^^^^^^^^^^^
110 |         level="INFO",
111 |     )
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> scripts\checks\test_openrouter_integration.py:4:55
  |
2 | """
3 | @file: test_openrouter_integration.py
4 | @description: Тестовый скрипт для проверки интеграции с OpenRouter API
  |                                                       ^
5 | @created: 2025-09-20
6 | """
  |

E402 Module level import not at top of file
  --> scripts\checks\test_openrouter_integration.py:16:1
   |
14 | sys.path.insert(0, str(project_root))
15 |
16 | from loguru import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
17 |
18 | from app.services.ai_manager import ConversationMessage, get_ai_manager
   |

E402 Module level import not at top of file
  --> scripts\checks\test_openrouter_integration.py:18:1
   |
16 | from loguru import logger
17 |
18 | from app.services.ai_manager import ConversationMessage, get_ai_manager
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `test_openrouter_integration`
  --> scripts\checks\test_openrouter_integration.py:21:11
   |
21 | async def test_openrouter_integration():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |     """Тестирование интеграции с OpenRouter."""
23 |     logger.info("🚀 Начинаем тест интеграции с OpenRouter...")
   |
help: Add return type annotation: `bool | None`

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_openrouter_integration.py:22:32
   |
21 | async def test_openrouter_integration():
22 |     """Тестирование интеграции с OpenRouter."""
   |                                ^
23 |     logger.info("🚀 Начинаем тест интеграции с OpenRouter...")
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_openrouter_integration.py:23:45
   |
21 | async def test_openrouter_integration():
22 |     """Тестирование интеграции с OpenRouter."""
23 |     logger.info("🚀 Начинаем тест интеграции с OpenRouter...")
   |                                              ^
24 |
25 |     try:
   |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> scripts\checks\test_openrouter_integration.py:55:57
   |
53 |                 ConversationMessage(
54 |                     role="user",
55 |                     content="Привет! Как дела? Расскажи о себе в 2-3 предложениях.",
   |                                                         ^
56 |                 ),
57 |             ]
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_openrouter_integration.py:55:59
   |
53 |                 ConversationMessage(
54 |                     role="user",
55 |                     content="Привет! Как дела? Расскажи о себе в 2-3 предложениях.",
   |                                                           ^
56 |                 ),
57 |             ]
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> scripts\checks\test_openrouter_integration.py:55:60
   |
53 |                 ConversationMessage(
54 |                     role="user",
55 |                     content="Привет! Как дела? Расскажи о себе в 2-3 предложениях.",
   |                                                            ^
56 |                 ),
57 |             ]
   |

RUF001 String contains ambiguous `б` (CYRILLIC SMALL LETTER BE). Did you mean `6` (DIGIT SIX)?
  --> scripts\checks\test_openrouter_integration.py:55:61
   |
53 |                 ConversationMessage(
54 |                     role="user",
55 |                     content="Привет! Как дела? Расскажи о себе в 2-3 предложениях.",
   |                                                             ^
56 |                 ),
57 |             ]
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> scripts\checks\test_openrouter_integration.py:55:62
   |
53 |                 ConversationMessage(
54 |                     role="user",
55 |                     content="Привет! Как дела? Расскажи о себе в 2-3 предложениях.",
   |                                                              ^
56 |                 ),
57 |             ]
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_openrouter_integration.py:71:76
   |
69 |                 logger.info(f"📊 Модель: {response.model}")
70 |                 logger.info(f"🔗 Провайдер: {response.provider}")
71 |                 logger.info(f"⏱️ Время ответа: {response.response_time:.2f}с")
   |                                                                           ^
72 |                 logger.info(f"🎯 Токенов использовано: {response.tokens_used}")
   |

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> scripts\checks\test_openrouter_integration.py:94:26
   |
92 |         stats = manager.get_stats()
93 |         logger.info("📈 Статистика менеджера:")
94 |         logger.info(f"   Всего запросов: {stats['requests_total']}")
   |                          ^
95 |         logger.info(f"   Успешных: {stats['requests_successful']}")
96 |         logger.info(f"   Неудачных: {stats['requests_failed']}")
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\checks\test_openrouter_integration.py:94:27
   |
92 |         stats = manager.get_stats()
93 |         logger.info("📈 Статистика менеджера:")
94 |         logger.info(f"   Всего запросов: {stats['requests_total']}")
   |                           ^
95 |         logger.info(f"   Успешных: {stats['requests_successful']}")
96 |         logger.info(f"   Неудачных: {stats['requests_failed']}")
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> scripts\checks\test_openrouter_integration.py:94:28
   |
92 |         stats = manager.get_stats()
93 |         logger.info("📈 Статистика менеджера:")
94 |         logger.info(f"   Всего запросов: {stats['requests_total']}")
   |                            ^
95 |         logger.info(f"   Успешных: {stats['requests_successful']}")
96 |         logger.info(f"   Неудачных: {stats['requests_failed']}")
   |

RUF001 String contains ambiguous `г` (CYRILLIC SMALL LETTER GHE). Did you mean `r` (LATIN SMALL LETTER R)?
  --> scripts\checks\test_openrouter_integration.py:94:29
   |
92 |         stats = manager.get_stats()
93 |         logger.info("📈 Статистика менеджера:")
94 |         logger.info(f"   Всего запросов: {stats['requests_total']}")
   |                             ^
95 |         logger.info(f"   Успешных: {stats['requests_successful']}")
96 |         logger.info(f"   Неудачных: {stats['requests_failed']}")
   |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
  --> scripts\checks\test_openrouter_integration.py:94:30
   |
92 |         stats = manager.get_stats()
93 |         logger.info("📈 Статистика менеджера:")
94 |         logger.info(f"   Всего запросов: {stats['requests_total']}")
   |                              ^
95 |         logger.info(f"   Успешных: {stats['requests_successful']}")
96 |         logger.info(f"   Неудачных: {stats['requests_failed']}")
   |

E501 Line too long (101 > 88)
   --> scripts\checks\test_openrouter_integration.py:101:89
    |
 99 |         for provider, provider_stats in stats["provider_stats"].items():
100 |             logger.info(
101 |                 f"   {provider}: {provider_stats['successes']}/{provider_stats['requests']} успешно",
    |                                                                                         ^^^^^^^^^^^^^
102 |             )
    |

TRY300 Consider moving this statement to an `else` block
   --> scripts\checks\test_openrouter_integration.py:104:9
    |
102 |             )
103 |
104 |         return True
    |         ^^^^^^^^^^^
105 |
106 |     except Exception as e:
    |

ANN201 Missing return type annotation for public function `main`
   --> scripts\checks\test_openrouter_integration.py:115:11
    |
115 | async def main():
    |           ^^^^
116 |     """Основная функция теста."""
117 |     logger.add("openrouter_test.log", rotation="1 MB", retention="1 week")
    |
help: Add return type annotation: `None`

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> scripts\checks\test_openrouter_integration.py:130:41
    |
128 |         logger.info("✅ OpenRouter интеграция работает корректно")
129 |     else:
130 |         logger.error("😞 Тест завершился с ошибками")
    |                                          ^
131 |         logger.info("📋 Проверьте настройки в .env файле")
    |

RUF002 Docstring contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
 --> scripts\diagnostics\check_deepseek_api.py:4:46
  |
2 | """
3 | @file: check_deepseek_api.py
4 | @description: Скрипт для диагностики проблем с DeepSeek API
  |                                              ^
5 | @created: 2025-09-20
6 | """
  |

E402 Module level import not at top of file
  --> scripts\diagnostics\check_deepseek_api.py:16:1
   |
14 | sys.path.insert(0, str(project_root))
15 |
16 | import httpx
   | ^^^^^^^^^^^^
17 | from loguru import logger
   |

E402 Module level import not at top of file
  --> scripts\diagnostics\check_deepseek_api.py:17:1
   |
16 | import httpx
17 | from loguru import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
18 |
19 | from app.config import get_config
   |

E402 Module level import not at top of file
  --> scripts\diagnostics\check_deepseek_api.py:19:1
   |
17 | from loguru import logger
18 |
19 | from app.config import get_config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

PLR0911 Too many return statements (7 > 6)
  --> scripts\diagnostics\check_deepseek_api.py:22:11
   |
22 | async def check_deepseek_api_status():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     """Проверка статуса DeepSeek API и диагностика проблем."""
24 |     logger.info("🔍 Начинаем диагностику DeepSeek API...")
   |

PLR0912 Too many branches (14 > 12)
  --> scripts\diagnostics\check_deepseek_api.py:22:11
   |
22 | async def check_deepseek_api_status():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     """Проверка статуса DeepSeek API и диагностика проблем."""
24 |     logger.info("🔍 Начинаем диагностику DeepSeek API...")
   |

PLR0915 Too many statements (61 > 50)
  --> scripts\diagnostics\check_deepseek_api.py:22:11
   |
22 | async def check_deepseek_api_status():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     """Проверка статуса DeepSeek API и диагностика проблем."""
24 |     logger.info("🔍 Начинаем диагностику DeepSeek API...")
   |

ANN201 Missing return type annotation for public function `check_deepseek_api_status`
  --> scripts\diagnostics\check_deepseek_api.py:22:11
   |
22 | async def check_deepseek_api_status():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     """Проверка статуса DeepSeek API и диагностика проблем."""
24 |     logger.info("🔍 Начинаем диагностику DeepSeek API...")
   |
help: Add return type annotation: `bool | None`

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
  --> scripts\diagnostics\check_deepseek_api.py:78:40
   |
76 |             logger.info(f"📊 Статус ответа: {response.status_code}")
77 |
78 |             if response.status_code == 200:
   |                                        ^^^
79 |                 logger.success("✅ API работает корректно!")
80 |                 data = response.json()
   |

PLR2004 Magic value used in comparison, consider replacing `401` with a constant variable
  --> scripts\diagnostics\check_deepseek_api.py:92:40
   |
90 |                 return True
91 |
92 |             if response.status_code == 401:
   |                                        ^^^
93 |                 logger.error("❌ Ошибка 401: Неверный API ключ!")
94 |                 logger.info("💡 Проверьте правильность API ключа в .env файле")
   |

PLR2004 Magic value used in comparison, consider replacing `402` with a constant variable
  --> scripts\diagnostics\check_deepseek_api.py:96:42
   |
94 |                 logger.info("💡 Проверьте правильность API ключа в .env файле")
95 |
96 |             elif response.status_code == 402:
   |                                          ^^^
97 |                 logger.error("❌ Ошибка 402: Недостаточно средств на счете!")
98 |                 logger.info("💡 Решение проблемы:")
   |

PLR2004 Magic value used in comparison, consider replacing `429` with a constant variable
   --> scripts\diagnostics\check_deepseek_api.py:106:42
    |
104 |                 logger.info("   4. Проверьте лимиты использования API")
105 |
106 |             elif response.status_code == 429:
    |                                          ^^^
107 |                 logger.error("❌ Ошибка 429: Превышен лимит запросов!")
108 |                 logger.info("💡 Подождите несколько минут и попробуйте снова")
    |

PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   --> scripts\diagnostics\check_deepseek_api.py:110:42
    |
108 |                 logger.info("💡 Подождите несколько минут и попробуйте снова")
109 |
110 |             elif response.status_code >= 500:
    |                                          ^^^
111 |                 logger.error(f"❌ Ошибка сервера DeepSeek: {response.status_code}")
112 |                 logger.info("💡 Попробуйте повторить запрос позже")
    |

E722 Do not use bare `except`
   --> scripts\diagnostics\check_deepseek_api.py:121:13
    |
119 |                 error_data = response.json()
120 |                 logger.info(f"📄 Детали ошибки: {error_data}")
121 |             except:
    |             ^^^^^^
122 |                 logger.info(f"📄 Тело ответа: {response.text}")
    |

ANN201 Missing return type annotation for public function `check_balance_info`
   --> scripts\diagnostics\check_deepseek_api.py:141:11
    |
141 | async def check_balance_info():
    |           ^^^^^^^^^^^^^^^^^^
142 |     """Дополнительная проверка информации о балансе (если доступно)."""
143 |     logger.info("💳 Проверяем информацию о балансе...")
    |
help: Add return type annotation: `bool`

RUF002 Docstring contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> scripts\diagnostics\check_deepseek_api.py:142:43
    |
141 | async def check_balance_info():
142 |     """Дополнительная проверка информации о балансе (если доступно)."""
    |                                           ^
143 |     logger.info("💳 Проверяем информацию о балансе...")
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> scripts\diagnostics\check_deepseek_api.py:143:41
    |
141 | async def check_balance_info():
142 |     """Дополнительная проверка информации о балансе (если доступно)."""
143 |     logger.info("💳 Проверяем информацию о балансе...")
    |                                          ^
144 |
145 |     try:
    |

RUF003 Comment contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> scripts\diagnostics\check_deepseek_api.py:158:45
    |
156 |             timeout=httpx.Timeout(10.0),
157 |         ) as client:
158 |             # Попробуем получить информацию о балансе
    |                                             ^
159 |             try:
160 |                 balance_response = await client.get(
    |

PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   --> scripts\diagnostics\check_deepseek_api.py:163:52
    |
161 |                     "/v1/dashboard/billing/subscription",
162 |                 )
163 |                 if balance_response.status_code == 200:
    |                                                    ^^^
164 |                     balance_data = balance_response.json()
165 |                     logger.info(f"💰 Информация о подписке: {balance_data}")
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> scripts\diagnostics\check_deepseek_api.py:165:48
    |
163 |                 if balance_response.status_code == 200:
164 |                     balance_data = balance_response.json()
165 |                     logger.info(f"💰 Информация о подписке: {balance_data}")
    |                                                 ^
166 |                     return True
167 |             except:
    |

E722 Do not use bare `except`
   --> scripts\diagnostics\check_deepseek_api.py:167:13
    |
165 |                     logger.info(f"💰 Информация о подписке: {balance_data}")
166 |                     return True
167 |             except:
    |             ^^^^^^
168 |                 logger.info("ℹ️ Информация о балансе недоступна через API")
    |

RUF001 String contains ambiguous `ℹ` (INFORMATION SOURCE). Did you mean `i` (LATIN SMALL LETTER I)?
   --> scripts\diagnostics\check_deepseek_api.py:168:30
    |
166 |                     return True
167 |             except:
168 |                 logger.info("ℹ️ Информация о балансе недоступна через API")
    |                              ^
169 |
170 |     except Exception as e:
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> scripts\diagnostics\check_deepseek_api.py:168:44
    |
166 |                     return True
167 |             except:
168 |                 logger.info("ℹ️ Информация о балансе недоступна через API")
    |                                           ^
169 |
170 |     except Exception as e:
    |

RUF001 String contains ambiguous `Н` (CYRILLIC CAPITAL LETTER EN). Did you mean `H` (LATIN CAPITAL LETTER H)?
   --> scripts\diagnostics\check_deepseek_api.py:171:29
    |
170 |     except Exception as e:
171 |         logger.warning(f"⚠️ Не удалось получить информацию о балансе: {e}")
    |                            ^
172 |
173 |     return False
    |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
   --> scripts\diagnostics\check_deepseek_api.py:171:30
    |
170 |     except Exception as e:
171 |         logger.warning(f"⚠️ Не удалось получить информацию о балансе: {e}")
    |                             ^
172 |
173 |     return False
    |

RUF001 String contains ambiguous `о` (CYRILLIC SMALL LETTER O). Did you mean `o` (LATIN SMALL LETTER O)?
   --> scripts\diagnostics\check_deepseek_api.py:171:60
    |
170 |     except Exception as e:
171 |         logger.warning(f"⚠️ Не удалось получить информацию о балансе: {e}")
    |                                                           ^
172 |
173 |     return False
    |

ANN201 Missing return type annotation for public function `main`
   --> scripts\diagnostics\check_deepseek_api.py:176:11
    |
176 | async def main():
    |           ^^^^
177 |     """Основная функция диагностики."""
178 |     logger.add("deepseek_diagnosis.log", rotation="1 MB", retention="1 week")
    |
help: Add return type annotation: `None`

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
   --> scripts\diagnostics\check_deepseek_api.py:197:45
    |
195 |         logger.info("✅ DeepSeek API готов к работе")
196 |     else:
197 |         logger.error("😞 Обнаружены проблемы с DeepSeek API")
    |                                              ^
198 |         logger.info("📋 Рекомендации:")
199 |         logger.info("   1. Проверьте настройки в .env файле")
    |

T201 `print` found
  --> scripts\diagnostics\check_imports.py:15:5
   |
13 |     import pytest
14 |
15 |     print(f"✅ pytest {pytest.__version__} - OK")
   |     ^^^^^
16 | except ImportError as e:
17 |     print(f"❌ pytest не найден: {e}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:17:5
   |
15 |     print(f"✅ pytest {pytest.__version__} - OK")
16 | except ImportError as e:
17 |     print(f"❌ pytest не найден: {e}")
   |     ^^^^^
18 |
19 | try:
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:22:5
   |
20 |     import loguru
21 |
22 |     print(f"✅ loguru {loguru.__version__} - OK")
   |     ^^^^^
23 | except ImportError as e:
24 |     print(f"❌ loguru не найден: {e}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:24:5
   |
22 |     print(f"✅ loguru {loguru.__version__} - OK")
23 | except ImportError as e:
24 |     print(f"❌ loguru не найден: {e}")
   |     ^^^^^
25 |
26 | try:
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:29:5
   |
27 |     import pydantic
28 |
29 |     print(f"✅ pydantic {pydantic.__version__} - OK")
   |     ^^^^^
30 | except ImportError as e:
31 |     print(f"❌ pydantic не найден: {e}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:31:5
   |
29 |     print(f"✅ pydantic {pydantic.__version__} - OK")
30 | except ImportError as e:
31 |     print(f"❌ pydantic не найден: {e}")
   |     ^^^^^
32 |
33 | try:
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:36:5
   |
34 |     import aiogram
35 |
36 |     print(f"✅ aiogram {aiogram.__version__} - OK")
   |     ^^^^^
37 | except ImportError as e:
38 |     print(f"❌ aiogram не найден: {e}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:38:5
   |
36 |     print(f"✅ aiogram {aiogram.__version__} - OK")
37 | except ImportError as e:
38 |     print(f"❌ aiogram не найден: {e}")
   |     ^^^^^
39 |
40 | # Проверяем путь к интерпретатору
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:41:1
   |
40 | # Проверяем путь к интерпретатору
41 | print(f"\n📍 Python интерпретатор: {sys.executable}")
   | ^^^^^
42 | print(f"📁 Рабочая директория: {Path.cwd()}")
43 | print(f"🐍 Версия Python: {sys.version}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:42:1
   |
40 | # Проверяем путь к интерпретатору
41 | print(f"\n📍 Python интерпретатор: {sys.executable}")
42 | print(f"📁 Рабочая директория: {Path.cwd()}")
   | ^^^^^
43 | print(f"🐍 Версия Python: {sys.version}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:43:1
   |
41 | print(f"\n📍 Python интерпретатор: {sys.executable}")
42 | print(f"📁 Рабочая директория: {Path.cwd()}")
43 | print(f"🐍 Версия Python: {sys.version}")
   | ^^^^^
44 |
45 | # Проверяем пути Python
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:46:1
   |
45 | # Проверяем пути Python
46 | print("\n📚 Python paths:")
   | ^^^^^
47 | for i, path in enumerate(sys.path[:5], 1):
48 |     print(f"  {i}. {path}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:48:5
   |
46 | print("\n📚 Python paths:")
47 | for i, path in enumerate(sys.path[:5], 1):
48 |     print(f"  {i}. {path}")
   |     ^^^^^
49 |
50 | if __name__ == "__main__":
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:51:5
   |
50 | if __name__ == "__main__":
51 |     print("\n🎉 Все импорты успешно загружены!")
   |     ^^^^^
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
   |
help: Remove `print`

RUF001 String contains ambiguous `В` (CYRILLIC CAPITAL LETTER VE). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> scripts\diagnostics\check_imports.py:51:16
   |
50 | if __name__ == "__main__":
51 |     print("\n🎉 Все импорты успешно загружены!")
   |                 ^
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
   |

RUF001 String contains ambiguous `с` (CYRILLIC SMALL LETTER ES). Did you mean `c` (LATIN SMALL LETTER C)?
  --> scripts\diagnostics\check_imports.py:51:17
   |
50 | if __name__ == "__main__":
51 |     print("\n🎉 Все импорты успешно загружены!")
   |                  ^
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
   |

RUF001 String contains ambiguous `е` (CYRILLIC SMALL LETTER IE). Did you mean `e` (LATIN SMALL LETTER E)?
  --> scripts\diagnostics\check_imports.py:51:18
   |
50 | if __name__ == "__main__":
51 |     print("\n🎉 Все импорты успешно загружены!")
   |                   ^
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
   |

T201 `print` found
  --> scripts\diagnostics\check_imports.py:52:5
   |
50 | if __name__ == "__main__":
51 |     print("\n🎉 Все импорты успешно загружены!")
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
   |     ^^^^^
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
54 |     print("   PyCharm: File -> Settings -> Project -> Python Interpreter")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:53:5
   |
51 |     print("\n🎉 Все импорты успешно загружены!")
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
   |     ^^^^^
54 |     print("   PyCharm: File -> Settings -> Project -> Python Interpreter")
55 |     print(f"   Путь: {Path.cwd() / '.venv' / 'Scripts' / 'python.exe'}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:54:5
   |
52 |     print("💡 Если в IDE все еще ошибки, настройте интерпретатор Python:")
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
54 |     print("   PyCharm: File -> Settings -> Project -> Python Interpreter")
   |     ^^^^^
55 |     print(f"   Путь: {Path.cwd() / '.venv' / 'Scripts' / 'python.exe'}")
   |
help: Remove `print`

T201 `print` found
  --> scripts\diagnostics\check_imports.py:55:5
   |
53 |     print("   VS Code: Ctrl+Shift+P -> 'Python: Select Interpreter'")
54 |     print("   PyCharm: File -> Settings -> Project -> Python Interpreter")
55 |     print(f"   Путь: {Path.cwd() / '.venv' / 'Scripts' / 'python.exe'}")
   |     ^^^^^
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic.py:28:1
   |
27 | config = TestConfig(field1="test", field2="test2")
28 | print("field1:", config.field1)
   | ^^^^^
29 | print("field2:", config.field2)
30 | print("computed_field:", config.computed_field)
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic.py:29:1
   |
27 | config = TestConfig(field1="test", field2="test2")
28 | print("field1:", config.field1)
29 | print("field2:", config.field2)
   | ^^^^^
30 | print("computed_field:", config.computed_field)
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic.py:30:1
   |
28 | print("field1:", config.field1)
29 | print("field2:", config.field2)
30 | print("computed_field:", config.computed_field)
   | ^^^^^
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:16:9
   |
14 |     def build_computed_field(cls, v: str | None, info: ValidationInfo) -> str:
15 |         """Build computed field from other fields."""
16 |         print(f"Validator called with v={v}, info.data={info.data}")
   |         ^^^^^
17 |
18 |         if v is not None:
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:30:1
   |
29 | # Test 1: With constructor parameters
30 | print("=== Test 1: Constructor parameters ===")
   | ^^^^^
31 | try:
32 |     config1 = TestConfig(field1="test", field2="test2")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:33:5
   |
31 | try:
32 |     config1 = TestConfig(field1="test", field2="test2")
33 |     print(f"field1: {config1.field1}")
   |     ^^^^^
34 |     print(f"field2: {config1.field2}")
35 |     print(f"computed_field: {config1.computed_field}")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:34:5
   |
32 |     config1 = TestConfig(field1="test", field2="test2")
33 |     print(f"field1: {config1.field1}")
34 |     print(f"field2: {config1.field2}")
   |     ^^^^^
35 |     print(f"computed_field: {config1.computed_field}")
36 | except Exception as e:
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:35:5
   |
33 |     print(f"field1: {config1.field1}")
34 |     print(f"field2: {config1.field2}")
35 |     print(f"computed_field: {config1.computed_field}")
   |     ^^^^^
36 | except Exception as e:
37 |     print(f"Error: {e}")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:37:5
   |
35 |     print(f"computed_field: {config1.computed_field}")
36 | except Exception as e:
37 |     print(f"Error: {e}")
   |     ^^^^^
38 |
39 | # Test 2: With environment variables
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:40:1
   |
39 | # Test 2: With environment variables
40 | print("\n=== Test 2: Environment variables ===")
   | ^^^^^
41 | import os
   |
help: Remove `print`

E402 Module level import not at top of file
  --> test_pydantic_behavior.py:41:1
   |
39 | # Test 2: With environment variables
40 | print("\n=== Test 2: Environment variables ===")
41 | import os
   | ^^^^^^^^^
42 |
43 | os.environ["FIELD1"] = "env_test"
   |

T201 `print` found
  --> test_pydantic_behavior.py:48:5
   |
46 | try:
47 |     config2 = TestConfig()
48 |     print(f"field1: {config2.field1}")
   |     ^^^^^
49 |     print(f"field2: {config2.field2}")
50 |     print(f"computed_field: {config2.computed_field}")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:49:5
   |
47 |     config2 = TestConfig()
48 |     print(f"field1: {config2.field1}")
49 |     print(f"field2: {config2.field2}")
   |     ^^^^^
50 |     print(f"computed_field: {config2.computed_field}")
51 | except Exception as e:
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:50:5
   |
48 |     print(f"field1: {config2.field1}")
49 |     print(f"field2: {config2.field2}")
50 |     print(f"computed_field: {config2.computed_field}")
   |     ^^^^^
51 | except Exception as e:
52 |     print(f"Error: {e}")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:52:5
   |
50 |     print(f"computed_field: {config2.computed_field}")
51 | except Exception as e:
52 |     print(f"Error: {e}")
   |     ^^^^^
53 |
54 | # Test 3: Mixed (constructor overrides env)
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:55:1
   |
54 | # Test 3: Mixed (constructor overrides env)
55 | print("\n=== Test 3: Mixed (constructor overrides env) ===")
   | ^^^^^
56 | try:
57 |     config3 = TestConfig(field1="constructor_override")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:58:5
   |
56 | try:
57 |     config3 = TestConfig(field1="constructor_override")
58 |     print(f"field1: {config3.field1}")
   |     ^^^^^
59 |     print(f"field2: {config3.field2}")
60 |     print(f"computed_field: {config3.computed_field}")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:59:5
   |
57 |     config3 = TestConfig(field1="constructor_override")
58 |     print(f"field1: {config3.field1}")
59 |     print(f"field2: {config3.field2}")
   |     ^^^^^
60 |     print(f"computed_field: {config3.computed_field}")
61 | except Exception as e:
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:60:5
   |
58 |     print(f"field1: {config3.field1}")
59 |     print(f"field2: {config3.field2}")
60 |     print(f"computed_field: {config3.computed_field}")
   |     ^^^^^
61 | except Exception as e:
62 |     print(f"Error: {e}")
   |
help: Remove `print`

T201 `print` found
  --> test_pydantic_behavior.py:62:5
   |
60 |     print(f"computed_field: {config3.computed_field}")
61 | except Exception as e:
62 |     print(f"Error: {e}")
   |     ^^^^^
   |
help: Remove `print`

ANN201 Missing return type annotation for public function `project_root_path`
  --> tests\conftest.py:20:5
   |
19 | @pytest.fixture(scope="session")
20 | def project_root_path():
   |     ^^^^^^^^^^^^^^^^^
21 |     """Фикстура возвращающая путь к корню проекта."""
22 |     return project_root
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `setup_test_environment`
  --> tests\conftest.py:26:5
   |
25 | @pytest.fixture(autouse=True)
26 | def setup_test_environment():
   |     ^^^^^^^^^^^^^^^^^^^^^^
27 |     """Автоматическая настройка тестового окружения."""
28 |     # Настройка логирования для тестов
   |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
  --> tests\conftest.py:29:5
   |
27 |     """Автоматическая настройка тестового окружения."""
28 |     # Настройка логирования для тестов
29 |     from app.utils.logging import setup_logging
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |
31 |     setup_logging(
   |

ANN201 Missing return type annotation for public function `clean_config_cache`
  --> tests\conftest.py:40:5
   |
39 | @pytest.fixture
40 | def clean_config_cache():
   |     ^^^^^^^^^^^^^^^^^^
41 |     """Фикстура для очистки кеша конфигурации между тестами."""
42 |     import app.config
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> tests\conftest.py:42:5
   |
40 | def clean_config_cache():
41 |     """Фикстура для очистки кеша конфигурации между тестами."""
42 |     import app.config
   |     ^^^^^^^^^^^^^^^^^
43 |
44 |     # Сохраняем текущее состояние
   |

SLF001 Private member accessed: `_config_instance`
  --> tests\conftest.py:48:5
   |
47 |     # Очищаем кеш
48 |     app.config._config_instance = None
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |
50 |     yield
   |

SLF001 Private member accessed: `_config_instance`
  --> tests\conftest.py:53:5
   |
52 |     # Восстанавливаем состояние
53 |     app.config._config_instance = original_instance
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `mock_config`
  --> tests\conftest.py:62:5
   |
61 | @pytest.fixture
62 | def mock_config():
   |     ^^^^^^^^^^^
63 |     """Мок конфигурации для тестов."""
64 |     config = MagicMock()
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `mock_ai_response`
  --> tests\conftest.py:90:5
   |
89 | @pytest.fixture
90 | def mock_ai_response():
   |     ^^^^^^^^^^^^^^^^
91 |     """Стандартный мок AI ответа."""
92 |     from app.services.ai_providers.base import AIResponse
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> tests\conftest.py:92:5
   |
90 | def mock_ai_response():
91 |     """Стандартный мок AI ответа."""
92 |     from app.services.ai_providers.base import AIResponse
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
93 |
94 |     return AIResponse(
   |

ANN201 Missing return type annotation for public function `mock_conversation_messages`
   --> tests\conftest.py:105:5
    |
104 | @pytest.fixture
105 | def mock_conversation_messages():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |     """Тестовые сообщения диалога."""
107 |     from app.services.ai_providers.base import ConversationMessage
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> tests\conftest.py:107:5
    |
105 | def mock_conversation_messages():
106 |     """Тестовые сообщения диалога."""
107 |     from app.services.ai_providers.base import ConversationMessage
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
108 |
109 |     return [
    |

ANN201 Missing return type annotation for public function `mock_openrouter_provider`
   --> tests\conftest.py:126:5
    |
125 | @pytest.fixture
126 | def mock_openrouter_provider():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
127 |     """Мок OpenRouter провайдера."""
128 |     provider = AsyncMock()
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `mock_deepseek_provider`
   --> tests\conftest.py:136:5
    |
135 | @pytest.fixture
136 | def mock_deepseek_provider():
    |     ^^^^^^^^^^^^^^^^^^^^^^
137 |     """Мок DeepSeek провайдера."""
138 |     provider = AsyncMock()
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `mock_ai_manager`
   --> tests\conftest.py:146:5
    |
145 | @pytest.fixture
146 | def mock_ai_manager(mock_openrouter_provider, mock_deepseek_provider, mock_ai_response):
    |     ^^^^^^^^^^^^^^^
147 |     """Мок AI менеджера с настроенными провайдерами."""
148 |     manager = AsyncMock()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_openrouter_provider`
   --> tests\conftest.py:146:21
    |
145 | @pytest.fixture
146 | def mock_ai_manager(mock_openrouter_provider, mock_deepseek_provider, mock_ai_response):
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^
147 |     """Мок AI менеджера с настроенными провайдерами."""
148 |     manager = AsyncMock()
    |

ANN001 Missing type annotation for function argument `mock_deepseek_provider`
   --> tests\conftest.py:146:47
    |
145 | @pytest.fixture
146 | def mock_ai_manager(mock_openrouter_provider, mock_deepseek_provider, mock_ai_response):
    |                                               ^^^^^^^^^^^^^^^^^^^^^^
147 |     """Мок AI менеджера с настроенными провайдерами."""
148 |     manager = AsyncMock()
    |

ANN001 Missing type annotation for function argument `mock_ai_response`
   --> tests\conftest.py:146:71
    |
145 | @pytest.fixture
146 | def mock_ai_manager(mock_openrouter_provider, mock_deepseek_provider, mock_ai_response):
    |                                                                       ^^^^^^^^^^^^^^^^
147 |     """Мок AI менеджера с настроенными провайдерами."""
148 |     manager = AsyncMock()
    |

ANN201 Missing return type annotation for public function `mock_db_session`
   --> tests\conftest.py:187:5
    |
186 | @pytest.fixture
187 | def mock_db_session():
    |     ^^^^^^^^^^^^^^^
188 |     """Мок сессии базы данных."""
189 |     session = AsyncMock()
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `sample_user`
   --> tests\conftest.py:199:5
    |
198 | @pytest.fixture
199 | def sample_user():
    |     ^^^^^^^^^^^
200 |     """Пример пользователя для тестов."""
201 |     from app.models.user import User
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> tests\conftest.py:201:5
    |
199 | def sample_user():
200 |     """Пример пользователя для тестов."""
201 |     from app.models.user import User
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
202 |
203 |     return User(
    |

ANN201 Missing return type annotation for public function `sample_conversation`
   --> tests\conftest.py:214:5
    |
213 | @pytest.fixture
214 | def sample_conversation():
    |     ^^^^^^^^^^^^^^^^^^^
215 |     """Пример диалога для тестов."""
216 |     from app.models.conversation import Conversation, MessageRole
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> tests\conftest.py:216:5
    |
214 | def sample_conversation():
215 |     """Пример диалога для тестов."""
216 |     from app.models.conversation import Conversation, MessageRole
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |
218 |     return Conversation(
    |

ANN201 Missing return type annotation for public function `mock_telegram_message`
   --> tests\conftest.py:228:5
    |
227 | @pytest.fixture
228 | def mock_telegram_message():
    |     ^^^^^^^^^^^^^^^^^^^^^
229 |     """Мок Telegram сообщения."""
230 |     from aiogram.types import Chat, Message
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> tests\conftest.py:230:5
    |
228 | def mock_telegram_message():
229 |     """Мок Telegram сообщения."""
230 |     from aiogram.types import Chat, Message
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
231 |     from aiogram.types import User as TelegramUser
    |

PLC0415 `import` should be at the top-level of a file
   --> tests\conftest.py:231:5
    |
229 |     """Мок Telegram сообщения."""
230 |     from aiogram.types import Chat, Message
231 |     from aiogram.types import User as TelegramUser
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
232 |
233 |     message = MagicMock(spec=Message)
    |

ANN201 Missing return type annotation for public function `pytest_configure`
   --> tests\conftest.py:251:5
    |
250 | # Маркеры для категоризации тестов
251 | def pytest_configure(config):
    |     ^^^^^^^^^^^^^^^^
252 |     """Конфигурация pytest с пользовательскими маркерами."""
253 |     config.addinivalue_line(
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `config`
   --> tests\conftest.py:251:22
    |
250 | # Маркеры для категоризации тестов
251 | def pytest_configure(config):
    |                      ^^^^^^
252 |     """Конфигурация pytest с пользовательскими маркерами."""
253 |     config.addinivalue_line(
    |

ANN201 Missing return type annotation for public function `test_ai_manager_initialization`
  --> tests\integration\test_ai_manager.py:29:15
   |
28 |     @pytest.mark.asyncio
29 |     async def test_ai_manager_initialization(self, mock_config):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |         """Тест инициализации AI менеджера."""
31 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_ai_manager.py:29:52
   |
28 |     @pytest.mark.asyncio
29 |     async def test_ai_manager_initialization(self, mock_config):
   |                                                    ^^^^^^^^^^^
30 |         """Тест инициализации AI менеджера."""
31 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |

ANN201 Missing return type annotation for public function `test_ai_manager_singleton`
  --> tests\integration\test_ai_manager.py:38:9
   |
36 |             assert hasattr(manager, "_config")
37 |
38 |     def test_ai_manager_singleton(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
39 |         """Тест singleton паттерна для AIManager."""
40 |         with patch("app.services.ai_manager.get_config"):
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_provider_registration`
  --> tests\integration\test_ai_manager.py:47:15
   |
46 |     @pytest.mark.asyncio
47 |     async def test_provider_registration(self, mock_config):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |         """Тест регистрации провайдеров."""
49 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_ai_manager.py:47:48
   |
46 |     @pytest.mark.asyncio
47 |     async def test_provider_registration(self, mock_config):
   |                                                ^^^^^^^^^^^
48 |         """Тест регистрации провайдеров."""
49 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |

ANN201 Missing return type annotation for public function `test_invalid_provider_request`
  --> tests\integration\test_ai_manager.py:59:9
   |
57 |             assert deepseek is not None
58 |
59 |     def test_invalid_provider_request(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
60 |         """Тест запроса несуществующего провайдера."""
61 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_ai_manager.py:59:45
   |
57 |             assert deepseek is not None
58 |
59 |     def test_invalid_provider_request(self, mock_config):
   |                                             ^^^^^^^^^^^
60 |         """Тест запроса несуществующего провайдера."""
61 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |

ANN201 Missing return type annotation for public function `manager_with_mocked_providers`
  --> tests\integration\test_ai_manager.py:74:9
   |
73 |     @pytest.fixture
74 |     def manager_with_mocked_providers(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |         """Менеджер с мокированными провайдерами."""
76 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_ai_manager.py:74:45
   |
73 |     @pytest.fixture
74 |     def manager_with_mocked_providers(self, mock_config):
   |                                             ^^^^^^^^^^^
75 |         """Менеджер с мокированными провайдерами."""
76 |         with patch("app.services.ai_manager.get_config", return_value=mock_config):
   |

SLF001 Private member accessed: `_providers`
  --> tests\integration\test_ai_manager.py:96:13
   |
94 |             mock_deepseek.close = AsyncMock()
95 |
96 |             manager._providers["openrouter"] = mock_openrouter
   |             ^^^^^^^^^^^^^^^^^^
97 |             manager._providers["deepseek"] = mock_deepseek
   |

SLF001 Private member accessed: `_providers`
  --> tests\integration\test_ai_manager.py:97:13
   |
96 |             manager._providers["openrouter"] = mock_openrouter
97 |             manager._providers["deepseek"] = mock_deepseek
   |             ^^^^^^^^^^^^^^^^^^
98 |
99 |             return manager, mock_openrouter, mock_deepseek
   |

ANN201 Missing return type annotation for public function `test_successful_primary_provider`
   --> tests\integration\test_ai_manager.py:102:15
    |
101 |     @pytest.mark.asyncio
102 |     async def test_successful_primary_provider(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
103 |         self,
104 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:104:9
    |
102 |     async def test_successful_primary_provider(
103 |         self,
104 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |         mock_conversation_messages,
106 |         mock_ai_response,
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:105:9
    |
103 |         self,
104 |         manager_with_mocked_providers,
105 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |         mock_ai_response,
107 |     ):
    |

ANN001 Missing type annotation for function argument `mock_ai_response`
   --> tests\integration\test_ai_manager.py:106:9
    |
104 |         manager_with_mocked_providers,
105 |         mock_conversation_messages,
106 |         mock_ai_response,
    |         ^^^^^^^^^^^^^^^^
107 |     ):
108 |         """Тест успешного ответа от основного провайдера."""
    |

ANN201 Missing return type annotation for public function `test_fallback_on_primary_failure`
   --> tests\integration\test_ai_manager.py:122:15
    |
121 |     @pytest.mark.asyncio
122 |     async def test_fallback_on_primary_failure(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |         self,
124 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:124:9
    |
122 |     async def test_fallback_on_primary_failure(
123 |         self,
124 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |         mock_conversation_messages,
126 |         mock_ai_response,
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:125:9
    |
123 |         self,
124 |         manager_with_mocked_providers,
125 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
126 |         mock_ai_response,
127 |     ):
    |

ANN001 Missing type annotation for function argument `mock_ai_response`
   --> tests\integration\test_ai_manager.py:126:9
    |
124 |         manager_with_mocked_providers,
125 |         mock_conversation_messages,
126 |         mock_ai_response,
    |         ^^^^^^^^^^^^^^^^
127 |     ):
128 |         """Тест fallback при сбое основного провайдера."""
    |

ANN201 Missing return type annotation for public function `test_both_providers_fail`
   --> tests\integration\test_ai_manager.py:145:15
    |
144 |     @pytest.mark.asyncio
145 |     async def test_both_providers_fail(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^
146 |         self,
147 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:147:9
    |
145 |     async def test_both_providers_fail(
146 |         self,
147 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |         mock_conversation_messages,
149 |     ):
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:148:9
    |
146 |         self,
147 |         manager_with_mocked_providers,
148 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |     ):
150 |         """Тест когда оба провайдера недоступны."""
    |

ANN201 Missing return type annotation for public function `test_rate_limit_fallback`
   --> tests\integration\test_ai_manager.py:167:15
    |
166 |     @pytest.mark.asyncio
167 |     async def test_rate_limit_fallback(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^
168 |         self,
169 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:169:9
    |
167 |     async def test_rate_limit_fallback(
168 |         self,
169 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 |         mock_conversation_messages,
171 |         mock_ai_response,
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:170:9
    |
168 |         self,
169 |         manager_with_mocked_providers,
170 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
171 |         mock_ai_response,
172 |     ):
    |

ANN001 Missing type annotation for function argument `mock_ai_response`
   --> tests\integration\test_ai_manager.py:171:9
    |
169 |         manager_with_mocked_providers,
170 |         mock_conversation_messages,
171 |         mock_ai_response,
    |         ^^^^^^^^^^^^^^^^
172 |     ):
173 |         """Тест fallback при превышении лимита запросов."""
    |

ANN201 Missing return type annotation for public function `test_health_check_all_healthy`
   --> tests\integration\test_ai_manager.py:197:15
    |
196 |     @pytest.mark.asyncio
197 |     async def test_health_check_all_healthy(self, mock_ai_manager):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
198 |         """Тест health check когда все провайдеры здоровы."""
199 |         health = await mock_ai_manager.health_check()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:197:51
    |
196 |     @pytest.mark.asyncio
197 |     async def test_health_check_all_healthy(self, mock_ai_manager):
    |                                                   ^^^^^^^^^^^^^^^
198 |         """Тест health check когда все провайдеры здоровы."""
199 |         health = await mock_ai_manager.health_check()
    |

ANN201 Missing return type annotation for public function `test_health_check_with_failures`
   --> tests\integration\test_ai_manager.py:207:15
    |
206 |     @pytest.mark.asyncio
207 |     async def test_health_check_with_failures(self, manager_with_mocked_providers):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
208 |         """Тест health check с недоступными провайдерами."""
209 |         manager, mock_openrouter, mock_deepseek = manager_with_mocked_providers
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:207:53
    |
206 |     @pytest.mark.asyncio
207 |     async def test_health_check_with_failures(self, manager_with_mocked_providers):
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
208 |         """Тест health check с недоступными провайдерами."""
209 |         manager, mock_openrouter, mock_deepseek = manager_with_mocked_providers
    |

ANN201 Missing return type annotation for public function `test_initial_statistics`
   --> tests\integration\test_ai_manager.py:236:9
    |
234 |     """Тесты системы статистики AIManager."""
235 |
236 |     def test_initial_statistics(self, mock_ai_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
237 |         """Тест начальной статистики."""
238 |         # Мок возвращает синхронно
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:236:39
    |
234 |     """Тесты системы статистики AIManager."""
235 |
236 |     def test_initial_statistics(self, mock_ai_manager):
    |                                       ^^^^^^^^^^^^^^^
237 |         """Тест начальной статистики."""
238 |         # Мок возвращает синхронно
    |

ANN201 Missing return type annotation for public function `test_statistics_after_requests`
   --> tests\integration\test_ai_manager.py:255:9
    |
253 |         assert "provider_stats" in stats
254 |
255 |     def test_statistics_after_requests(self, mock_ai_manager):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
256 |         """Тест статистики после запросов."""
257 |         # Имитируем статистику с запросами
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:255:46
    |
253 |         assert "provider_stats" in stats
254 |
255 |     def test_statistics_after_requests(self, mock_ai_manager):
    |                                              ^^^^^^^^^^^^^^^
256 |         """Тест статистики после запросов."""
257 |         # Имитируем статистику с запросами
    |

ANN201 Missing return type annotation for public function `test_cache_hit`
   --> tests\integration\test_ai_manager.py:283:15
    |
282 |     @pytest.mark.asyncio
283 |     async def test_cache_hit(
    |               ^^^^^^^^^^^^^^
284 |         self,
285 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:285:9
    |
283 |     async def test_cache_hit(
284 |         self,
285 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
286 |         mock_conversation_messages,
287 |     ):
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:286:9
    |
284 |         self,
285 |         manager_with_mocked_providers,
286 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
287 |     ):
288 |         """Тест попадания в кеш."""
    |

ANN201 Missing return type annotation for public function `test_cache_disabled`
   --> tests\integration\test_ai_manager.py:330:15
    |
329 |     @pytest.mark.asyncio
330 |     async def test_cache_disabled(
    |               ^^^^^^^^^^^^^^^^^^^
331 |         self,
332 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:332:9
    |
330 |     async def test_cache_disabled(
331 |         self,
332 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
333 |         mock_conversation_messages,
334 |         mock_ai_response,
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:333:9
    |
331 |         self,
332 |         manager_with_mocked_providers,
333 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
334 |         mock_ai_response,
335 |     ):
    |

ANN001 Missing type annotation for function argument `mock_ai_response`
   --> tests\integration\test_ai_manager.py:334:9
    |
332 |         manager_with_mocked_providers,
333 |         mock_conversation_messages,
334 |         mock_ai_response,
    |         ^^^^^^^^^^^^^^^^
335 |     ):
336 |         """Тест отключения кеша."""
    |

ANN201 Missing return type annotation for public function `test_generate_simple_response`
   --> tests\integration\test_ai_manager.py:357:15
    |
356 |     @pytest.mark.asyncio
357 |     async def test_generate_simple_response(self, mock_ai_manager):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
358 |         """Тест генерации простого ответа."""
359 |         response = await mock_ai_manager.generate_simple_response("Привет!")
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:357:51
    |
356 |     @pytest.mark.asyncio
357 |     async def test_generate_simple_response(self, mock_ai_manager):
    |                                                   ^^^^^^^^^^^^^^^
358 |         """Тест генерации простого ответа."""
359 |         response = await mock_ai_manager.generate_simple_response("Привет!")
    |

ANN201 Missing return type annotation for public function `test_simple_response_with_parameters`
   --> tests\integration\test_ai_manager.py:365:15
    |
364 |     @pytest.mark.asyncio
365 |     async def test_simple_response_with_parameters(self, mock_ai_manager):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
366 |         """Тест простого ответа с параметрами."""
367 |         custom_response = AIResponse(
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:365:58
    |
364 |     @pytest.mark.asyncio
365 |     async def test_simple_response_with_parameters(self, mock_ai_manager):
    |                                                          ^^^^^^^^^^^^^^^
366 |         """Тест простого ответа с параметрами."""
367 |         custom_response = AIResponse(
    |

ANN201 Missing return type annotation for public function `test_manager_close`
   --> tests\integration\test_ai_manager.py:392:15
    |
391 |     @pytest.mark.asyncio
392 |     async def test_manager_close(self, manager_with_mocked_providers):
    |               ^^^^^^^^^^^^^^^^^^
393 |         """Тест корректного закрытия менеджера."""
394 |         manager, mock_openrouter, mock_deepseek = manager_with_mocked_providers
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:392:40
    |
391 |     @pytest.mark.asyncio
392 |     async def test_manager_close(self, manager_with_mocked_providers):
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
393 |         """Тест корректного закрытия менеджера."""
394 |         manager, mock_openrouter, mock_deepseek = manager_with_mocked_providers
    |

ERA001 Found commented-out code
   --> tests\integration\test_ai_manager.py:410:5
    |
408 |     #             assert manager is not None
409 |     #             # Менеджер должен быть доступен в контексте
410 |     #             assert hasattr(manager, '_providers')
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `test_invalid_messages_format`
   --> tests\integration\test_ai_manager.py:419:15
    |
418 |     @pytest.mark.asyncio
419 |     async def test_invalid_messages_format(self, mock_ai_manager):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
420 |         """Тест обработки некорректного формата сообщений."""
421 |         # Мок должен выбрасывать ошибку
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:419:50
    |
418 |     @pytest.mark.asyncio
419 |     async def test_invalid_messages_format(self, mock_ai_manager):
    |                                                  ^^^^^^^^^^^^^^^
420 |         """Тест обработки некорректного формата сообщений."""
421 |         # Мок должен выбрасывать ошибку
    |

ANN201 Missing return type annotation for public function `test_empty_messages_list`
   --> tests\integration\test_ai_manager.py:430:15
    |
429 |     @pytest.mark.asyncio
430 |     async def test_empty_messages_list(self, mock_ai_manager):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^
431 |         """Тест обработки пустого списка сообщений."""
432 |         # Мок должен выбрасывать ошибку
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_ai_manager`
   --> tests\integration\test_ai_manager.py:430:46
    |
429 |     @pytest.mark.asyncio
430 |     async def test_empty_messages_list(self, mock_ai_manager):
    |                                              ^^^^^^^^^^^^^^^
431 |         """Тест обработки пустого списка сообщений."""
432 |         # Мок должен выбрасывать ошибку
    |

ANN201 Missing return type annotation for public function `test_authentication_error_handling`
   --> tests\integration\test_ai_manager.py:441:15
    |
440 |     @pytest.mark.asyncio
441 |     async def test_authentication_error_handling(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
442 |         self,
443 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:443:9
    |
441 |     async def test_authentication_error_handling(
442 |         self,
443 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
444 |         mock_conversation_messages,
445 |     ):
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:444:9
    |
442 |         self,
443 |         manager_with_mocked_providers,
444 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
445 |     ):
446 |         """Тест обработки ошибок аутентификации."""
    |

ANN201 Missing return type annotation for public function `test_mixed_error_handling`
   --> tests\integration\test_ai_manager.py:466:15
    |
465 |     @pytest.mark.asyncio
466 |     async def test_mixed_error_handling(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
467 |         self,
468 |         manager_with_mocked_providers,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `manager_with_mocked_providers`
   --> tests\integration\test_ai_manager.py:468:9
    |
466 |     async def test_mixed_error_handling(
467 |         self,
468 |         manager_with_mocked_providers,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         mock_conversation_messages,
470 |         mock_ai_response,
    |

ANN001 Missing type annotation for function argument `mock_conversation_messages`
   --> tests\integration\test_ai_manager.py:469:9
    |
467 |         self,
468 |         manager_with_mocked_providers,
469 |         mock_conversation_messages,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
470 |         mock_ai_response,
471 |     ):
    |

ANN001 Missing type annotation for function argument `mock_ai_response`
   --> tests\integration\test_ai_manager.py:470:9
    |
468 |         manager_with_mocked_providers,
469 |         mock_conversation_messages,
470 |         mock_ai_response,
    |         ^^^^^^^^^^^^^^^^
471 |     ):
472 |         """Тест обработки смешанных ошибок."""
    |

ANN201 Missing return type annotation for public function `test_cache_init`
  --> tests\integration\test_ai_service.py:31:9
   |
29 |     """Тесты для системы кеширования ответов."""
30 |
31 |     def test_cache_init(self):
   |         ^^^^^^^^^^^^^^^
32 |         """Тест инициализации кеша."""
33 |         cache = ResponseCache(ttl_seconds=3600)
   |
help: Add return type annotation: `None`

SLF001 Private member accessed: `_ttl`
  --> tests\integration\test_ai_service.py:34:16
   |
32 |         """Тест инициализации кеша."""
33 |         cache = ResponseCache(ttl_seconds=3600)
34 |         assert cache._ttl == 3600
   |                ^^^^^^^^^^
35 |         assert cache._cache == {}
   |

SLF001 Private member accessed: `_cache`
  --> tests\integration\test_ai_service.py:35:16
   |
33 |         cache = ResponseCache(ttl_seconds=3600)
34 |         assert cache._ttl == 3600
35 |         assert cache._cache == {}
   |                ^^^^^^^^^^^^
36 |
37 |     def test_cache_key_generation(self):
   |

ANN201 Missing return type annotation for public function `test_cache_key_generation`
  --> tests\integration\test_ai_service.py:37:9
   |
35 |         assert cache._cache == {}
36 |
37 |     def test_cache_key_generation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         """Тест генерации ключей кеша."""
39 |         cache = ResponseCache()
   |
help: Add return type annotation: `None`

SLF001 Private member accessed: `_generate_key`
  --> tests\integration\test_ai_service.py:45:16
   |
43 |         ]
44 |
45 |         key1 = cache._generate_key(messages, "deepseek-chat")
   |                ^^^^^^^^^^^^^^^^^^^
46 |         key2 = cache._generate_key(messages, "deepseek-chat")
47 |         key3 = cache._generate_key(messages, "different-model")
   |

SLF001 Private member accessed: `_generate_key`
  --> tests\integration\test_ai_service.py:46:16
   |
45 |         key1 = cache._generate_key(messages, "deepseek-chat")
46 |         key2 = cache._generate_key(messages, "deepseek-chat")
   |                ^^^^^^^^^^^^^^^^^^^
47 |         key3 = cache._generate_key(messages, "different-model")
   |

SLF001 Private member accessed: `_generate_key`
  --> tests\integration\test_ai_service.py:47:16
   |
45 |         key1 = cache._generate_key(messages, "deepseek-chat")
46 |         key2 = cache._generate_key(messages, "deepseek-chat")
47 |         key3 = cache._generate_key(messages, "different-model")
   |                ^^^^^^^^^^^^^^^^^^^
48 |
49 |         assert key1 == key2  # Одинаковые сообщения = одинаковый ключ
   |

ANN201 Missing return type annotation for public function `test_cache_set_and_get`
  --> tests\integration\test_ai_service.py:53:9
   |
51 |         assert len(key1) == 32  # MD5 hash length
52 |
53 |     def test_cache_set_and_get(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^
54 |         """Тест сохранения и получения из кеша."""
55 |         cache = ResponseCache(ttl_seconds=3600)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_cache_miss`
  --> tests\integration\test_ai_service.py:74:9
   |
72 |         assert cached_response.cached is True
73 |
74 |     def test_cache_miss(self):
   |         ^^^^^^^^^^^^^^^
75 |         """Тест промаха кеша."""
76 |         cache = ResponseCache()
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_cache_ttl_expiration`
  --> tests\integration\test_ai_service.py:82:9
   |
80 |         assert result is None
81 |
82 |     def test_cache_ttl_expiration(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
83 |         """Тест истечения срока кеша."""
84 |         cache = ResponseCache(ttl_seconds=1)
   |
help: Add return type annotation: `None`

SLF001 Private member accessed: `_cache`
   --> tests\integration\test_ai_service.py:100:9
    |
 99 |         # Имитируем истечение TTL
100 |         cache._cache[cache._generate_key(messages, "deepseek-chat")]["timestamp"] = (
    |         ^^^^^^^^^^^^
101 |             datetime.now() - timedelta(seconds=2)
102 |         )
    |

SLF001 Private member accessed: `_generate_key`
   --> tests\integration\test_ai_service.py:100:22
    |
 99 |         # Имитируем истечение TTL
100 |         cache._cache[cache._generate_key(messages, "deepseek-chat")]["timestamp"] = (
    |                      ^^^^^^^^^^^^^^^^^^^
101 |             datetime.now() - timedelta(seconds=2)
102 |         )
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests\integration\test_ai_service.py:101:13
    |
 99 |         # Имитируем истечение TTL
100 |         cache._cache[cache._generate_key(messages, "deepseek-chat")]["timestamp"] = (
101 |             datetime.now() - timedelta(seconds=2)
    |             ^^^^^^^^^^^^^^
102 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ANN201 Missing return type annotation for public function `test_cache_clear`
   --> tests\integration\test_ai_service.py:107:9
    |
105 |         assert cache.get(messages, "deepseek-chat") is None
106 |
107 |     def test_cache_clear(self):
    |         ^^^^^^^^^^^^^^^^
108 |         """Тест очистки кеша."""
109 |         cache = ResponseCache()
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_message_creation`
   --> tests\integration\test_ai_service.py:128:9
    |
126 |     """Тесты для структуры сообщений диалога."""
127 |
128 |     def test_message_creation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^
129 |         """Тест создания сообщения."""
130 |         msg = ConversationMessage(
    |
help: Add return type annotation: `None`

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests\integration\test_ai_service.py:133:23
    |
131 |             role="user",
132 |             content="Hello world",
133 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
134 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ANN201 Missing return type annotation for public function `test_message_without_timestamp`
   --> tests\integration\test_ai_service.py:140:9
    |
138 |         assert isinstance(msg.timestamp, datetime)
139 |
140 |     def test_message_without_timestamp(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
141 |         """Тест создания сообщения без времени."""
142 |         msg = ConversationMessage(role="assistant", content="Hi!")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_response_creation`
   --> tests\integration\test_ai_service.py:152:9
    |
150 |     """Тесты для структуры ответа AI."""
151 |
152 |     def test_response_creation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^
153 |         """Тест создания ответа AI."""
154 |         response = AIResponse(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_response_default_cached`
   --> tests\integration\test_ai_service.py:168:9
    |
166 |         assert response.cached is False
167 |
168 |     def test_response_default_cached(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |         """Тест значения по умолчанию для cached."""
170 |         response = AIResponse(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `ai_service`
   --> tests\integration\test_ai_service.py:185:9
    |
184 |     @pytest.fixture
185 |     def ai_service(self):
    |         ^^^^^^^^^^
186 |         """Фикстура для создания AI сервиса."""
187 |         return AIService()
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `mock_config`
   --> tests\integration\test_ai_service.py:190:9
    |
189 |     @pytest.fixture
190 |     def mock_config(self):
    |         ^^^^^^^^^^^
191 |         """Фикстура для мокирования конфигурации."""
192 |         with patch("app.services.ai_service.get_config") as mock:
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_service_initialization`
   --> tests\integration\test_ai_service.py:204:15
    |
202 |             yield config
203 |
204 |     async def test_service_initialization(self, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
205 |         """Тест инициализации AI сервиса."""
206 |         assert ai_service._client is None
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:204:49
    |
202 |             yield config
203 |
204 |     async def test_service_initialization(self, ai_service, mock_config):
    |                                                 ^^^^^^^^^^
205 |         """Тест инициализации AI сервиса."""
206 |         assert ai_service._client is None
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:204:61
    |
202 |             yield config
203 |
204 |     async def test_service_initialization(self, ai_service, mock_config):
    |                                                             ^^^^^^^^^^^
205 |         """Тест инициализации AI сервиса."""
206 |         assert ai_service._client is None
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:204:61
    |
202 |             yield config
203 |
204 |     async def test_service_initialization(self, ai_service, mock_config):
    |                                                             ^^^^^^^^^^^
205 |         """Тест инициализации AI сервиса."""
206 |         assert ai_service._client is None
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_ai_service.py:206:16
    |
204 |     async def test_service_initialization(self, ai_service, mock_config):
205 |         """Тест инициализации AI сервиса."""
206 |         assert ai_service._client is None
    |                ^^^^^^^^^^^^^^^^^^
207 |         assert ai_service._cache is not None
208 |         assert ai_service._default_temperature == 0.7
    |

SLF001 Private member accessed: `_cache`
   --> tests\integration\test_ai_service.py:207:16
    |
205 |         """Тест инициализации AI сервиса."""
206 |         assert ai_service._client is None
207 |         assert ai_service._cache is not None
    |                ^^^^^^^^^^^^^^^^^
208 |         assert ai_service._default_temperature == 0.7
209 |         assert ai_service._default_max_tokens == 1000
    |

SLF001 Private member accessed: `_default_temperature`
   --> tests\integration\test_ai_service.py:208:16
    |
206 |         assert ai_service._client is None
207 |         assert ai_service._cache is not None
208 |         assert ai_service._default_temperature == 0.7
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
209 |         assert ai_service._default_max_tokens == 1000
210 |         assert ai_service._timeout == 30
    |

SLF001 Private member accessed: `_default_max_tokens`
   --> tests\integration\test_ai_service.py:209:16
    |
207 |         assert ai_service._cache is not None
208 |         assert ai_service._default_temperature == 0.7
209 |         assert ai_service._default_max_tokens == 1000
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |         assert ai_service._timeout == 30
    |

SLF001 Private member accessed: `_timeout`
   --> tests\integration\test_ai_service.py:210:16
    |
208 |         assert ai_service._default_temperature == 0.7
209 |         assert ai_service._default_max_tokens == 1000
210 |         assert ai_service._timeout == 30
    |                ^^^^^^^^^^^^^^^^^^^
211 |
212 |     async def test_get_client_creation(self, ai_service, mock_config):
    |

ANN201 Missing return type annotation for public function `test_get_client_creation`
   --> tests\integration\test_ai_service.py:212:15
    |
210 |         assert ai_service._timeout == 30
211 |
212 |     async def test_get_client_creation(self, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^
213 |         """Тест создания HTTP клиента."""
214 |         client = await ai_service._get_client()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:212:46
    |
210 |         assert ai_service._timeout == 30
211 |
212 |     async def test_get_client_creation(self, ai_service, mock_config):
    |                                              ^^^^^^^^^^
213 |         """Тест создания HTTP клиента."""
214 |         client = await ai_service._get_client()
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:212:58
    |
210 |         assert ai_service._timeout == 30
211 |
212 |     async def test_get_client_creation(self, ai_service, mock_config):
    |                                                          ^^^^^^^^^^^
213 |         """Тест создания HTTP клиента."""
214 |         client = await ai_service._get_client()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:212:58
    |
210 |         assert ai_service._timeout == 30
211 |
212 |     async def test_get_client_creation(self, ai_service, mock_config):
    |                                                          ^^^^^^^^^^^
213 |         """Тест создания HTTP клиента."""
214 |         client = await ai_service._get_client()
    |

SLF001 Private member accessed: `_get_client`
   --> tests\integration\test_ai_service.py:214:24
    |
212 |     async def test_get_client_creation(self, ai_service, mock_config):
213 |         """Тест создания HTTP клиента."""
214 |         client = await ai_service._get_client()
    |                        ^^^^^^^^^^^^^^^^^^^^^^
215 |
216 |         assert client is not None
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_ai_service.py:218:16
    |
216 |         assert client is not None
217 |         assert isinstance(client, httpx.AsyncClient)
218 |         assert ai_service._client is client
    |                ^^^^^^^^^^^^^^^^^^
219 |
220 |         # Проверяем, что повторный вызов возвращает тот же клиент
    |

SLF001 Private member accessed: `_get_client`
   --> tests\integration\test_ai_service.py:221:25
    |
220 |         # Проверяем, что повторный вызов возвращает тот же клиент
221 |         client2 = await ai_service._get_client()
    |                         ^^^^^^^^^^^^^^^^^^^^^^
222 |         assert client is client2
    |

ANN201 Missing return type annotation for public function `test_client_close`
   --> tests\integration\test_ai_service.py:224:15
    |
222 |         assert client is client2
223 |
224 |     async def test_client_close(self, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^
225 |         """Тест закрытия HTTP клиента."""
226 |         await ai_service._get_client()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:224:39
    |
222 |         assert client is client2
223 |
224 |     async def test_client_close(self, ai_service, mock_config):
    |                                       ^^^^^^^^^^
225 |         """Тест закрытия HTTP клиента."""
226 |         await ai_service._get_client()
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:224:51
    |
222 |         assert client is client2
223 |
224 |     async def test_client_close(self, ai_service, mock_config):
    |                                                   ^^^^^^^^^^^
225 |         """Тест закрытия HTTP клиента."""
226 |         await ai_service._get_client()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:224:51
    |
222 |         assert client is client2
223 |
224 |     async def test_client_close(self, ai_service, mock_config):
    |                                                   ^^^^^^^^^^^
225 |         """Тест закрытия HTTP клиента."""
226 |         await ai_service._get_client()
    |

SLF001 Private member accessed: `_get_client`
   --> tests\integration\test_ai_service.py:226:15
    |
224 |     async def test_client_close(self, ai_service, mock_config):
225 |         """Тест закрытия HTTP клиента."""
226 |         await ai_service._get_client()
    |               ^^^^^^^^^^^^^^^^^^^^^^
227 |         assert ai_service._client is not None
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_ai_service.py:227:16
    |
225 |         """Тест закрытия HTTP клиента."""
226 |         await ai_service._get_client()
227 |         assert ai_service._client is not None
    |                ^^^^^^^^^^^^^^^^^^
228 |
229 |         await ai_service.close()
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_ai_service.py:230:16
    |
229 |         await ai_service.close()
230 |         assert ai_service._client is None
    |                ^^^^^^^^^^^^^^^^^^
231 |
232 |     def test_prepare_messages(self, ai_service):
    |

ANN201 Missing return type annotation for public function `test_prepare_messages`
   --> tests\integration\test_ai_service.py:232:9
    |
230 |         assert ai_service._client is None
231 |
232 |     def test_prepare_messages(self, ai_service):
    |         ^^^^^^^^^^^^^^^^^^^^^
233 |         """Тест подготовки сообщений для API."""
234 |         messages = [
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:232:37
    |
230 |         assert ai_service._client is None
231 |
232 |     def test_prepare_messages(self, ai_service):
    |                                     ^^^^^^^^^^
233 |         """Тест подготовки сообщений для API."""
234 |         messages = [
    |

SLF001 Private member accessed: `_prepare_messages`
   --> tests\integration\test_ai_service.py:240:20
    |
238 |         ]
239 |
240 |         prepared = ai_service._prepare_messages(messages)
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 |
242 |         assert len(prepared) == 3
    |

ANN201 Missing return type annotation for public function `test_generate_response_validation`
   --> tests\integration\test_ai_service.py:247:15
    |
245 |         assert prepared[2] == {"role": "user", "content": "How are you?"}
246 |
247 |     async def test_generate_response_validation(self, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
248 |         """Тест валидации параметров для генерации ответа."""
249 |         # Тест пустого списка сообщений
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:247:55
    |
245 |         assert prepared[2] == {"role": "user", "content": "How are you?"}
246 |
247 |     async def test_generate_response_validation(self, ai_service, mock_config):
    |                                                       ^^^^^^^^^^
248 |         """Тест валидации параметров для генерации ответа."""
249 |         # Тест пустого списка сообщений
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:247:67
    |
245 |         assert prepared[2] == {"role": "user", "content": "How are you?"}
246 |
247 |     async def test_generate_response_validation(self, ai_service, mock_config):
    |                                                                   ^^^^^^^^^^^
248 |         """Тест валидации параметров для генерации ответа."""
249 |         # Тест пустого списка сообщений
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:247:67
    |
245 |         assert prepared[2] == {"role": "user", "content": "How are you?"}
246 |
247 |     async def test_generate_response_validation(self, ai_service, mock_config):
    |                                                                   ^^^^^^^^^^^
248 |         """Тест валидации параметров для генерации ответа."""
249 |         # Тест пустого списка сообщений
    |

ANN201 Missing return type annotation for public function `test_generate_response_success`
   --> tests\integration\test_ai_service.py:264:15
    |
263 |     @patch("app.services.ai_service.AIService._make_api_request")
264 |     async def test_generate_response_success(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
265 |         self,
266 |         mock_api_request,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_api_request`
   --> tests\integration\test_ai_service.py:266:9
    |
264 |     async def test_generate_response_success(
265 |         self,
266 |         mock_api_request,
    |         ^^^^^^^^^^^^^^^^
267 |         ai_service,
268 |         mock_config,
    |

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:267:9
    |
265 |         self,
266 |         mock_api_request,
267 |         ai_service,
    |         ^^^^^^^^^^
268 |         mock_config,
269 |     ):
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:268:9
    |
266 |         mock_api_request,
267 |         ai_service,
268 |         mock_config,
    |         ^^^^^^^^^^^
269 |     ):
270 |         """Тест успешной генерации ответа."""
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:268:9
    |
266 |         mock_api_request,
267 |         ai_service,
268 |         mock_config,
    |         ^^^^^^^^^^^
269 |     ):
270 |         """Тест успешной генерации ответа."""
    |

ANN201 Missing return type annotation for public function `test_generate_response_with_cache`
   --> tests\integration\test_ai_service.py:295:15
    |
294 |     @patch("app.services.ai_service.AIService._make_api_request")
295 |     async def test_generate_response_with_cache(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
296 |         self,
297 |         mock_api_request,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_api_request`
   --> tests\integration\test_ai_service.py:297:9
    |
295 |     async def test_generate_response_with_cache(
296 |         self,
297 |         mock_api_request,
    |         ^^^^^^^^^^^^^^^^
298 |         ai_service,
299 |         mock_config,
    |

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:298:9
    |
296 |         self,
297 |         mock_api_request,
298 |         ai_service,
    |         ^^^^^^^^^^
299 |         mock_config,
300 |     ):
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:299:9
    |
297 |         mock_api_request,
298 |         ai_service,
299 |         mock_config,
    |         ^^^^^^^^^^^
300 |     ):
301 |         """Тест генерации ответа с кешированием."""
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:299:9
    |
297 |         mock_api_request,
298 |         ai_service,
299 |         mock_config,
    |         ^^^^^^^^^^^
300 |     ):
301 |         """Тест генерации ответа с кешированием."""
    |

ANN201 Missing return type annotation for public function `test_generate_simple_response`
   --> tests\integration\test_ai_service.py:329:15
    |
327 |         assert response2.content == "Кешированный ответ"
328 |
329 |     async def test_generate_simple_response(self, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
330 |         """Тест упрощенного метода генерации ответа."""
331 |         with patch.object(ai_service, "generate_response") as mock_generate:
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:329:51
    |
327 |         assert response2.content == "Кешированный ответ"
328 |
329 |     async def test_generate_simple_response(self, ai_service, mock_config):
    |                                                   ^^^^^^^^^^
330 |         """Тест упрощенного метода генерации ответа."""
331 |         with patch.object(ai_service, "generate_response") as mock_generate:
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:329:63
    |
327 |         assert response2.content == "Кешированный ответ"
328 |
329 |     async def test_generate_simple_response(self, ai_service, mock_config):
    |                                                               ^^^^^^^^^^^
330 |         """Тест упрощенного метода генерации ответа."""
331 |         with patch.object(ai_service, "generate_response") as mock_generate:
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:329:63
    |
327 |         assert response2.content == "Кешированный ответ"
328 |
329 |     async def test_generate_simple_response(self, ai_service, mock_config):
    |                                                               ^^^^^^^^^^^
330 |         """Тест упрощенного метода генерации ответа."""
331 |         with patch.object(ai_service, "generate_response") as mock_generate:
    |

F841 Local variable `response` is assigned to but never used
   --> tests\integration\test_ai_service.py:339:13
    |
337 |             )
338 |
339 |             response = await ai_service.generate_simple_response("Привет")
    |             ^^^^^^^^
340 |
341 |             # Проверяем, что вызвался generate_response с правильными сообщениями
    |
help: Remove assignment to unused variable `response`

ANN201 Missing return type annotation for public function `test_clear_cache`
   --> tests\integration\test_ai_service.py:352:9
    |
350 |             assert messages[1].content == "Привет"
351 |
352 |     def test_clear_cache(self, ai_service):
    |         ^^^^^^^^^^^^^^^^
353 |         """Тест очистки кеша сервиса."""
354 |         # Добавляем что-то в кеш
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:352:32
    |
350 |             assert messages[1].content == "Привет"
351 |
352 |     def test_clear_cache(self, ai_service):
    |                                ^^^^^^^^^^
353 |         """Тест очистки кеша сервиса."""
354 |         # Добавляем что-то в кеш
    |

SLF001 Private member accessed: `_cache`
   --> tests\integration\test_ai_service.py:355:9
    |
353 |         """Тест очистки кеша сервиса."""
354 |         # Добавляем что-то в кеш
355 |         ai_service._cache._cache["test"] = {"data": "test"}
    |         ^^^^^^^^^^^^^^^^^
356 |
357 |         # Очищаем кеш
    |

SLF001 Private member accessed: `_cache`
   --> tests\integration\test_ai_service.py:355:9
    |
353 |         """Тест очистки кеша сервиса."""
354 |         # Добавляем что-то в кеш
355 |         ai_service._cache._cache["test"] = {"data": "test"}
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
356 |
357 |         # Очищаем кеш
    |

SLF001 Private member accessed: `_cache`
   --> tests\integration\test_ai_service.py:361:16
    |
360 |         # Проверяем, что кеш пуст
361 |         assert ai_service._cache._cache == {}
    |                ^^^^^^^^^^^^^^^^^
362 |
363 |     @patch("app.services.ai_service.AIService.generate_response")
    |

SLF001 Private member accessed: `_cache`
   --> tests\integration\test_ai_service.py:361:16
    |
360 |         # Проверяем, что кеш пуст
361 |         assert ai_service._cache._cache == {}
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
362 |
363 |     @patch("app.services.ai_service.AIService.generate_response")
    |

ANN201 Missing return type annotation for public function `test_health_check_healthy`
   --> tests\integration\test_ai_service.py:364:15
    |
363 |     @patch("app.services.ai_service.AIService.generate_response")
364 |     async def test_health_check_healthy(self, mock_generate, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
365 |         """Тест health check при работающем сервисе."""
366 |         mock_generate.return_value = AIResponse(
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_generate`
   --> tests\integration\test_ai_service.py:364:47
    |
363 |     @patch("app.services.ai_service.AIService.generate_response")
364 |     async def test_health_check_healthy(self, mock_generate, ai_service, mock_config):
    |                                               ^^^^^^^^^^^^^
365 |         """Тест health check при работающем сервисе."""
366 |         mock_generate.return_value = AIResponse(
    |

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:364:62
    |
363 |     @patch("app.services.ai_service.AIService.generate_response")
364 |     async def test_health_check_healthy(self, mock_generate, ai_service, mock_config):
    |                                                              ^^^^^^^^^^
365 |         """Тест health check при работающем сервисе."""
366 |         mock_generate.return_value = AIResponse(
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:364:74
    |
363 |     @patch("app.services.ai_service.AIService.generate_response")
364 |     async def test_health_check_healthy(self, mock_generate, ai_service, mock_config):
    |                                                                          ^^^^^^^^^^^
365 |         """Тест health check при работающем сервисе."""
366 |         mock_generate.return_value = AIResponse(
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:364:74
    |
363 |     @patch("app.services.ai_service.AIService.generate_response")
364 |     async def test_health_check_healthy(self, mock_generate, ai_service, mock_config):
    |                                                                          ^^^^^^^^^^^
365 |         """Тест health check при работающем сервисе."""
366 |         mock_generate.return_value = AIResponse(
    |

ANN201 Missing return type annotation for public function `test_health_check_unhealthy`
   --> tests\integration\test_ai_service.py:381:15
    |
380 |     @patch("app.services.ai_service.AIService.generate_response")
381 |     async def test_health_check_unhealthy(self, mock_generate, ai_service, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
382 |         """Тест health check при неработающем сервисе."""
383 |         mock_generate.side_effect = APIConnectionError("Connection failed")
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_generate`
   --> tests\integration\test_ai_service.py:381:49
    |
380 |     @patch("app.services.ai_service.AIService.generate_response")
381 |     async def test_health_check_unhealthy(self, mock_generate, ai_service, mock_config):
    |                                                 ^^^^^^^^^^^^^
382 |         """Тест health check при неработающем сервисе."""
383 |         mock_generate.side_effect = APIConnectionError("Connection failed")
    |

ANN001 Missing type annotation for function argument `ai_service`
   --> tests\integration\test_ai_service.py:381:64
    |
380 |     @patch("app.services.ai_service.AIService.generate_response")
381 |     async def test_health_check_unhealthy(self, mock_generate, ai_service, mock_config):
    |                                                                ^^^^^^^^^^
382 |         """Тест health check при неработающем сервисе."""
383 |         mock_generate.side_effect = APIConnectionError("Connection failed")
    |

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_ai_service.py:381:76
    |
380 |     @patch("app.services.ai_service.AIService.generate_response")
381 |     async def test_health_check_unhealthy(self, mock_generate, ai_service, mock_config):
    |                                                                            ^^^^^^^^^^^
382 |         """Тест health check при неработающем сервисе."""
383 |         mock_generate.side_effect = APIConnectionError("Connection failed")
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_ai_service.py:381:76
    |
380 |     @patch("app.services.ai_service.AIService.generate_response")
381 |     async def test_health_check_unhealthy(self, mock_generate, ai_service, mock_config):
    |                                                                            ^^^^^^^^^^^
382 |         """Тест health check при неработающем сервисе."""
383 |         mock_generate.side_effect = APIConnectionError("Connection failed")
    |

ANN201 Missing return type annotation for public function `test_error_hierarchy`
   --> tests\integration\test_ai_service.py:395:9
    |
393 |     """Тесты для обработки ошибок AI сервиса."""
394 |
395 |     def test_error_hierarchy(self):
    |         ^^^^^^^^^^^^^^^^^^^^
396 |         """Тест иерархии ошибок."""
397 |         # Проверяем наследование
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_get_ai_service_singleton`
   --> tests\integration\test_ai_service.py:417:15
    |
415 |     """Тесты для singleton pattern AI сервиса."""
416 |
417 |     async def test_get_ai_service_singleton(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
418 |         """Тест singleton behavior для get_ai_service."""
419 |         # Очищаем глобальный экземпляр если есть
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_close_ai_service`
   --> tests\integration\test_ai_service.py:430:15
    |
428 |         await close_ai_service()
429 |
430 |     async def test_close_ai_service(self):
    |               ^^^^^^^^^^^^^^^^^^^^^
431 |         """Тест закрытия AI сервиса."""
432 |         service = get_ai_service()
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_real_api_call`
   --> tests\integration\test_ai_service.py:450:15
    |
449 |     @pytest.mark.skip(reason="Требует реальный API ключ")
450 |     async def test_real_api_call(self):
    |               ^^^^^^^^^^^^^^^^^^
451 |         """Интеграционный тест с реальным API (требует API ключ)."""
452 |         service = AIService()
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_create_engine_success`
  --> tests\integration\test_database.py:35:15
   |
33 |     @patch("app.database.get_config")
34 |     @patch("app.database.create_async_engine")
35 |     async def test_create_engine_success(
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |         self,
37 |         mock_create_async_engine,
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_create_async_engine`
  --> tests\integration\test_database.py:37:9
   |
35 |     async def test_create_engine_success(
36 |         self,
37 |         mock_create_async_engine,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
38 |         mock_get_config,
39 |     ):
   |

ANN001 Missing type annotation for function argument `mock_get_config`
  --> tests\integration\test_database.py:38:9
   |
36 |         self,
37 |         mock_create_async_engine,
38 |         mock_get_config,
   |         ^^^^^^^^^^^^^^^
39 |     ):
40 |         """Тест успешного создания движка БД."""
   |

ANN201 Missing return type annotation for public function `test_create_engine_debug_mode`
  --> tests\integration\test_database.py:74:15
   |
73 |     @patch("app.database.get_config")
74 |     async def test_create_engine_debug_mode(self, mock_get_config):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |         """Тест создания движка в debug режиме."""
76 |         mock_config = MagicMock()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_config`
  --> tests\integration\test_database.py:74:51
   |
73 |     @patch("app.database.get_config")
74 |     async def test_create_engine_debug_mode(self, mock_get_config):
   |                                                   ^^^^^^^^^^^^^^^
75 |         """Тест создания движка в debug режиме."""
76 |         mock_config = MagicMock()
   |

ANN201 Missing return type annotation for public function `test_create_session_factory`
  --> tests\integration\test_database.py:94:15
   |
92 |             assert call_args["echo_pool"] is True
93 |
94 |     async def test_create_session_factory(self):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
95 |         """Тест создания фабрики сессий."""
96 |         mock_engine = MagicMock(spec=AsyncEngine)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_init_db_success`
   --> tests\integration\test_database.py:122:15
    |
120 |     @patch("app.database.create_session_factory")
121 |     @patch("app.database.check_connection")
122 |     async def test_init_db_success(
    |               ^^^^^^^^^^^^^^^^^^^^
123 |         self,
124 |         mock_check_conn,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_check_conn`
   --> tests\integration\test_database.py:124:9
    |
122 |     async def test_init_db_success(
123 |         self,
124 |         mock_check_conn,
    |         ^^^^^^^^^^^^^^^
125 |         mock_create_factory,
126 |         mock_create_engine,
    |

ANN001 Missing type annotation for function argument `mock_create_factory`
   --> tests\integration\test_database.py:125:9
    |
123 |         self,
124 |         mock_check_conn,
125 |         mock_create_factory,
    |         ^^^^^^^^^^^^^^^^^^^
126 |         mock_create_engine,
127 |         mock_get_config,
    |

ANN001 Missing type annotation for function argument `mock_create_engine`
   --> tests\integration\test_database.py:126:9
    |
124 |         mock_check_conn,
125 |         mock_create_factory,
126 |         mock_create_engine,
    |         ^^^^^^^^^^^^^^^^^^
127 |         mock_get_config,
128 |     ):
    |

ANN001 Missing type annotation for function argument `mock_get_config`
   --> tests\integration\test_database.py:127:9
    |
125 |         mock_create_factory,
126 |         mock_create_engine,
127 |         mock_get_config,
    |         ^^^^^^^^^^^^^^^
128 |     ):
129 |         """Тест успешной инициализации БД."""
    |

ANN201 Missing return type annotation for public function `test_init_db_failure`
   --> tests\integration\test_database.py:154:15
    |
152 |     @patch("app.database.get_config")
153 |     @patch("app.database.create_engine")
154 |     async def test_init_db_failure(self, mock_create_engine, mock_get_config):
    |               ^^^^^^^^^^^^^^^^^^^^
155 |         """Тест неудачной инициализации БД."""
156 |         # Мокаем конфигурацию
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_create_engine`
   --> tests\integration\test_database.py:154:42
    |
152 |     @patch("app.database.get_config")
153 |     @patch("app.database.create_engine")
154 |     async def test_init_db_failure(self, mock_create_engine, mock_get_config):
    |                                          ^^^^^^^^^^^^^^^^^^
155 |         """Тест неудачной инициализации БД."""
156 |         # Мокаем конфигурацию
    |

ANN001 Missing type annotation for function argument `mock_get_config`
   --> tests\integration\test_database.py:154:62
    |
152 |     @patch("app.database.get_config")
153 |     @patch("app.database.create_engine")
154 |     async def test_init_db_failure(self, mock_create_engine, mock_get_config):
    |                                                              ^^^^^^^^^^^^^^^
155 |         """Тест неудачной инициализации БД."""
156 |         # Мокаем конфигурацию
    |

ANN201 Missing return type annotation for public function `test_close_db_success`
   --> tests\integration\test_database.py:172:15
    |
171 |     @patch("app.database._engine")
172 |     async def test_close_db_success(self, mock_engine):
    |               ^^^^^^^^^^^^^^^^^^^^^
173 |         """Тест успешного закрытия БД."""
174 |         mock_engine_instance = AsyncMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_engine`
   --> tests\integration\test_database.py:172:43
    |
171 |     @patch("app.database._engine")
172 |     async def test_close_db_success(self, mock_engine):
    |                                           ^^^^^^^^^^^
173 |         """Тест успешного закрытия БД."""
174 |         mock_engine_instance = AsyncMock()
    |

F841 Local variable `mock_engine` is assigned to but never used
   --> tests\integration\test_database.py:175:9
    |
173 |         """Тест успешного закрытия БД."""
174 |         mock_engine_instance = AsyncMock()
175 |         mock_engine = mock_engine_instance
    |         ^^^^^^^^^^^
176 |
177 |         with patch("app.database._engine", mock_engine_instance):
    |
help: Remove assignment to unused variable `mock_engine`

ANN201 Missing return type annotation for public function `test_close_db_no_engine`
   --> tests\integration\test_database.py:182:15
    |
180 |             mock_engine_instance.dispose.assert_called_once()
181 |
182 |     async def test_close_db_no_engine(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^
183 |         """Тест закрытия БД когда движок не инициализирован."""
184 |         with patch("app.database._engine", None):
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_check_connection_success`
   --> tests\integration\test_database.py:194:15
    |
193 |     @patch("app.database.get_session")
194 |     async def test_check_connection_success(self, mock_get_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
195 |         """Тест успешной проверки подключения."""
196 |         # Мокируем сессию и её методы
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_session`
   --> tests\integration\test_database.py:194:51
    |
193 |     @patch("app.database.get_session")
194 |     async def test_check_connection_success(self, mock_get_session):
    |                                                   ^^^^^^^^^^^^^^^^
195 |         """Тест успешной проверки подключения."""
196 |         # Мокируем сессию и её методы
    |

ANN201 Missing return type annotation for public function `test_check_connection_failure`
   --> tests\integration\test_database.py:212:15
    |
211 |     @patch("app.database.get_session")
212 |     async def test_check_connection_failure(self, mock_get_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |         """Тест неудачной проверки подключения."""
214 |         # Мокируем исключение при выполнении запроса
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_session`
   --> tests\integration\test_database.py:212:51
    |
211 |     @patch("app.database.get_session")
212 |     async def test_check_connection_failure(self, mock_get_session):
    |                                                   ^^^^^^^^^^^^^^^^
213 |         """Тест неудачной проверки подключения."""
214 |         # Мокируем исключение при выполнении запроса
    |

ANN201 Missing return type annotation for public function `test_get_engine_success`
   --> tests\integration\test_database.py:230:9
    |
228 |     """Тесты для getter функций БД."""
229 |
230 |     def test_get_engine_success(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
231 |         """Тест получения движка когда он инициализирован."""
232 |         mock_engine = MagicMock()
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_get_engine_not_initialized`
   --> tests\integration\test_database.py:238:9
    |
236 |             assert engine == mock_engine
237 |
238 |     def test_get_engine_not_initialized(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
239 |         """Тест получения движка когда он не инициализирован."""
240 |         with patch("app.database._engine", None):
    |
help: Add return type annotation: `None`

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_database.py:240:9
    |
238 |       def test_get_engine_not_initialized(self):
239 |           """Тест получения движка когда он не инициализирован."""
240 | /         with patch("app.database._engine", None):
241 | |             with pytest.raises(RuntimeError, match="База данных не инициализирована"):
    | |______________________________________________________________________________________^
242 |                   get_engine()
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_get_session_factory_success`
   --> tests\integration\test_database.py:244:9
    |
242 |                 get_engine()
243 |
244 |     def test_get_session_factory_success(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
245 |         """Тест получения фабрики сессий когда она инициализирована."""
246 |         mock_factory = MagicMock()
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_get_session_factory_not_initialized`
   --> tests\integration\test_database.py:252:9
    |
250 |             assert factory == mock_factory
251 |
252 |     def test_get_session_factory_not_initialized(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
253 |         """Тест получения фабрики сессий когда она не инициализирована."""
254 |         with patch("app.database._session_factory", None):
    |
help: Add return type annotation: `None`

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_database.py:254:9
    |
252 |       def test_get_session_factory_not_initialized(self):
253 |           """Тест получения фабрики сессий когда она не инициализирована."""
254 | /         with patch("app.database._session_factory", None):
255 | |             with pytest.raises(RuntimeError, match="База данных не инициализирована"):
    | |______________________________________________________________________________________^
256 |                   get_session_factory()
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_get_session_success`
   --> tests\integration\test_database.py:264:15
    |
263 |     @patch("app.database.get_session_factory")
264 |     async def test_get_session_success(self, mock_get_factory):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^
265 |         """Тест успешного создания и использования сессии."""
266 |         # Мокируем фабрику и сессию
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_factory`
   --> tests\integration\test_database.py:264:46
    |
263 |     @patch("app.database.get_session_factory")
264 |     async def test_get_session_success(self, mock_get_factory):
    |                                              ^^^^^^^^^^^^^^^^
265 |         """Тест успешного создания и использования сессии."""
266 |         # Мокируем фабрику и сессию
    |

ANN201 Missing return type annotation for public function `test_get_session_rollback_on_error`
   --> tests\integration\test_database.py:281:15
    |
280 |     @patch("app.database.get_session_factory")
281 |     async def test_get_session_rollback_on_error(self, mock_get_factory):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |         """Тест rollback при ошибке в сессии."""
283 |         mock_session = AsyncMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_factory`
   --> tests\integration\test_database.py:281:56
    |
280 |     @patch("app.database.get_session_factory")
281 |     async def test_get_session_rollback_on_error(self, mock_get_factory):
    |                                                        ^^^^^^^^^^^^^^^^
282 |         """Тест rollback при ошибке в сессии."""
283 |         mock_session = AsyncMock()
    |

F841 Local variable `session` is assigned to but never used
   --> tests\integration\test_database.py:292:41
    |
291 |         with pytest.raises(SQLAlchemyError):
292 |             async with get_session() as session:
    |                                         ^^^^^^^
293 |                 pass  # Ошибка возникнет при commit
    |
help: Remove assignment to unused variable `session`

ANN201 Missing return type annotation for public function `test_get_session_rollback_on_exception`
   --> tests\integration\test_database.py:300:15
    |
299 |     @patch("app.database.get_session_factory")
300 |     async def test_get_session_rollback_on_exception(self, mock_get_factory):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
301 |         """Тест rollback при общем исключении."""
302 |         mock_session = AsyncMock()
    |
help: Add return type annotation: `Never`

ANN001 Missing type annotation for function argument `mock_get_factory`
   --> tests\integration\test_database.py:300:60
    |
299 |     @patch("app.database.get_session_factory")
300 |     async def test_get_session_rollback_on_exception(self, mock_get_factory):
    |                                                            ^^^^^^^^^^^^^^^^
301 |         """Тест rollback при общем исключении."""
302 |         mock_session = AsyncMock()
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\integration\test_database.py:307:28
    |
305 |         mock_get_factory.return_value = mock_factory
306 |
307 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^
308 |             async with get_session() as session:
309 |                 raise ValueError("Test exception")
    |

F841 Local variable `session` is assigned to but never used
   --> tests\integration\test_database.py:308:41
    |
307 |         with pytest.raises(ValueError):
308 |             async with get_session() as session:
    |                                         ^^^^^^^
309 |                 raise ValueError("Test exception")
    |
help: Remove assignment to unused variable `session`

TRY003 Avoid specifying long messages outside the exception class
   --> tests\integration\test_database.py:309:23
    |
307 |         with pytest.raises(ValueError):
308 |             async with get_session() as session:
309 |                 raise ValueError("Test exception")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
310 |
311 |         # Проверяем, что был вызван rollback
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\integration\test_database.py:309:34
    |
307 |         with pytest.raises(ValueError):
308 |             async with get_session() as session:
309 |                 raise ValueError("Test exception")
    |                                  ^^^^^^^^^^^^^^^^
310 |
311 |         # Проверяем, что был вызван rollback
    |
help: Assign to variable; remove string literal

ANN201 Missing return type annotation for public function `test_create_tables_success`
   --> tests\integration\test_database.py:321:15
    |
320 |     @patch("app.database.get_engine")
321 |     async def test_create_tables_success(self, mock_get_engine):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^
322 |         """Тест успешного создания таблиц."""
323 |         mock_engine = AsyncMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_engine`
   --> tests\integration\test_database.py:321:48
    |
320 |     @patch("app.database.get_engine")
321 |     async def test_create_tables_success(self, mock_get_engine):
    |                                                ^^^^^^^^^^^^^^^
322 |         """Тест успешного создания таблиц."""
323 |         mock_engine = AsyncMock()
    |

ANN201 Missing return type annotation for public function `test_create_tables_failure`
   --> tests\integration\test_database.py:339:15
    |
338 |     @patch("app.database.get_engine")
339 |     async def test_create_tables_failure(self, mock_get_engine):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^
340 |         """Тест неудачного создания таблиц."""
341 |         mock_engine = AsyncMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_engine`
   --> tests\integration\test_database.py:339:48
    |
338 |     @patch("app.database.get_engine")
339 |     async def test_create_tables_failure(self, mock_get_engine):
    |                                                ^^^^^^^^^^^^^^^
340 |         """Тест неудачного создания таблиц."""
341 |         mock_engine = AsyncMock()
    |

ANN201 Missing return type annotation for public function `test_drop_tables_debug_mode`
   --> tests\integration\test_database.py:357:15
    |
355 |     @patch("app.database.get_config")
356 |     @patch("app.database.get_engine")
357 |     async def test_drop_tables_debug_mode(self, mock_get_engine, mock_get_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
358 |         """Тест удаления таблиц в debug режиме."""
359 |         mock_config = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_engine`
   --> tests\integration\test_database.py:357:49
    |
355 |     @patch("app.database.get_config")
356 |     @patch("app.database.get_engine")
357 |     async def test_drop_tables_debug_mode(self, mock_get_engine, mock_get_config):
    |                                                 ^^^^^^^^^^^^^^^
358 |         """Тест удаления таблиц в debug режиме."""
359 |         mock_config = MagicMock()
    |

ANN001 Missing type annotation for function argument `mock_get_config`
   --> tests\integration\test_database.py:357:66
    |
355 |     @patch("app.database.get_config")
356 |     @patch("app.database.get_engine")
357 |     async def test_drop_tables_debug_mode(self, mock_get_engine, mock_get_config):
    |                                                                  ^^^^^^^^^^^^^^^
358 |         """Тест удаления таблиц в debug режиме."""
359 |         mock_config = MagicMock()
    |

ANN201 Missing return type annotation for public function `test_drop_tables_production_mode`
   --> tests\integration\test_database.py:379:15
    |
378 |     @patch("app.database.get_config")
379 |     async def test_drop_tables_production_mode(self, mock_get_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
380 |         """Тест запрета удаления таблиц в production режиме."""
381 |         mock_config = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_get_config`
   --> tests\integration\test_database.py:379:54
    |
378 |     @patch("app.database.get_config")
379 |     async def test_drop_tables_production_mode(self, mock_get_config):
    |                                                      ^^^^^^^^^^^^^^^
380 |         """Тест запрета удаления таблиц в production режиме."""
381 |         mock_config = MagicMock()
    |

ANN201 Missing return type annotation for public function `test_base_exists`
   --> tests\integration\test_database.py:396:9
    |
394 |     """Тесты для базового класса моделей."""
395 |
396 |     def test_base_exists(self):
    |         ^^^^^^^^^^^^^^^^
397 |         """Тест существования базового класса."""
398 |         assert Base is not None
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_full_database_lifecycle`
   --> tests\integration\test_database.py:411:15
    |
410 |     @pytest.mark.skip(reason="Требует настроенную БД")
411 |     async def test_full_database_lifecycle(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
412 |         """Интеграционный тест полного жизненного цикла БД."""
413 |         # Инициализация
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_database_error_handling`
   --> tests\integration\test_database.py:433:15
    |
432 |     @pytest.mark.skip(reason="Требует настроенную БД")
433 |     async def test_database_error_handling(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
434 |         """Интеграционный тест обработки ошибок БД."""
435 |         # Тест с неправильными параметрами подключения
    |
help: Add return type annotation: `None`

B017 Do not assert blind exception: `Exception`
   --> tests\integration\test_database.py:446:18
    |
444 |             mock_config.return_value = config
445 |
446 |             with pytest.raises(Exception):
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^
447 |                 await init_db()
    |

PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\integration\test_database.py:446:32
    |
444 |             mock_config.return_value = config
445 |
446 |             with pytest.raises(Exception):
    |                                ^^^^^^^^^
447 |                 await init_db()
    |

ANN201 Missing return type annotation for public function `test_all_exports_exist`
   --> tests\integration\test_database.py:454:9
    |
453 |     @pytest.mark.skip(reason="Temporarily disabled due to commit issues")
454 |     def test_all_exports_exist(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^
455 |         """Тест наличия всех экспортируемых элементов."""
456 |         from app.database import __all__
    |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
   --> tests\integration\test_database.py:456:9
    |
454 |     def test_all_exports_exist(self):
455 |         """Тест наличия всех экспортируемых элементов."""
456 |         from app.database import __all__
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
457 |
458 |         expected_exports = [
    |

PLC0415 `import` should be at the top-level of a file
   --> tests\integration\test_database.py:473:9
    |
472 |         # Проверяем, что все элементы действительно импортируются
473 |         import app.database as db_module
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
474 |
475 |         for export in expected_exports:
    |

ANN201 Missing return type annotation for public function `test_provider_initialization`
  --> tests\integration\test_deepseek_provider.py:29:9
   |
27 |     """Тесты инициализации DeepSeek провайдера."""
28 |
29 |     def test_provider_initialization(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |         """Тест инициализации провайдера."""
31 |         provider = DeepSeekProvider()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_deepseek_provider.py:29:44
   |
27 |     """Тесты инициализации DeepSeek провайдера."""
28 |
29 |     def test_provider_initialization(self, mock_config):
   |                                            ^^^^^^^^^^^
30 |         """Тест инициализации провайдера."""
31 |         provider = DeepSeekProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_deepseek_provider.py:29:44
   |
27 |     """Тесты инициализации DeepSeek провайдера."""
28 |
29 |     def test_provider_initialization(self, mock_config):
   |                                            ^^^^^^^^^^^
30 |         """Тест инициализации провайдера."""
31 |         provider = DeepSeekProvider()
   |

ANN201 Missing return type annotation for public function `test_provider_configuration_check`
  --> tests\integration\test_deepseek_provider.py:37:9
   |
35 |         assert hasattr(provider, "_client")
36 |
37 |     def test_provider_configuration_check(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         """Тест проверки конфигурации провайдера."""
39 |         provider = DeepSeekProvider()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_deepseek_provider.py:37:49
   |
35 |         assert hasattr(provider, "_client")
36 |
37 |     def test_provider_configuration_check(self, mock_config):
   |                                                 ^^^^^^^^^^^
38 |         """Тест проверки конфигурации провайдера."""
39 |         provider = DeepSeekProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_deepseek_provider.py:37:49
   |
35 |         assert hasattr(provider, "_client")
36 |
37 |     def test_provider_configuration_check(self, mock_config):
   |                                                 ^^^^^^^^^^^
38 |         """Тест проверки конфигурации провайдера."""
39 |         provider = DeepSeekProvider()
   |

ANN201 Missing return type annotation for public function `test_provider_availability_check`
  --> tests\integration\test_deepseek_provider.py:54:9
   |
52 |             assert provider_unconfigured.is_configured() is False
53 |
54 |     def test_provider_availability_check(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |         """Тест проверки доступности провайдера."""
56 |         provider = DeepSeekProvider()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_deepseek_provider.py:54:48
   |
52 |             assert provider_unconfigured.is_configured() is False
53 |
54 |     def test_provider_availability_check(self, mock_config):
   |                                                ^^^^^^^^^^^
55 |         """Тест проверки доступности провайдера."""
56 |         provider = DeepSeekProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_deepseek_provider.py:54:48
   |
52 |             assert provider_unconfigured.is_configured() is False
53 |
54 |     def test_provider_availability_check(self, mock_config):
   |                                                ^^^^^^^^^^^
55 |         """Тест проверки доступности провайдера."""
56 |         provider = DeepSeekProvider()
   |

E501 Line too long (92 > 88)
  --> tests\integration\test_deepseek_provider.py:59:89
   |
58 |         # По умолчанию провайдер считается доступным если настроен
59 |         # Note: is_available() is async, но в простых тестах можно проверить is_configured()
   |                                                                                         ^^^^
60 |         assert provider.is_configured() is True
   |

ANN201 Missing return type annotation for public function `provider`
  --> tests\integration\test_deepseek_provider.py:69:9
   |
68 |     @pytest.fixture
69 |     def provider(self, mock_config):
   |         ^^^^^^^^
70 |         """Провайдер для тестов."""
71 |         return DeepSeekProvider()
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_deepseek_provider.py:69:24
   |
68 |     @pytest.fixture
69 |     def provider(self, mock_config):
   |                        ^^^^^^^^^^^
70 |         """Провайдер для тестов."""
71 |         return DeepSeekProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_deepseek_provider.py:69:24
   |
68 |     @pytest.fixture
69 |     def provider(self, mock_config):
   |                        ^^^^^^^^^^^
70 |         """Провайдер для тестов."""
71 |         return DeepSeekProvider()
   |

ANN201 Missing return type annotation for public function `sample_messages`
  --> tests\integration\test_deepseek_provider.py:74:9
   |
73 |     @pytest.fixture
74 |     def sample_messages(self):
   |         ^^^^^^^^^^^^^^^
75 |         """Пример сообщений для тестов."""
76 |         return [
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_successful_api_request`
  --> tests\integration\test_deepseek_provider.py:85:15
   |
84 |     @pytest.mark.asyncio
85 |     async def test_successful_api_request(self, provider, sample_messages):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |         """Тест успешного API запроса."""
87 |         # Мокаем HTTP ответ в стиле DeepSeek API
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
  --> tests\integration\test_deepseek_provider.py:85:49
   |
84 |     @pytest.mark.asyncio
85 |     async def test_successful_api_request(self, provider, sample_messages):
   |                                                 ^^^^^^^^
86 |         """Тест успешного API запроса."""
87 |         # Мокаем HTTP ответ в стиле DeepSeek API
   |

ANN001 Missing type annotation for function argument `sample_messages`
  --> tests\integration\test_deepseek_provider.py:85:59
   |
84 |     @pytest.mark.asyncio
85 |     async def test_successful_api_request(self, provider, sample_messages):
   |                                                           ^^^^^^^^^^^^^^^
86 |         """Тест успешного API запроса."""
87 |         # Мокаем HTTP ответ в стиле DeepSeek API
   |

E501 Line too long (100 > 88)
   --> tests\integration\test_deepseek_provider.py:100:89
    |
 98 | …     "message": {
 99 | …         "role": "assistant",
100 | …         "content": "Квантовая физика изучает поведение частиц на атомном уровне...",
    |                                                                           ^^^^^^^^^^^^
101 | …     },
102 | …     "finish_reason": "stop",
    |

ANN201 Missing return type annotation for public function `test_api_request_with_parameters`
   --> tests\integration\test_deepseek_provider.py:123:15
    |
122 |     @pytest.mark.asyncio
123 |     async def test_api_request_with_parameters(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 |         """Тест API запроса с дополнительными параметрами."""
125 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:123:54
    |
122 |     @pytest.mark.asyncio
123 |     async def test_api_request_with_parameters(self, provider, sample_messages):
    |                                                      ^^^^^^^^
124 |         """Тест API запроса с дополнительными параметрами."""
125 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:123:64
    |
122 |     @pytest.mark.asyncio
123 |     async def test_api_request_with_parameters(self, provider, sample_messages):
    |                                                                ^^^^^^^^^^^^^^^
124 |         """Тест API запроса с дополнительными параметрами."""
125 |         mock_response = MagicMock()
    |

ANN201 Missing return type annotation for public function `test_http_headers`
   --> tests\integration\test_deepseek_provider.py:149:15
    |
148 |     @pytest.mark.asyncio
149 |     async def test_http_headers(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^
150 |         """Тест правильных HTTP заголовков."""
151 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:149:39
    |
148 |     @pytest.mark.asyncio
149 |     async def test_http_headers(self, provider, sample_messages):
    |                                       ^^^^^^^^
150 |         """Тест правильных HTTP заголовков."""
151 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:149:49
    |
148 |     @pytest.mark.asyncio
149 |     async def test_http_headers(self, provider, sample_messages):
    |                                                 ^^^^^^^^^^^^^^^
150 |         """Тест правильных HTTP заголовков."""
151 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:159:9
    |
157 |           }
158 |
159 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
160 | |             with patch(
161 | |                 "httpx.AsyncClient.__init__",
162 | |                 return_value=None,
163 | |             ) as mock_client_init:
    | |__________________________________^
164 |                   # Принудительно очищаем клиент
165 |                   provider._client = None
    |
help: Combine `with` statements

SLF001 Private member accessed: `_client`
   --> tests\integration\test_deepseek_provider.py:165:17
    |
163 |             ) as mock_client_init:
164 |                 # Принудительно очищаем клиент
165 |                 provider._client = None
    |                 ^^^^^^^^^^^^^^^^
166 |
167 |                 await provider.generate_response(sample_messages)
    |

ANN201 Missing return type annotation for public function `provider`
   --> tests\integration\test_deepseek_provider.py:186:9
    |
185 |     @pytest.fixture
186 |     def provider(self, mock_config):
    |         ^^^^^^^^
187 |         """Провайдер для тестов ошибок."""
188 |         return DeepSeekProvider()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_deepseek_provider.py:186:24
    |
185 |     @pytest.fixture
186 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
187 |         """Провайдер для тестов ошибок."""
188 |         return DeepSeekProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_deepseek_provider.py:186:24
    |
185 |     @pytest.fixture
186 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
187 |         """Провайдер для тестов ошибок."""
188 |         return DeepSeekProvider()
    |

ANN201 Missing return type annotation for public function `sample_messages`
   --> tests\integration\test_deepseek_provider.py:191:9
    |
190 |     @pytest.fixture
191 |     def sample_messages(self):
    |         ^^^^^^^^^^^^^^^
192 |         """Сообщения для тестов ошибок."""
193 |         return [ConversationMessage(role="user", content="Тест ошибок DeepSeek")]
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_authentication_error`
   --> tests\integration\test_deepseek_provider.py:196:15
    |
195 |     @pytest.mark.asyncio
196 |     async def test_authentication_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
197 |         """Тест ошибки аутентификации (401)."""
198 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:196:47
    |
195 |     @pytest.mark.asyncio
196 |     async def test_authentication_error(self, provider, sample_messages):
    |                                               ^^^^^^^^
197 |         """Тест ошибки аутентификации (401)."""
198 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:196:57
    |
195 |     @pytest.mark.asyncio
196 |     async def test_authentication_error(self, provider, sample_messages):
    |                                                         ^^^^^^^^^^^^^^^
197 |         """Тест ошибки аутентификации (401)."""
198 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:208:9
    |
206 |           }
207 |
208 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
209 | |             with pytest.raises(
210 | |                 APIAuthenticationError,
211 | |                 match="Неверный API ключ DeepSeek",
212 | |             ):
    | |______________^
213 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_quota_exceeded_error`
   --> tests\integration\test_deepseek_provider.py:216:15
    |
215 |     @pytest.mark.asyncio
216 |     async def test_quota_exceeded_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
217 |         """Тест ошибки превышения квоты (402)."""
218 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:216:47
    |
215 |     @pytest.mark.asyncio
216 |     async def test_quota_exceeded_error(self, provider, sample_messages):
    |                                               ^^^^^^^^
217 |         """Тест ошибки превышения квоты (402)."""
218 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:216:57
    |
215 |     @pytest.mark.asyncio
216 |     async def test_quota_exceeded_error(self, provider, sample_messages):
    |                                                         ^^^^^^^^^^^^^^^
217 |         """Тест ошибки превышения квоты (402)."""
218 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:228:9
    |
226 |           }
227 |
228 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
229 | |             with pytest.raises(
230 | |                 APIQuotaExceededError,
231 | |                 match="Недостаточно средств на счете DeepSeek API",
232 | |             ):
    | |______________^
233 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_rate_limit_error`
   --> tests\integration\test_deepseek_provider.py:236:15
    |
235 |     @pytest.mark.asyncio
236 |     async def test_rate_limit_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^
237 |         """Тест ошибки превышения лимита (429)."""
238 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:236:43
    |
235 |     @pytest.mark.asyncio
236 |     async def test_rate_limit_error(self, provider, sample_messages):
    |                                           ^^^^^^^^
237 |         """Тест ошибки превышения лимита (429)."""
238 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:236:53
    |
235 |     @pytest.mark.asyncio
236 |     async def test_rate_limit_error(self, provider, sample_messages):
    |                                                     ^^^^^^^^^^^^^^^
237 |         """Тест ошибки превышения лимита (429)."""
238 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:247:9
    |
245 |           }
246 |
247 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
248 | |             with pytest.raises(
249 | |                 APIRateLimitError,
250 | |                 match="Превышен лимит запросов к DeepSeek API",
251 | |             ):
    | |______________^
252 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_specific_deepseek_errors`
   --> tests\integration\test_deepseek_provider.py:255:15
    |
254 |     @pytest.mark.asyncio
255 |     async def test_specific_deepseek_errors(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
256 |         """Тест специфичных ошибок DeepSeek."""
257 |         # Тест ошибки модели
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:255:51
    |
254 |     @pytest.mark.asyncio
255 |     async def test_specific_deepseek_errors(self, provider, sample_messages):
    |                                                   ^^^^^^^^
256 |         """Тест специфичных ошибок DeepSeek."""
257 |         # Тест ошибки модели
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:255:61
    |
254 |     @pytest.mark.asyncio
255 |     async def test_specific_deepseek_errors(self, provider, sample_messages):
    |                                                             ^^^^^^^^^^^^^^^
256 |         """Тест специфичных ошибок DeepSeek."""
257 |         # Тест ошибки модели
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:267:9
    |
265 |           }
266 |
267 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
268 | |             with pytest.raises(APIConnectionError, match="Model not found"):
    | |____________________________________________________________________________^
269 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_server_error`
   --> tests\integration\test_deepseek_provider.py:272:15
    |
271 |     @pytest.mark.asyncio
272 |     async def test_server_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^
273 |         """Тест серверной ошибки (5xx)."""
274 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:272:39
    |
271 |     @pytest.mark.asyncio
272 |     async def test_server_error(self, provider, sample_messages):
    |                                       ^^^^^^^^
273 |         """Тест серверной ошибки (5xx)."""
274 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:272:49
    |
271 |     @pytest.mark.asyncio
272 |     async def test_server_error(self, provider, sample_messages):
    |                                                 ^^^^^^^^^^^^^^^
273 |         """Тест серверной ошибки (5xx)."""
274 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:278:9
    |
276 |           mock_response.text = "Service Temporarily Unavailable"
277 |
278 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
279 | |             with pytest.raises(
280 | |                 APIConnectionError,
281 | |                 match="Ошибка сервера DeepSeek: 503",
282 | |             ):
    | |______________^
283 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_connection_timeout`
   --> tests\integration\test_deepseek_provider.py:286:15
    |
285 |     @pytest.mark.asyncio
286 |     async def test_connection_timeout(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^
287 |         """Тест таймаута соединения."""
288 |         with patch(
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:286:45
    |
285 |     @pytest.mark.asyncio
286 |     async def test_connection_timeout(self, provider, sample_messages):
    |                                             ^^^^^^^^
287 |         """Тест таймаута соединения."""
288 |         with patch(
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_deepseek_provider.py:286:55
    |
285 |     @pytest.mark.asyncio
286 |     async def test_connection_timeout(self, provider, sample_messages):
    |                                                       ^^^^^^^^^^^^^^^
287 |         """Тест таймаута соединения."""
288 |         with patch(
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_deepseek_provider.py:288:9
    |
286 |       async def test_connection_timeout(self, provider, sample_messages):
287 |           """Тест таймаута соединения."""
288 | /         with patch(
289 | |             "httpx.AsyncClient.post",
290 | |             side_effect=httpx.TimeoutException("Request timeout"),
291 | |         ):
292 | |             with pytest.raises(
293 | |                 APIConnectionError,
294 | |                 match="Timeout при обращении к DeepSeek API",
295 | |             ):
    | |______________^
296 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `provider`
   --> tests\integration\test_deepseek_provider.py:305:9
    |
304 |     @pytest.fixture
305 |     def provider(self, mock_config):
    |         ^^^^^^^^
306 |         """Провайдер для тестов парсинга."""
307 |         return DeepSeekProvider()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_deepseek_provider.py:305:24
    |
304 |     @pytest.fixture
305 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
306 |         """Провайдер для тестов парсинга."""
307 |         return DeepSeekProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_deepseek_provider.py:305:24
    |
304 |     @pytest.fixture
305 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
306 |         """Провайдер для тестов парсинга."""
307 |         return DeepSeekProvider()
    |

ANN201 Missing return type annotation for public function `test_complete_response_parsing`
   --> tests\integration\test_deepseek_provider.py:310:15
    |
309 |     @pytest.mark.asyncio
310 |     async def test_complete_response_parsing(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
311 |         """Тест парсинга полного ответа."""
312 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:310:52
    |
309 |     @pytest.mark.asyncio
310 |     async def test_complete_response_parsing(self, provider):
    |                                                    ^^^^^^^^
311 |         """Тест парсинга полного ответа."""
312 |         mock_response = MagicMock()
    |

ANN201 Missing return type annotation for public function `test_streaming_response_handling`
   --> tests\integration\test_deepseek_provider.py:347:15
    |
346 |     @pytest.mark.asyncio
347 |     async def test_streaming_response_handling(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
348 |         """Тест обработки streaming ответов (если поддерживается)."""
349 |         # DeepSeek может поддерживать streaming, тестируем базовую обработку
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:347:54
    |
346 |     @pytest.mark.asyncio
347 |     async def test_streaming_response_handling(self, provider):
    |                                                      ^^^^^^^^
348 |         """Тест обработки streaming ответов (если поддерживается)."""
349 |         # DeepSeek может поддерживать streaming, тестируем базовую обработку
    |

ANN201 Missing return type annotation for public function `test_chinese_content_handling`
   --> tests\integration\test_deepseek_provider.py:365:15
    |
364 |     @pytest.mark.asyncio
365 |     async def test_chinese_content_handling(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
366 |         """Тест обработки китайского контента (DeepSeek специализируется на китайском)."""
367 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:365:51
    |
364 |     @pytest.mark.asyncio
365 |     async def test_chinese_content_handling(self, provider):
    |                                                   ^^^^^^^^
366 |         """Тест обработки китайского контента (DeepSeek специализируется на китайском)."""
367 |         mock_response = MagicMock()
    |

E501 Line too long (90 > 88)
   --> tests\integration\test_deepseek_provider.py:366:89
    |
364 |     @pytest.mark.asyncio
365 |     async def test_chinese_content_handling(self, provider):
366 |         """Тест обработки китайского контента (DeepSeek специализируется на китайском)."""
    |                                                                                         ^^
367 |         mock_response = MagicMock()
368 |         mock_response.status_code = 200
    |

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:391:5
    |
389 |     # def test_message_formatting(self, mock_config):
390 |     #     """Тест форматирования сообщений для DeepSeek API."""
391 |     #     provider = DeepSeekProvider()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
392 |     #
393 |     #     messages = [
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:393:5
    |
391 |     #     provider = DeepSeekProvider()
392 |     #
393 |     #     messages = [
    |     ^^^^^^^^^^^^^^^^^^
394 |     #         ConversationMessage(role="system", content="Ты эксперт по AI"),
395 |     #         ConversationMessage(role="user", content="Расскажи о нейросетях"),
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:394:5
    |
392 |     #
393 |     #     messages = [
394 |     #         ConversationMessage(role="system", content="Ты эксперт по AI"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
395 |     #         ConversationMessage(role="user", content="Расскажи о нейросетях"),
396 |     #         ConversationMessage(role="assistant", content="Нейросети это...")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:395:5
    |
393 |     #     messages = [
394 |     #         ConversationMessage(role="system", content="Ты эксперт по AI"),
395 |     #         ConversationMessage(role="user", content="Расскажи о нейросетях"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
396 |     #         ConversationMessage(role="assistant", content="Нейросети это...")
397 |     #     ]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:396:5
    |
394 |     #         ConversationMessage(role="system", content="Ты эксперт по AI"),
395 |     #         ConversationMessage(role="user", content="Расскажи о нейросетях"),
396 |     #         ConversationMessage(role="assistant", content="Нейросети это...")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
397 |     #     ]
398 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:397:5
    |
395 |     #         ConversationMessage(role="user", content="Расскажи о нейросетях"),
396 |     #         ConversationMessage(role="assistant", content="Нейросети это...")
397 |     #     ]
    |     ^^^^^^^
398 |     #
399 |     #     formatted = provider._format_messages(messages)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:399:5
    |
397 |     #     ]
398 |     #
399 |     #     formatted = provider._format_messages(messages)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
400 |     #
401 |     #     assert len(formatted) == 3
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:401:5
    |
399 |     #     formatted = provider._format_messages(messages)
400 |     #
401 |     #     assert len(formatted) == 3
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
402 |     #     assert all(msg["role"] in ["system", "user", "assistant"] for msg in formatted)
403 |     #     assert formatted[0]["content"] == "Ты эксперт по AI"
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:402:5
    |
400 |     #
401 |     #     assert len(formatted) == 3
402 |     #     assert all(msg["role"] in ["system", "user", "assistant"] for msg in formatted)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
403 |     #     assert formatted[0]["content"] == "Ты эксперт по AI"
    |
help: Remove commented-out code

E501 Line too long (89 > 88)
   --> tests\integration\test_deepseek_provider.py:402:89
    |
400 |     #
401 |     #     assert len(formatted) == 3
402 |     #     assert all(msg["role"] in ["system", "user", "assistant"] for msg in formatted)
    |                                                                                         ^
403 |     #     assert formatted[0]["content"] == "Ты эксперт по AI"
    |

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:403:5
    |
401 |     #     assert len(formatted) == 3
402 |     #     assert all(msg["role"] in ["system", "user", "assistant"] for msg in formatted)
403 |     #     assert formatted[0]["content"] == "Ты эксперт по AI"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
404 |
405 |     # def test_request_preparation(self, mock_config):
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:407:5
    |
405 |     # def test_request_preparation(self, mock_config):
406 |     #     """Тест подготовки запроса."""
407 |     #     provider = DeepSeekProvider()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
408 |     #
409 |     #     messages = [ConversationMessage(role="user", content="Тест запроса")]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:409:5
    |
407 |     #     provider = DeepSeekProvider()
408 |     #
409 |     #     messages = [ConversationMessage(role="user", content="Тест запроса")]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
410 |     #
411 |     #     request_data = provider._prepare_request_data(
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:411:5
    |
409 |     #     messages = [ConversationMessage(role="user", content="Тест запроса")]
410 |     #
411 |     #     request_data = provider._prepare_request_data(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
412 |     #         messages,
413 |     #         temperature=0.7,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:413:5
    |
411 |     #     request_data = provider._prepare_request_data(
412 |     #         messages,
413 |     #         temperature=0.7,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
414 |     #         max_tokens=2000
415 |     #     )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:414:5
    |
412 |     #         messages,
413 |     #         temperature=0.7,
414 |     #         max_tokens=2000
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
415 |     #     )
416 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:415:5
    |
413 |     #         temperature=0.7,
414 |     #         max_tokens=2000
415 |     #     )
    |     ^^^^^^^
416 |     #
417 |     #     assert request_data["model"] == mock_config.deepseek.deepseek_model
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:417:5
    |
415 |     #     )
416 |     #
417 |     #     assert request_data["model"] == mock_config.deepseek.deepseek_model
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
418 |     #     assert request_data["temperature"] == 0.7
419 |     #     assert request_data["max_tokens"] == 2000
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:418:5
    |
416 |     #
417 |     #     assert request_data["model"] == mock_config.deepseek.deepseek_model
418 |     #     assert request_data["temperature"] == 0.7
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
419 |     #     assert request_data["max_tokens"] == 2000
420 |     #     assert "messages" in request_data
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:419:5
    |
417 |     #     assert request_data["model"] == mock_config.deepseek.deepseek_model
418 |     #     assert request_data["temperature"] == 0.7
419 |     #     assert request_data["max_tokens"] == 2000
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
420 |     #     assert "messages" in request_data
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:424:5
    |
422 |     # def test_error_extraction(self, mock_config):
423 |     #     """Тест извлечения ошибок из ответа."""
424 |     #     provider = DeepSeekProvider()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
425 |     #
426 |     #     error_response = {
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:426:5
    |
424 |     #     provider = DeepSeekProvider()
425 |     #
426 |     #     error_response = {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
427 |     #         "error": {
428 |     #             "message": "Test error message",
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:427:5
    |
425 |     #
426 |     #     error_response = {
427 |     #         "error": {
    |     ^^^^^^^^^^^^^^^^^^^^
428 |     #             "message": "Test error message",
429 |     #             "type": "test_error",
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:428:5
    |
426 |     #     error_response = {
427 |     #         "error": {
428 |     #             "message": "Test error message",
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
429 |     #             "type": "test_error",
430 |     #             "code": "test_code"
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:429:5
    |
427 |     #         "error": {
428 |     #             "message": "Test error message",
429 |     #             "type": "test_error",
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
430 |     #             "code": "test_code"
431 |     #         }
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:431:5
    |
429 |     #             "type": "test_error",
430 |     #             "code": "test_code"
431 |     #         }
    |     ^^^^^^^^^^^
432 |     #     }
433 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:432:5
    |
430 |     #             "code": "test_code"
431 |     #         }
432 |     #     }
    |     ^^^^^^^
433 |     #
434 |     #     error_msg = provider._extract_error_message(error_response)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:434:5
    |
432 |     #     }
433 |     #
434 |     #     error_msg = provider._extract_error_message(error_response)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
435 |     #     assert "Test error message" in error_msg
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `test_provider_close`
   --> tests\integration\test_deepseek_provider.py:444:15
    |
443 |     @pytest.mark.asyncio
444 |     async def test_provider_close(self, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^
445 |         """Тест закрытия провайдера."""
446 |         provider = DeepSeekProvider()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_deepseek_provider.py:444:41
    |
443 |     @pytest.mark.asyncio
444 |     async def test_provider_close(self, mock_config):
    |                                         ^^^^^^^^^^^
445 |         """Тест закрытия провайдера."""
446 |         provider = DeepSeekProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_deepseek_provider.py:444:41
    |
443 |     @pytest.mark.asyncio
444 |     async def test_provider_close(self, mock_config):
    |                                         ^^^^^^^^^^^
445 |         """Тест закрытия провайдера."""
446 |         provider = DeepSeekProvider()
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_deepseek_provider.py:450:9
    |
448 |         # Создаем мок клиента
449 |         mock_client = AsyncMock()
450 |         provider._client = mock_client
    |         ^^^^^^^^^^^^^^^^
451 |
452 |         await provider.close()
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_deepseek_provider.py:455:16
    |
454 |         mock_client.aclose.assert_called_once()
455 |         assert provider._client is None
    |                ^^^^^^^^^^^^^^^^
456 |
457 |     # @pytest.mark.asyncio
    |

ERA001 Found commented-out code
   --> tests\integration\test_deepseek_provider.py:462:5
    |
460 |     #     async with DeepSeekProvider(mock_config.deepseek) as provider:
461 |     #         assert provider is not None
462 |     #         assert hasattr(provider, '_config')
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
463 |     #
464 |     #     # После выхода из контекста провайдер должен быть закрыт
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `provider`
   --> tests\integration\test_deepseek_provider.py:474:9
    |
473 |     @pytest.fixture
474 |     def provider(self, mock_config):
    |         ^^^^^^^^
475 |         """Провайдер для тестов специфичных функций."""
476 |         return DeepSeekProvider()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_deepseek_provider.py:474:24
    |
473 |     @pytest.fixture
474 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
475 |         """Провайдер для тестов специфичных функций."""
476 |         return DeepSeekProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_deepseek_provider.py:474:24
    |
473 |     @pytest.fixture
474 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
475 |         """Провайдер для тестов специфичных функций."""
476 |         return DeepSeekProvider()
    |

ANN201 Missing return type annotation for public function `test_code_generation_request`
   --> tests\integration\test_deepseek_provider.py:479:15
    |
478 |     @pytest.mark.asyncio
479 |     async def test_code_generation_request(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
480 |         """Тест запроса на генерацию кода (DeepSeek хорош в программировании)."""
481 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:479:50
    |
478 |     @pytest.mark.asyncio
479 |     async def test_code_generation_request(self, provider):
    |                                                  ^^^^^^^^
480 |         """Тест запроса на генерацию кода (DeepSeek хорош в программировании)."""
481 |         mock_response = MagicMock()
    |

E501 Line too long (149 > 88)
   --> tests\integration\test_deepseek_provider.py:487:89
    |
485 | …
486 | …
487 | …bonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n```",
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
488 | …
489 | …
    |

ANN201 Missing return type annotation for public function `test_math_problem_solving`
   --> tests\integration\test_deepseek_provider.py:510:15
    |
509 |     @pytest.mark.asyncio
510 |     async def test_math_problem_solving(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
511 |         """Тест решения математических задач."""
512 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_deepseek_provider.py:510:47
    |
509 |     @pytest.mark.asyncio
510 |     async def test_math_problem_solving(self, provider):
    |                                               ^^^^^^^^
511 |         """Тест решения математических задач."""
512 |         mock_response = MagicMock()
    |

E501 Line too long (174 > 88)
   --> tests\integration\test_deepseek_provider.py:518:89
    |
516 | …
517 | …
518 | … + 6 = 0:\n\nИспользуем квадратную формулу:\nx = (-5 ± √(25-24))/2 = (-5 ± 1)/2\n\nОтветы: x₁ = -2, x₂ = -3",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
519 | …
520 | …
    |

ANN201 Missing return type annotation for public function `test_real_api_connection`
   --> tests\integration\test_deepseek_provider.py:546:15
    |
545 |     @pytest.mark.asyncio
546 |     async def test_real_api_connection(self, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^
547 |         """Тест реального подключения к DeepSeek API."""
548 |         # Этот тест выполняется только если есть настоящий ключ
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_deepseek_provider.py:546:46
    |
545 |     @pytest.mark.asyncio
546 |     async def test_real_api_connection(self, mock_config):
    |                                              ^^^^^^^^^^^
547 |         """Тест реального подключения к DeepSeek API."""
548 |         # Этот тест выполняется только если есть настоящий ключ
    |

ANN201 Missing return type annotation for public function `mock_message`
  --> tests\integration\test_message_handler.py:38:9
   |
37 |     @pytest.fixture
38 |     def mock_message(self):
   |         ^^^^^^^^^^^^
39 |         """Создает мок объект сообщения."""
40 |         message = MagicMock(spec=Message)
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_get_existing_user`
  --> tests\integration\test_message_handler.py:48:15
   |
47 |     @pytest.mark.asyncio
48 |     async def test_get_existing_user(self, mock_message, mock_session):
   |               ^^^^^^^^^^^^^^^^^^^^^^
49 |         """Тест получения существующего пользователя."""
50 |         # Arrange
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
  --> tests\integration\test_message_handler.py:48:44
   |
47 |     @pytest.mark.asyncio
48 |     async def test_get_existing_user(self, mock_message, mock_session):
   |                                            ^^^^^^^^^^^^
49 |         """Тест получения существующего пользователя."""
50 |         # Arrange
   |

ANN001 Missing type annotation for function argument `mock_session`
  --> tests\integration\test_message_handler.py:48:58
   |
47 |     @pytest.mark.asyncio
48 |     async def test_get_existing_user(self, mock_message, mock_session):
   |                                                          ^^^^^^^^^^^^
49 |         """Тест получения существующего пользователя."""
50 |         # Arrange
   |

ANN201 Missing return type annotation for public function `test_user_not_found`
  --> tests\integration\test_message_handler.py:74:15
   |
73 |     @pytest.mark.asyncio
74 |     async def test_user_not_found(self, mock_message, mock_session):
   |               ^^^^^^^^^^^^^^^^^^^
75 |         """Тест случая когда пользователь не найден."""
76 |         # Arrange
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
  --> tests\integration\test_message_handler.py:74:41
   |
73 |     @pytest.mark.asyncio
74 |     async def test_user_not_found(self, mock_message, mock_session):
   |                                         ^^^^^^^^^^^^
75 |         """Тест случая когда пользователь не найден."""
76 |         # Arrange
   |

ANN001 Missing type annotation for function argument `mock_session`
  --> tests\integration\test_message_handler.py:74:55
   |
73 |     @pytest.mark.asyncio
74 |     async def test_user_not_found(self, mock_message, mock_session):
   |                                                       ^^^^^^^^^^^^
75 |         """Тест случая когда пользователь не найден."""
76 |         # Arrange
   |

ANN201 Missing return type annotation for public function `test_message_without_user`
  --> tests\integration\test_message_handler.py:89:15
   |
88 |     @pytest.mark.asyncio
89 |     async def test_message_without_user(self, mock_session):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^
90 |         """Тест обработки сообщения без данных пользователя."""
91 |         # Arrange
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_session`
  --> tests\integration\test_message_handler.py:89:47
   |
88 |     @pytest.mark.asyncio
89 |     async def test_message_without_user(self, mock_session):
   |                                               ^^^^^^^^^^^^
90 |         """Тест обработки сообщения без данных пользователя."""
91 |         # Arrange
   |

ARG002 Unused method argument: `mock_session`
  --> tests\integration\test_message_handler.py:89:47
   |
88 |     @pytest.mark.asyncio
89 |     async def test_message_without_user(self, mock_session):
   |                                               ^^^^^^^^^^^^
90 |         """Тест обработки сообщения без данных пользователя."""
91 |         # Arrange
   |

ANN201 Missing return type annotation for public function `test_database_error`
   --> tests\integration\test_message_handler.py:102:15
    |
101 |     @pytest.mark.asyncio
102 |     async def test_database_error(self, mock_message, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^
103 |         """Тест обработки ошибки базы данных."""
104 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:102:41
    |
101 |     @pytest.mark.asyncio
102 |     async def test_database_error(self, mock_message, mock_session):
    |                                         ^^^^^^^^^^^^
103 |         """Тест обработки ошибки базы данных."""
104 |         # Arrange
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:102:55
    |
101 |     @pytest.mark.asyncio
102 |     async def test_database_error(self, mock_message, mock_session):
    |                                                       ^^^^^^^^^^^^
103 |         """Тест обработки ошибки базы данных."""
104 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_get_conversation_history`
   --> tests\integration\test_message_handler.py:122:15
    |
121 |     @pytest.mark.asyncio
122 |     async def test_get_conversation_history(self, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |         """Тест получения истории диалогов."""
124 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:122:51
    |
121 |     @pytest.mark.asyncio
122 |     async def test_get_conversation_history(self, mock_session):
    |                                                   ^^^^^^^^^^^^
123 |         """Тест получения истории диалогов."""
124 |         # Arrange
    |

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests\integration\test_message_handler.py:131:28
    |
129 |                 role="USER",
130 |                 content="Hello",
131 |                 created_at=datetime(2025, 9, 12, 10, 0),
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
132 |             ),
133 |             Conversation(
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests\integration\test_message_handler.py:137:28
    |
135 |                 role="ASSISTANT",
136 |                 content="Hi there!",
137 |                 created_at=datetime(2025, 9, 12, 10, 1),
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
138 |             ),
139 |         ]
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

ANN201 Missing return type annotation for public function `test_empty_conversation_history`
   --> tests\integration\test_message_handler.py:157:15
    |
156 |     @pytest.mark.asyncio
157 |     async def test_empty_conversation_history(self, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
158 |         """Тест получения пустой истории диалогов."""
159 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:157:53
    |
156 |     @pytest.mark.asyncio
157 |     async def test_empty_conversation_history(self, mock_session):
    |                                                     ^^^^^^^^^^^^
158 |         """Тест получения пустой истории диалогов."""
159 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_conversation_history_database_error`
   --> tests\integration\test_message_handler.py:171:15
    |
170 |     @pytest.mark.asyncio
171 |     async def test_conversation_history_database_error(self, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
172 |         """Тест обработки ошибки при получении истории."""
173 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:171:62
    |
170 |     @pytest.mark.asyncio
171 |     async def test_conversation_history_database_error(self, mock_session):
    |                                                              ^^^^^^^^^^^^
172 |         """Тест обработки ошибки при получении истории."""
173 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_save_conversation_success`
   --> tests\integration\test_message_handler.py:187:15
    |
186 |     @pytest.mark.asyncio
187 |     async def test_save_conversation_success(self, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
188 |         """Тест успешного сохранения диалога."""
189 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:187:52
    |
186 |     @pytest.mark.asyncio
187 |     async def test_save_conversation_success(self, mock_session):
    |                                                    ^^^^^^^^^^^^
188 |         """Тест успешного сохранения диалога."""
189 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_save_conversation_database_error`
   --> tests\integration\test_message_handler.py:214:15
    |
213 |     @pytest.mark.asyncio
214 |     async def test_save_conversation_database_error(self, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
215 |         """Тест обработки ошибки при сохранении диалога."""
216 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:214:59
    |
213 |     @pytest.mark.asyncio
214 |     async def test_save_conversation_database_error(self, mock_session):
    |                                                           ^^^^^^^^^^^^
215 |         """Тест обработки ошибки при сохранении диалога."""
216 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_create_system_message`
   --> tests\integration\test_message_handler.py:238:9
    |
236 |     """Тесты функции create_system_message."""
237 |
238 |     def test_create_system_message(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
239 |         """Тест создания системного сообщения."""
240 |         # Act
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `mock_user`
   --> tests\integration\test_message_handler.py:254:9
    |
253 |     @pytest.fixture
254 |     def mock_user(self):
    |         ^^^^^^^^^
255 |         """Создает мок пользователя."""
256 |         user = User(
    |
help: Add return type annotation

RET504 Unnecessary assignment to `user` before `return` statement
   --> tests\integration\test_message_handler.py:262:16
    |
260 |             daily_message_count=1,
261 |         )
262 |         return user
    |                ^^^^
263 |
264 |     @pytest.mark.asyncio
    |
help: Remove unnecessary assignment

ANN201 Missing return type annotation for public function `test_generate_ai_response_success`
   --> tests\integration\test_message_handler.py:265:15
    |
264 |     @pytest.mark.asyncio
265 |     async def test_generate_ai_response_success(self, mock_user, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
266 |         """Тест успешной генерации AI ответа."""
267 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_user`
   --> tests\integration\test_message_handler.py:265:55
    |
264 |     @pytest.mark.asyncio
265 |     async def test_generate_ai_response_success(self, mock_user, mock_session):
    |                                                       ^^^^^^^^^
266 |         """Тест успешной генерации AI ответа."""
267 |         # Arrange
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:265:66
    |
264 |     @pytest.mark.asyncio
265 |     async def test_generate_ai_response_success(self, mock_user, mock_session):
    |                                                                  ^^^^^^^^^^^^
266 |         """Тест успешной генерации AI ответа."""
267 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_generate_ai_response_api_error`
   --> tests\integration\test_message_handler.py:301:15
    |
300 |     @pytest.mark.asyncio
301 |     async def test_generate_ai_response_api_error(self, mock_user, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
302 |         """Тест обработки ошибки AI API."""
303 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_user`
   --> tests\integration\test_message_handler.py:301:57
    |
300 |     @pytest.mark.asyncio
301 |     async def test_generate_ai_response_api_error(self, mock_user, mock_session):
    |                                                         ^^^^^^^^^
302 |         """Тест обработки ошибки AI API."""
303 |         # Arrange
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:301:68
    |
300 |     @pytest.mark.asyncio
301 |     async def test_generate_ai_response_api_error(self, mock_user, mock_session):
    |                                                                    ^^^^^^^^^^^^
302 |         """Тест обработки ошибки AI API."""
303 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_generate_ai_response_unexpected_error`
   --> tests\integration\test_message_handler.py:331:15
    |
330 |     @pytest.mark.asyncio
331 |     async def test_generate_ai_response_unexpected_error(self, mock_user, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
332 |         """Тест обработки неожиданной ошибки."""
333 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_user`
   --> tests\integration\test_message_handler.py:331:64
    |
330 |     @pytest.mark.asyncio
331 |     async def test_generate_ai_response_unexpected_error(self, mock_user, mock_session):
    |                                                                ^^^^^^^^^
332 |         """Тест обработки неожиданной ошибки."""
333 |         # Arrange
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:331:75
    |
330 |     @pytest.mark.asyncio
331 |     async def test_generate_ai_response_unexpected_error(self, mock_user, mock_session):
    |                                                                           ^^^^^^^^^^^^
332 |         """Тест обработки неожиданной ошибки."""
333 |         # Arrange
    |

ANN201 Missing return type annotation for public function `mock_message`
   --> tests\integration\test_message_handler.py:357:9
    |
356 |     @pytest.fixture
357 |     def mock_message(self):
    |         ^^^^^^^^^^^^
358 |         """Создает полный мок сообщения."""
359 |         message = MagicMock(spec=Message)
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `mock_user`
   --> tests\integration\test_message_handler.py:370:9
    |
369 |     @pytest.fixture
370 |     def mock_user(self):
    |         ^^^^^^^^^
371 |         """Создает мок пользователя с активными лимитами."""
372 |         user = MagicMock(spec=User)
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_handle_text_message_success`
   --> tests\integration\test_message_handler.py:381:15
    |
380 |     @pytest.mark.asyncio
381 |     async def test_handle_text_message_success(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
382 |         self,
383 |         mock_message,
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:383:9
    |
381 |     async def test_handle_text_message_success(
382 |         self,
383 |         mock_message,
    |         ^^^^^^^^^^^^
384 |         mock_user,
385 |         mock_session,
    |

ANN001 Missing type annotation for function argument `mock_user`
   --> tests\integration\test_message_handler.py:384:9
    |
382 |         self,
383 |         mock_message,
384 |         mock_user,
    |         ^^^^^^^^^
385 |         mock_session,
386 |     ):
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:385:9
    |
383 |         mock_message,
384 |         mock_user,
385 |         mock_session,
    |         ^^^^^^^^^^^^
386 |     ):
387 |         """Тест успешной обработки текстового сообщения."""
    |

ANN201 Missing return type annotation for public function `test_handle_text_message_no_user_data`
   --> tests\integration\test_message_handler.py:413:15
    |
412 |     @pytest.mark.asyncio
413 |     async def test_handle_text_message_no_user_data(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
414 |         """Тест обработки сообщения без данных пользователя."""
415 |         # Arrange
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_handle_text_message_no_text`
   --> tests\integration\test_message_handler.py:426:15
    |
425 |     @pytest.mark.asyncio
426 |     async def test_handle_text_message_no_text(self, mock_message):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
427 |         """Тест обработки сообщения без текста."""
428 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:426:54
    |
425 |     @pytest.mark.asyncio
426 |     async def test_handle_text_message_no_text(self, mock_message):
    |                                                      ^^^^^^^^^^^^
427 |         """Тест обработки сообщения без текста."""
428 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_handle_text_message_too_short`
   --> tests\integration\test_message_handler.py:437:15
    |
436 |     @pytest.mark.asyncio
437 |     async def test_handle_text_message_too_short(self, mock_message):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
438 |         """Тест обработки слишком короткого сообщения."""
439 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:437:56
    |
436 |     @pytest.mark.asyncio
437 |     async def test_handle_text_message_too_short(self, mock_message):
    |                                                        ^^^^^^^^^^^^
438 |         """Тест обработки слишком короткого сообщения."""
439 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_handle_text_message_too_long`
   --> tests\integration\test_message_handler.py:452:15
    |
451 |     @pytest.mark.asyncio
452 |     async def test_handle_text_message_too_long(self, mock_message):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
453 |         """Тест обработки слишком длинного сообщения."""
454 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:452:55
    |
451 |     @pytest.mark.asyncio
452 |     async def test_handle_text_message_too_long(self, mock_message):
    |                                                       ^^^^^^^^^^^^
453 |         """Тест обработки слишком длинного сообщения."""
454 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_handle_text_message_unregistered_user`
   --> tests\integration\test_message_handler.py:465:15
    |
464 |     @pytest.mark.asyncio
465 |     async def test_handle_text_message_unregistered_user(self, mock_message):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
466 |         """Тест обработки сообщения от незарегистрированного пользователя."""
467 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:465:64
    |
464 |     @pytest.mark.asyncio
465 |     async def test_handle_text_message_unregistered_user(self, mock_message):
    |                                                                ^^^^^^^^^^^^
466 |         """Тест обработки сообщения от незарегистрированного пользователя."""
467 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_handle_text_message_limit_exceeded`
   --> tests\integration\test_message_handler.py:479:15
    |
478 |     @pytest.mark.asyncio
479 |     async def test_handle_text_message_limit_exceeded(self, mock_message, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
480 |         """Тест обработки сообщения при превышении лимита."""
481 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:479:61
    |
478 |     @pytest.mark.asyncio
479 |     async def test_handle_text_message_limit_exceeded(self, mock_message, mock_session):
    |                                                             ^^^^^^^^^^^^
480 |         """Тест обработки сообщения при превышении лимита."""
481 |         # Arrange
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:479:75
    |
478 |     @pytest.mark.asyncio
479 |     async def test_handle_text_message_limit_exceeded(self, mock_message, mock_session):
    |                                                                           ^^^^^^^^^^^^
480 |         """Тест обработки сообщения при превышении лимита."""
481 |         # Arrange
    |

ARG002 Unused method argument: `mock_session`
   --> tests\integration\test_message_handler.py:479:75
    |
478 |     @pytest.mark.asyncio
479 |     async def test_handle_text_message_limit_exceeded(self, mock_message, mock_session):
    |                                                                           ^^^^^^^^^^^^
480 |         """Тест обработки сообщения при превышении лимита."""
481 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_handle_text_message_critical_error`
   --> tests\integration\test_message_handler.py:506:15
    |
505 |     @pytest.mark.asyncio
506 |     async def test_handle_text_message_critical_error(self, mock_message, mock_user):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
507 |         """Тест обработки критической ошибки."""
508 |         # Arrange
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:506:61
    |
505 |     @pytest.mark.asyncio
506 |     async def test_handle_text_message_critical_error(self, mock_message, mock_user):
    |                                                             ^^^^^^^^^^^^
507 |         """Тест обработки критической ошибки."""
508 |         # Arrange
    |

ANN001 Missing type annotation for function argument `mock_user`
   --> tests\integration\test_message_handler.py:506:75
    |
505 |     @pytest.mark.asyncio
506 |     async def test_handle_text_message_critical_error(self, mock_message, mock_user):
    |                                                                           ^^^^^^^^^
507 |         """Тест обработки критической ошибки."""
508 |         # Arrange
    |

ANN201 Missing return type annotation for public function `test_full_message_flow`
   --> tests\integration\test_message_handler.py:528:15
    |
526 |     @pytest.mark.asyncio
527 |     @pytest.mark.integration
528 |     async def test_full_message_flow(self, mock_message, mock_user, mock_session):
    |               ^^^^^^^^^^^^^^^^^^^^^^
529 |         """Тест полного потока обработки сообщения."""
530 |         # Arrange - мокаем все зависимости
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_message`
   --> tests\integration\test_message_handler.py:528:44
    |
526 |     @pytest.mark.asyncio
527 |     @pytest.mark.integration
528 |     async def test_full_message_flow(self, mock_message, mock_user, mock_session):
    |                                            ^^^^^^^^^^^^
529 |         """Тест полного потока обработки сообщения."""
530 |         # Arrange - мокаем все зависимости
    |

ANN001 Missing type annotation for function argument `mock_user`
   --> tests\integration\test_message_handler.py:528:58
    |
526 |     @pytest.mark.asyncio
527 |     @pytest.mark.integration
528 |     async def test_full_message_flow(self, mock_message, mock_user, mock_session):
    |                                                          ^^^^^^^^^
529 |         """Тест полного потока обработки сообщения."""
530 |         # Arrange - мокаем все зависимости
    |

ANN001 Missing type annotation for function argument `mock_session`
   --> tests\integration\test_message_handler.py:528:69
    |
526 |     @pytest.mark.asyncio
527 |     @pytest.mark.integration
528 |     async def test_full_message_flow(self, mock_message, mock_user, mock_session):
    |                                                                     ^^^^^^^^^^^^
529 |         """Тест полного потока обработки сообщения."""
530 |         # Arrange - мокаем все зависимости
    |

ANN201 Missing return type annotation for public function `test_provider_initialization`
  --> tests\integration\test_openrouter_provider.py:29:9
   |
27 |     """Тесты инициализации OpenRouter провайдера."""
28 |
29 |     def test_provider_initialization(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |         """Тест инициализации провайдера."""
31 |         provider = OpenRouterProvider()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_openrouter_provider.py:29:44
   |
27 |     """Тесты инициализации OpenRouter провайдера."""
28 |
29 |     def test_provider_initialization(self, mock_config):
   |                                            ^^^^^^^^^^^
30 |         """Тест инициализации провайдера."""
31 |         provider = OpenRouterProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_openrouter_provider.py:29:44
   |
27 |     """Тесты инициализации OpenRouter провайдера."""
28 |
29 |     def test_provider_initialization(self, mock_config):
   |                                            ^^^^^^^^^^^
30 |         """Тест инициализации провайдера."""
31 |         provider = OpenRouterProvider()
   |

ANN201 Missing return type annotation for public function `test_provider_configuration_check`
  --> tests\integration\test_openrouter_provider.py:37:9
   |
35 |         assert hasattr(provider, "_client")
36 |
37 |     def test_provider_configuration_check(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         """Тест проверки конфигурации провайдера."""
39 |         provider = OpenRouterProvider()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_openrouter_provider.py:37:49
   |
35 |         assert hasattr(provider, "_client")
36 |
37 |     def test_provider_configuration_check(self, mock_config):
   |                                                 ^^^^^^^^^^^
38 |         """Тест проверки конфигурации провайдера."""
39 |         provider = OpenRouterProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_openrouter_provider.py:37:49
   |
35 |         assert hasattr(provider, "_client")
36 |
37 |     def test_provider_configuration_check(self, mock_config):
   |                                                 ^^^^^^^^^^^
38 |         """Тест проверки конфигурации провайдера."""
39 |         provider = OpenRouterProvider()
   |

ANN201 Missing return type annotation for public function `test_provider_availability_check`
  --> tests\integration\test_openrouter_provider.py:56:9
   |
54 |             assert provider_unconfigured.is_configured() is False
55 |
56 |     def test_provider_availability_check(self, mock_config):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |         """Тест проверки доступности провайдера."""
58 |         provider = OpenRouterProvider()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_openrouter_provider.py:56:48
   |
54 |             assert provider_unconfigured.is_configured() is False
55 |
56 |     def test_provider_availability_check(self, mock_config):
   |                                                ^^^^^^^^^^^
57 |         """Тест проверки доступности провайдера."""
58 |         provider = OpenRouterProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_openrouter_provider.py:56:48
   |
54 |             assert provider_unconfigured.is_configured() is False
55 |
56 |     def test_provider_availability_check(self, mock_config):
   |                                                ^^^^^^^^^^^
57 |         """Тест проверки доступности провайдера."""
58 |         provider = OpenRouterProvider()
   |

E501 Line too long (92 > 88)
  --> tests\integration\test_openrouter_provider.py:61:89
   |
60 |         # По умолчанию провайдер считается доступным если настроен
61 |         # Note: is_available() is async, но в простых тестах можно проверить is_configured()
   |                                                                                         ^^^^
62 |         assert provider.is_configured() is True
   |

ANN201 Missing return type annotation for public function `provider`
  --> tests\integration\test_openrouter_provider.py:71:9
   |
70 |     @pytest.fixture
71 |     def provider(self, mock_config):
   |         ^^^^^^^^
72 |         """Провайдер для тестов."""
73 |         return OpenRouterProvider()
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
  --> tests\integration\test_openrouter_provider.py:71:24
   |
70 |     @pytest.fixture
71 |     def provider(self, mock_config):
   |                        ^^^^^^^^^^^
72 |         """Провайдер для тестов."""
73 |         return OpenRouterProvider()
   |

ARG002 Unused method argument: `mock_config`
  --> tests\integration\test_openrouter_provider.py:71:24
   |
70 |     @pytest.fixture
71 |     def provider(self, mock_config):
   |                        ^^^^^^^^^^^
72 |         """Провайдер для тестов."""
73 |         return OpenRouterProvider()
   |

ANN201 Missing return type annotation for public function `sample_messages`
  --> tests\integration\test_openrouter_provider.py:76:9
   |
75 |     @pytest.fixture
76 |     def sample_messages(self):
   |         ^^^^^^^^^^^^^^^
77 |         """Пример сообщений для тестов."""
78 |         return [
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_successful_api_request`
  --> tests\integration\test_openrouter_provider.py:84:15
   |
83 |     @pytest.mark.asyncio
84 |     async def test_successful_api_request(self, provider, sample_messages):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |         """Тест успешного API запроса."""
86 |         # Мокаем HTTP ответ
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
  --> tests\integration\test_openrouter_provider.py:84:49
   |
83 |     @pytest.mark.asyncio
84 |     async def test_successful_api_request(self, provider, sample_messages):
   |                                                 ^^^^^^^^
85 |         """Тест успешного API запроса."""
86 |         # Мокаем HTTP ответ
   |

ANN001 Missing type annotation for function argument `sample_messages`
  --> tests\integration\test_openrouter_provider.py:84:59
   |
83 |     @pytest.mark.asyncio
84 |     async def test_successful_api_request(self, provider, sample_messages):
   |                                                           ^^^^^^^^^^^^^^^
85 |         """Тест успешного API запроса."""
86 |         # Мокаем HTTP ответ
   |

ANN201 Missing return type annotation for public function `test_api_request_with_parameters`
   --> tests\integration\test_openrouter_provider.py:122:15
    |
121 |     @pytest.mark.asyncio
122 |     async def test_api_request_with_parameters(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |         """Тест API запроса с дополнительными параметрами."""
124 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:122:54
    |
121 |     @pytest.mark.asyncio
122 |     async def test_api_request_with_parameters(self, provider, sample_messages):
    |                                                      ^^^^^^^^
123 |         """Тест API запроса с дополнительными параметрами."""
124 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:122:64
    |
121 |     @pytest.mark.asyncio
122 |     async def test_api_request_with_parameters(self, provider, sample_messages):
    |                                                                ^^^^^^^^^^^^^^^
123 |         """Тест API запроса с дополнительными параметрами."""
124 |         mock_response = MagicMock()
    |

ANN201 Missing return type annotation for public function `test_http_headers`
   --> tests\integration\test_openrouter_provider.py:147:15
    |
146 |     @pytest.mark.asyncio
147 |     async def test_http_headers(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^
148 |         """Тест правильных HTTP заголовков."""
149 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:147:39
    |
146 |     @pytest.mark.asyncio
147 |     async def test_http_headers(self, provider, sample_messages):
    |                                       ^^^^^^^^
148 |         """Тест правильных HTTP заголовков."""
149 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:147:49
    |
146 |     @pytest.mark.asyncio
147 |     async def test_http_headers(self, provider, sample_messages):
    |                                                 ^^^^^^^^^^^^^^^
148 |         """Тест правильных HTTP заголовков."""
149 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:157:9
    |
155 |           }
156 |
157 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
158 | |             with patch(
159 | |                 "httpx.AsyncClient.__init__",
160 | |                 return_value=None,
161 | |             ) as mock_client_init:
    | |__________________________________^
162 |                   # Принудительно очищаем клиент
163 |                   provider._client = None
    |
help: Combine `with` statements

SLF001 Private member accessed: `_client`
   --> tests\integration\test_openrouter_provider.py:163:17
    |
161 |             ) as mock_client_init:
162 |                 # Принудительно очищаем клиент
163 |                 provider._client = None
    |                 ^^^^^^^^^^^^^^^^
164 |
165 |                 await provider.generate_response(sample_messages)
    |

ANN201 Missing return type annotation for public function `provider`
   --> tests\integration\test_openrouter_provider.py:185:9
    |
184 |     @pytest.fixture
185 |     def provider(self, mock_config):
    |         ^^^^^^^^
186 |         """Провайдер для тестов ошибок."""
187 |         return OpenRouterProvider()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_openrouter_provider.py:185:24
    |
184 |     @pytest.fixture
185 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
186 |         """Провайдер для тестов ошибок."""
187 |         return OpenRouterProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_openrouter_provider.py:185:24
    |
184 |     @pytest.fixture
185 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
186 |         """Провайдер для тестов ошибок."""
187 |         return OpenRouterProvider()
    |

ANN201 Missing return type annotation for public function `sample_messages`
   --> tests\integration\test_openrouter_provider.py:190:9
    |
189 |     @pytest.fixture
190 |     def sample_messages(self):
    |         ^^^^^^^^^^^^^^^
191 |         """Сообщения для тестов ошибок."""
192 |         return [ConversationMessage(role="user", content="Тест ошибок")]
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_authentication_error`
   --> tests\integration\test_openrouter_provider.py:195:15
    |
194 |     @pytest.mark.asyncio
195 |     async def test_authentication_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
196 |         """Тест ошибки аутентификации (401)."""
197 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:195:47
    |
194 |     @pytest.mark.asyncio
195 |     async def test_authentication_error(self, provider, sample_messages):
    |                                               ^^^^^^^^
196 |         """Тест ошибки аутентификации (401)."""
197 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:195:57
    |
194 |     @pytest.mark.asyncio
195 |     async def test_authentication_error(self, provider, sample_messages):
    |                                                         ^^^^^^^^^^^^^^^
196 |         """Тест ошибки аутентификации (401)."""
197 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:206:9
    |
204 |           }
205 |
206 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
207 | |             with pytest.raises(
208 | |                 APIAuthenticationError,
209 | |                 match="Неверный API ключ OpenRouter",
210 | |             ):
    | |______________^
211 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_quota_exceeded_error`
   --> tests\integration\test_openrouter_provider.py:214:15
    |
213 |     @pytest.mark.asyncio
214 |     async def test_quota_exceeded_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^
215 |         """Тест ошибки превышения квоты (402)."""
216 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:214:47
    |
213 |     @pytest.mark.asyncio
214 |     async def test_quota_exceeded_error(self, provider, sample_messages):
    |                                               ^^^^^^^^
215 |         """Тест ошибки превышения квоты (402)."""
216 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:214:57
    |
213 |     @pytest.mark.asyncio
214 |     async def test_quota_exceeded_error(self, provider, sample_messages):
    |                                                         ^^^^^^^^^^^^^^^
215 |         """Тест ошибки превышения квоты (402)."""
216 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:225:9
    |
223 |           }
224 |
225 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
226 | |             with pytest.raises(
227 | |                 APIQuotaExceededError,
228 | |                 match="Недостаточно средств на счете OpenRouter API",
229 | |             ):
    | |______________^
230 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_rate_limit_error`
   --> tests\integration\test_openrouter_provider.py:233:15
    |
232 |     @pytest.mark.asyncio
233 |     async def test_rate_limit_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^
234 |         """Тест ошибки превышения лимита (429)."""
235 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:233:43
    |
232 |     @pytest.mark.asyncio
233 |     async def test_rate_limit_error(self, provider, sample_messages):
    |                                           ^^^^^^^^
234 |         """Тест ошибки превышения лимита (429)."""
235 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:233:53
    |
232 |     @pytest.mark.asyncio
233 |     async def test_rate_limit_error(self, provider, sample_messages):
    |                                                     ^^^^^^^^^^^^^^^
234 |         """Тест ошибки превышения лимита (429)."""
235 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:244:9
    |
242 |           }
243 |
244 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
245 | |             with pytest.raises(
246 | |                 APIRateLimitError,
247 | |                 match="Превышен лимит запросов к OpenRouter API",
248 | |             ):
    | |______________^
249 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_server_error`
   --> tests\integration\test_openrouter_provider.py:252:15
    |
251 |     @pytest.mark.asyncio
252 |     async def test_server_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^
253 |         """Тест серверной ошибки (5xx)."""
254 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:252:39
    |
251 |     @pytest.mark.asyncio
252 |     async def test_server_error(self, provider, sample_messages):
    |                                       ^^^^^^^^
253 |         """Тест серверной ошибки (5xx)."""
254 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:252:49
    |
251 |     @pytest.mark.asyncio
252 |     async def test_server_error(self, provider, sample_messages):
    |                                                 ^^^^^^^^^^^^^^^
253 |         """Тест серверной ошибки (5xx)."""
254 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:258:9
    |
256 |           mock_response.text = "Internal Server Error"
257 |
258 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
259 | |             with pytest.raises(
260 | |                 APIConnectionError,
261 | |                 match="Ошибка сервера OpenRouter: 500",
262 | |             ):
    | |______________^
263 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_connection_error`
   --> tests\integration\test_openrouter_provider.py:266:15
    |
265 |     @pytest.mark.asyncio
266 |     async def test_connection_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^
267 |         """Тест ошибки подключения."""
268 |         with patch(
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:266:43
    |
265 |     @pytest.mark.asyncio
266 |     async def test_connection_error(self, provider, sample_messages):
    |                                           ^^^^^^^^
267 |         """Тест ошибки подключения."""
268 |         with patch(
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:266:53
    |
265 |     @pytest.mark.asyncio
266 |     async def test_connection_error(self, provider, sample_messages):
    |                                                     ^^^^^^^^^^^^^^^
267 |         """Тест ошибки подключения."""
268 |         with patch(
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:268:9
    |
266 |       async def test_connection_error(self, provider, sample_messages):
267 |           """Тест ошибки подключения."""
268 | /         with patch(
269 | |             "httpx.AsyncClient.post",
270 | |             side_effect=httpx.ConnectError("Connection failed"),
271 | |         ):
272 | |             with pytest.raises(
273 | |                 APIConnectionError,
274 | |                 match="Не удалось подключиться к OpenRouter API",
275 | |             ):
    | |______________^
276 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_timeout_error`
   --> tests\integration\test_openrouter_provider.py:279:15
    |
278 |     @pytest.mark.asyncio
279 |     async def test_timeout_error(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^
280 |         """Тест ошибки таймаута."""
281 |         with patch(
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:279:40
    |
278 |     @pytest.mark.asyncio
279 |     async def test_timeout_error(self, provider, sample_messages):
    |                                        ^^^^^^^^
280 |         """Тест ошибки таймаута."""
281 |         with patch(
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:279:50
    |
278 |     @pytest.mark.asyncio
279 |     async def test_timeout_error(self, provider, sample_messages):
    |                                                  ^^^^^^^^^^^^^^^
280 |         """Тест ошибки таймаута."""
281 |         with patch(
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:281:9
    |
279 |       async def test_timeout_error(self, provider, sample_messages):
280 |           """Тест ошибки таймаута."""
281 | /         with patch(
282 | |             "httpx.AsyncClient.post",
283 | |             side_effect=httpx.TimeoutException("Request timed out"),
284 | |         ):
285 | |             with pytest.raises(
286 | |                 APIConnectionError,
287 | |                 match="Timeout при обращении к OpenRouter API",
288 | |             ):
    | |______________^
289 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_invalid_json_response`
   --> tests\integration\test_openrouter_provider.py:292:15
    |
291 |     @pytest.mark.asyncio
292 |     async def test_invalid_json_response(self, provider, sample_messages):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^
293 |         """Тест некорректного JSON ответа."""
294 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:292:48
    |
291 |     @pytest.mark.asyncio
292 |     async def test_invalid_json_response(self, provider, sample_messages):
    |                                                ^^^^^^^^
293 |         """Тест некорректного JSON ответа."""
294 |         mock_response = MagicMock()
    |

ANN001 Missing type annotation for function argument `sample_messages`
   --> tests\integration\test_openrouter_provider.py:292:58
    |
291 |     @pytest.mark.asyncio
292 |     async def test_invalid_json_response(self, provider, sample_messages):
    |                                                          ^^^^^^^^^^^^^^^
293 |         """Тест некорректного JSON ответа."""
294 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:299:9
    |
297 |           mock_response.text = "Invalid response"
298 |
299 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
300 | |             with pytest.raises(APIConnectionError, match="Invalid JSON"):
    | |_________________________________________________________________________^
301 |                   await provider.generate_response(sample_messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `provider`
   --> tests\integration\test_openrouter_provider.py:310:9
    |
309 |     @pytest.fixture
310 |     def provider(self, mock_config):
    |         ^^^^^^^^
311 |         """Провайдер для тестов парсинга."""
312 |         return OpenRouterProvider()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_openrouter_provider.py:310:24
    |
309 |     @pytest.fixture
310 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
311 |         """Провайдер для тестов парсинга."""
312 |         return OpenRouterProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_openrouter_provider.py:310:24
    |
309 |     @pytest.fixture
310 |     def provider(self, mock_config):
    |                        ^^^^^^^^^^^
311 |         """Провайдер для тестов парсинга."""
312 |         return OpenRouterProvider()
    |

ANN201 Missing return type annotation for public function `test_minimal_response_parsing`
   --> tests\integration\test_openrouter_provider.py:315:15
    |
314 |     @pytest.mark.asyncio
315 |     async def test_minimal_response_parsing(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
316 |         """Тест парсинга минимального ответа."""
317 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:315:51
    |
314 |     @pytest.mark.asyncio
315 |     async def test_minimal_response_parsing(self, provider):
    |                                                   ^^^^^^^^
316 |         """Тест парсинга минимального ответа."""
317 |         mock_response = MagicMock()
    |

ANN201 Missing return type annotation for public function `test_empty_content_handling`
   --> tests\integration\test_openrouter_provider.py:335:15
    |
334 |     @pytest.mark.asyncio
335 |     async def test_empty_content_handling(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
336 |         """Тест обработки пустого контента."""
337 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:335:49
    |
334 |     @pytest.mark.asyncio
335 |     async def test_empty_content_handling(self, provider):
    |                                                 ^^^^^^^^
336 |         """Тест обработки пустого контента."""
337 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:345:9
    |
343 |           messages = [ConversationMessage(role="user", content="Тест")]
344 |
345 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
346 | |             with pytest.raises(
347 | |                 APIConnectionError,
348 | |                 match="Пустой ответ от OpenRouter API",
349 | |             ):
    | |______________^
350 |                   await provider.generate_response(messages)
    |
help: Combine `with` statements

ANN201 Missing return type annotation for public function `test_missing_choices_handling`
   --> tests\integration\test_openrouter_provider.py:353:15
    |
352 |     @pytest.mark.asyncio
353 |     async def test_missing_choices_handling(self, provider):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
354 |         """Тест обработки отсутствующих choices."""
355 |         mock_response = MagicMock()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `provider`
   --> tests\integration\test_openrouter_provider.py:353:51
    |
352 |     @pytest.mark.asyncio
353 |     async def test_missing_choices_handling(self, provider):
    |                                                   ^^^^^^^^
354 |         """Тест обработки отсутствующих choices."""
355 |         mock_response = MagicMock()
    |

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\integration\test_openrouter_provider.py:361:9
    |
359 |           messages = [ConversationMessage(role="user", content="Тест")]
360 |
361 | /         with patch("httpx.AsyncClient.post", return_value=mock_response):
362 | |             with pytest.raises(
363 | |                 APIConnectionError,
364 | |                 match="Некорректный формат ответа от OpenRouter API",
365 | |             ):
    | |______________^
366 |                   await provider.generate_response(messages)
    |
help: Combine `with` statements

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:376:5
    |
374 |     # def test_format_messages(self, mock_config):
375 |     #     """Тест форматирования сообщений для API."""
376 |     #     provider = OpenRouterProvider()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
377 |     #
378 |     #     messages = [
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:378:5
    |
376 |     #     provider = OpenRouterProvider()
377 |     #
378 |     #     messages = [
    |     ^^^^^^^^^^^^^^^^^^
379 |     #         ConversationMessage(role="system", content="Ты помощник"),
380 |     #         ConversationMessage(role="user", content="Привет"),
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:379:5
    |
377 |     #
378 |     #     messages = [
379 |     #         ConversationMessage(role="system", content="Ты помощник"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
380 |     #         ConversationMessage(role="user", content="Привет"),
381 |     #         ConversationMessage(role="assistant", content="Привет!")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:380:5
    |
378 |     #     messages = [
379 |     #         ConversationMessage(role="system", content="Ты помощник"),
380 |     #         ConversationMessage(role="user", content="Привет"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
381 |     #         ConversationMessage(role="assistant", content="Привет!")
382 |     #     ]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:381:5
    |
379 |     #         ConversationMessage(role="system", content="Ты помощник"),
380 |     #         ConversationMessage(role="user", content="Привет"),
381 |     #         ConversationMessage(role="assistant", content="Привет!")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
382 |     #     ]
383 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:382:5
    |
380 |     #         ConversationMessage(role="user", content="Привет"),
381 |     #         ConversationMessage(role="assistant", content="Привет!")
382 |     #     ]
    |     ^^^^^^^
383 |     #
384 |     #     formatted = provider._format_messages(messages)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:384:5
    |
382 |     #     ]
383 |     #
384 |     #     formatted = provider._format_messages(messages)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
385 |     #
386 |     #     assert len(formatted) == 3
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:386:5
    |
384 |     #     formatted = provider._format_messages(messages)
385 |     #
386 |     #     assert len(formatted) == 3
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
387 |     #     assert formatted[0]["role"] == "system"
388 |     #     assert formatted[0]["content"] == "Ты помощник"
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:387:5
    |
385 |     #
386 |     #     assert len(formatted) == 3
387 |     #     assert formatted[0]["role"] == "system"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
388 |     #     assert formatted[0]["content"] == "Ты помощник"
389 |     #     assert formatted[1]["role"] == "user"
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:388:5
    |
386 |     #     assert len(formatted) == 3
387 |     #     assert formatted[0]["role"] == "system"
388 |     #     assert formatted[0]["content"] == "Ты помощник"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
389 |     #     assert formatted[1]["role"] == "user"
390 |     #     assert formatted[2]["role"] == "assistant"
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:389:5
    |
387 |     #     assert formatted[0]["role"] == "system"
388 |     #     assert formatted[0]["content"] == "Ты помощник"
389 |     #     assert formatted[1]["role"] == "user"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
390 |     #     assert formatted[2]["role"] == "assistant"
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:390:5
    |
388 |     #     assert formatted[0]["content"] == "Ты помощник"
389 |     #     assert formatted[1]["role"] == "user"
390 |     #     assert formatted[2]["role"] == "assistant"
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
391 |
392 |     # def test_prepare_request_data(self, mock_config):
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:394:5
    |
392 |     # def test_prepare_request_data(self, mock_config):
393 |     #     """Тест подготовки данных запроса."""
394 |     #     provider = OpenRouterProvider()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
395 |     #
396 |     #     messages = [ConversationMessage(role="user", content="Тест")]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:396:5
    |
394 |     #     provider = OpenRouterProvider()
395 |     #
396 |     #     messages = [ConversationMessage(role="user", content="Тест")]
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
397 |     #
398 |     #     request_data = provider._prepare_request_data(
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:398:5
    |
396 |     #     messages = [ConversationMessage(role="user", content="Тест")]
397 |     #
398 |     #     request_data = provider._prepare_request_data(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
399 |     #         messages,
400 |     #         temperature=0.8,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:400:5
    |
398 |     #     request_data = provider._prepare_request_data(
399 |     #         messages,
400 |     #         temperature=0.8,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
401 |     #         max_tokens=100
402 |     #     )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:401:5
    |
399 |     #         messages,
400 |     #         temperature=0.8,
401 |     #         max_tokens=100
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
402 |     #     )
403 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:402:5
    |
400 |     #         temperature=0.8,
401 |     #         max_tokens=100
402 |     #     )
    |     ^^^^^^^
403 |     #
404 |     #     assert request_data["model"] == mock_config.openrouter.openrouter_model
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:404:5
    |
402 |     #     )
403 |     #
404 |     #     assert request_data["model"] == mock_config.openrouter.openrouter_model
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
405 |     #     assert request_data["temperature"] == 0.8
406 |     #     assert request_data["max_tokens"] == 100
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:405:5
    |
403 |     #
404 |     #     assert request_data["model"] == mock_config.openrouter.openrouter_model
405 |     #     assert request_data["temperature"] == 0.8
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
406 |     #     assert request_data["max_tokens"] == 100
407 |     #     assert "messages" in request_data
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:406:5
    |
404 |     #     assert request_data["model"] == mock_config.openrouter.openrouter_model
405 |     #     assert request_data["temperature"] == 0.8
406 |     #     assert request_data["max_tokens"] == 100
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
407 |     #     assert "messages" in request_data
408 |     #     assert len(request_data["messages"]) == 1
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:408:5
    |
406 |     #     assert request_data["max_tokens"] == 100
407 |     #     assert "messages" in request_data
408 |     #     assert len(request_data["messages"]) == 1
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `test_provider_close`
   --> tests\integration\test_openrouter_provider.py:417:15
    |
416 |     @pytest.mark.asyncio
417 |     async def test_provider_close(self, mock_config):
    |               ^^^^^^^^^^^^^^^^^^^
418 |         """Тест закрытия провайдера."""
419 |         provider = OpenRouterProvider()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_openrouter_provider.py:417:41
    |
416 |     @pytest.mark.asyncio
417 |     async def test_provider_close(self, mock_config):
    |                                         ^^^^^^^^^^^
418 |         """Тест закрытия провайдера."""
419 |         provider = OpenRouterProvider()
    |

ARG002 Unused method argument: `mock_config`
   --> tests\integration\test_openrouter_provider.py:417:41
    |
416 |     @pytest.mark.asyncio
417 |     async def test_provider_close(self, mock_config):
    |                                         ^^^^^^^^^^^
418 |         """Тест закрытия провайдера."""
419 |         provider = OpenRouterProvider()
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_openrouter_provider.py:423:9
    |
421 |         # Создаем мок клиента
422 |         mock_client = AsyncMock()
423 |         provider._client = mock_client
    |         ^^^^^^^^^^^^^^^^
424 |
425 |         await provider.close()
    |

SLF001 Private member accessed: `_client`
   --> tests\integration\test_openrouter_provider.py:428:16
    |
427 |         mock_client.aclose.assert_called_once()
428 |         assert provider._client is None
    |                ^^^^^^^^^^^^^^^^
429 |
430 |     # @pytest.mark.asyncio
    |

ERA001 Found commented-out code
   --> tests\integration\test_openrouter_provider.py:435:5
    |
433 |     #     async with OpenRouterProvider(mock_config.openrouter) as provider:
434 |     #         assert provider is not None
435 |     #         assert hasattr(provider, '_config')
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
436 |     #
437 |     #     # После выхода из контекста провайдер должен быть закрыт
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `test_real_api_call`
   --> tests\integration\test_openrouter_provider.py:448:15
    |
447 |     @pytest.mark.asyncio
448 |     async def test_real_api_call(self, mock_config):
    |               ^^^^^^^^^^^^^^^^^^
449 |         """Тест реального вызова API (только если есть настоящий ключ)."""
450 |         # Этот тест выполняется только если установлен реальный API ключ
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_config`
   --> tests\integration\test_openrouter_provider.py:448:40
    |
447 |     @pytest.mark.asyncio
448 |     async def test_real_api_call(self, mock_config):
    |                                        ^^^^^^^^^^^
449 |         """Тест реального вызова API (только если есть настоящий ключ)."""
450 |         # Этот тест выполняется только если установлен реальный API ключ
    |

ANN201 Missing return type annotation for public function `test_message_creation`
  --> tests\unit\test_base_ai_provider.py:30:9
   |
28 |     """Тесты для структуры ConversationMessage."""
29 |
30 |     def test_message_creation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^
31 |         """Тест создания сообщения диалога."""
32 |         msg = ConversationMessage(
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_message_with_timestamp`
  --> tests\unit\test_base_ai_provider.py:41:9
   |
39 |         assert msg.timestamp is None  # По умолчанию None
40 |
41 |     def test_message_with_timestamp(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |         """Тест создания сообщения с временной меткой."""
43 |         now = datetime.now()
   |
help: Add return type annotation: `None`

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests\unit\test_base_ai_provider.py:43:15
   |
41 |     def test_message_with_timestamp(self):
42 |         """Тест создания сообщения с временной меткой."""
43 |         now = datetime.now()
   |               ^^^^^^^^^^^^^^
44 |         msg = ConversationMessage(
45 |             role="assistant",
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

ANN201 Missing return type annotation for public function `test_message_roles_validation`
  --> tests\unit\test_base_ai_provider.py:54:9
   |
52 |         assert msg.timestamp == now
53 |
54 |     def test_message_roles_validation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |         """Тест валидации ролей сообщений."""
56 |         # Валидные роли
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_message_equality`
  --> tests\unit\test_base_ai_provider.py:63:9
   |
61 |             assert msg.role == role
62 |
63 |     def test_message_equality(self):
   |         ^^^^^^^^^^^^^^^^^^^^^
64 |         """Тест сравнения сообщений."""
65 |         msg1 = ConversationMessage(role="user", content="Тест")
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_message_string_representation`
  --> tests\unit\test_base_ai_provider.py:73:9
   |
71 |         assert msg1.content != msg3.content
72 |
73 |     def test_message_string_representation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
74 |         """Тест строкового представления сообщения."""
75 |         msg = ConversationMessage(role="user", content="Короткий тест")
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_response_creation`
  --> tests\unit\test_base_ai_provider.py:88:9
   |
86 |     """Тесты для структуры AIResponse."""
87 |
88 |     def test_response_creation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^
89 |         """Тест создания AI ответа."""
90 |         response = AIResponse(
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_cached_response`
   --> tests\unit\test_base_ai_provider.py:105:9
    |
103 |         assert response.cached is False  # По умолчанию
104 |
105 |     def test_cached_response(self):
    |         ^^^^^^^^^^^^^^^^^^^^
106 |         """Тест кешированного ответа."""
107 |         response = AIResponse(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_response_with_minimal_data`
   --> tests\unit\test_base_ai_provider.py:120:9
    |
118 |         assert response.response_time == 0.1
119 |
120 |     def test_response_with_minimal_data(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
121 |         """Тест ответа с минимальными данными."""
122 |         response = AIResponse(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_response_string_representation`
   --> tests\unit\test_base_ai_provider.py:134:9
    |
132 |         assert response.provider == "unknown"
133 |
134 |     def test_response_string_representation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 |         """Тест строкового представления ответа."""
136 |         response = AIResponse(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_base_ai_provider_error`
   --> tests\unit\test_base_ai_provider.py:154:9
    |
152 |     """Тесты для иерархии ошибок AI провайдеров."""
153 |
154 |     def test_base_ai_provider_error(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
155 |         """Тест базовой ошибки AI провайдера."""
156 |         error = AIProviderError("Базовая ошибка AI", "test-provider")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_api_connection_error`
   --> tests\unit\test_base_ai_provider.py:161:9
    |
159 |         assert isinstance(error, Exception)
160 |
161 |     def test_api_connection_error(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
162 |         """Тест ошибки подключения к API."""
163 |         error = APIConnectionError("Не удалось подключиться к API", "test-provider")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_api_authentication_error`
   --> tests\unit\test_base_ai_provider.py:168:9
    |
166 |         assert isinstance(error, AIProviderError)
167 |
168 |     def test_api_authentication_error(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |         """Тест ошибки аутентификации."""
170 |         error = APIAuthenticationError("Неверный API ключ", "test-provider")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_api_rate_limit_error`
   --> tests\unit\test_base_ai_provider.py:175:9
    |
173 |         assert isinstance(error, AIProviderError)
174 |
175 |     def test_api_rate_limit_error(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
176 |         """Тест ошибки превышения лимита."""
177 |         error = APIRateLimitError("Превышен лимит запросов", "test-provider")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_api_quota_exceeded_error`
   --> tests\unit\test_base_ai_provider.py:182:9
    |
180 |         assert isinstance(error, AIProviderError)
181 |
182 |     def test_api_quota_exceeded_error(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |         """Тест ошибки превышения квоты."""
184 |         error = APIQuotaExceededError("Превышена квота API", "test-provider")
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_error_hierarchy`
   --> tests\unit\test_base_ai_provider.py:189:9
    |
187 |         assert isinstance(error, AIProviderError)
188 |
189 |     def test_error_hierarchy(self):
    |         ^^^^^^^^^^^^^^^^^^^^
190 |         """Тест иерархии ошибок."""
191 |         # Все специфичные ошибки должны быть подклассами AIProviderError
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_base_provider_is_abstract`
   --> tests\unit\test_base_ai_provider.py:208:9
    |
206 |     """Тесты для абстрактного базового AI провайдера."""
207 |
208 |     def test_base_provider_is_abstract(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
209 |         """Тест что BaseAIProvider является абстрактным классом."""
210 |         assert issubclass(BaseAIProvider, ABC)
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_concrete_provider_implementation`
   --> tests\unit\test_base_ai_provider.py:216:9
    |
214 |             BaseAIProvider("test")
215 |
216 |     def test_concrete_provider_implementation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |         """Тест конкретной реализации провайдера."""
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
   --> tests\unit\test_base_ai_provider.py:220:17
    |
219 |         class TestProvider(BaseAIProvider):
220 |             def __init__(self):
    |                 ^^^^^^^^
221 |                 self.name = "test-provider"
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `provider_name`
   --> tests\unit\test_base_ai_provider.py:224:17
    |
223 |             @property
224 |             def provider_name(self):
    |                 ^^^^^^^^^^^^^
225 |                 return "test-provider"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `generate_response`
   --> tests\unit\test_base_ai_provider.py:227:23
    |
225 |                 return "test-provider"
226 |
227 |             async def generate_response(
    |                       ^^^^^^^^^^^^^^^^^
228 |                 self,
229 |                 messages,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `messages`
   --> tests\unit\test_base_ai_provider.py:229:17
    |
227 |             async def generate_response(
228 |                 self,
229 |                 messages,
    |                 ^^^^^^^^
230 |                 temperature=None,
231 |                 max_tokens=None,
    |

ARG002 Unused method argument: `messages`
   --> tests\unit\test_base_ai_provider.py:229:17
    |
227 |             async def generate_response(
228 |                 self,
229 |                 messages,
    |                 ^^^^^^^^
230 |                 temperature=None,
231 |                 max_tokens=None,
    |

ANN001 Missing type annotation for function argument `temperature`
   --> tests\unit\test_base_ai_provider.py:230:17
    |
228 |                 self,
229 |                 messages,
230 |                 temperature=None,
    |                 ^^^^^^^^^^^
231 |                 max_tokens=None,
232 |                 **kwargs,
    |

ARG002 Unused method argument: `temperature`
   --> tests\unit\test_base_ai_provider.py:230:17
    |
228 |                 self,
229 |                 messages,
230 |                 temperature=None,
    |                 ^^^^^^^^^^^
231 |                 max_tokens=None,
232 |                 **kwargs,
    |

ANN001 Missing type annotation for function argument `max_tokens`
   --> tests\unit\test_base_ai_provider.py:231:17
    |
229 |                 messages,
230 |                 temperature=None,
231 |                 max_tokens=None,
    |                 ^^^^^^^^^^
232 |                 **kwargs,
233 |             ):
    |

ARG002 Unused method argument: `max_tokens`
   --> tests\unit\test_base_ai_provider.py:231:17
    |
229 |                 messages,
230 |                 temperature=None,
231 |                 max_tokens=None,
    |                 ^^^^^^^^^^
232 |                 **kwargs,
233 |             ):
    |

ANN003 Missing type annotation for `**kwargs`
   --> tests\unit\test_base_ai_provider.py:232:17
    |
230 |                 temperature=None,
231 |                 max_tokens=None,
232 |                 **kwargs,
    |                 ^^^^^^^^
233 |             ):
234 |                 return AIResponse(
    |

ARG002 Unused method argument: `kwargs`
   --> tests\unit\test_base_ai_provider.py:232:19
    |
230 |                 temperature=None,
231 |                 max_tokens=None,
232 |                 **kwargs,
    |                   ^^^^^^
233 |             ):
234 |                 return AIResponse(
    |

ANN202 Missing return type annotation for private function `is_configured`
   --> tests\unit\test_base_ai_provider.py:242:17
    |
240 |                 )
241 |
242 |             def is_configured(self):
    |                 ^^^^^^^^^^^^^
243 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `is_available`
   --> tests\unit\test_base_ai_provider.py:245:23
    |
243 |                 return True
244 |
245 |             async def is_available(self):
    |                       ^^^^^^^^^^^^
246 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `health_check`
   --> tests\unit\test_base_ai_provider.py:248:23
    |
246 |                 return True
247 |
248 |             async def health_check(self):
    |                       ^^^^^^^^^^^^
249 |                 return {"status": "healthy"}
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `close`
   --> tests\unit\test_base_ai_provider.py:251:23
    |
249 |                 return {"status": "healthy"}
250 |
251 |             async def close(self):
    |                       ^^^^^
252 |                 pass
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_provider_interface_methods`
   --> tests\unit\test_base_ai_provider.py:259:15
    |
258 |     @pytest.mark.asyncio
259 |     async def test_provider_interface_methods(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 |         """Тест интерфейса методов провайдера."""
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
   --> tests\unit\test_base_ai_provider.py:263:17
    |
262 |         class MockProvider(BaseAIProvider):
263 |             def __init__(self):
    |                 ^^^^^^^^
264 |                 self.name = "mock-provider"
265 |                 self._configured = True
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `provider_name`
   --> tests\unit\test_base_ai_provider.py:269:17
    |
268 |             @property
269 |             def provider_name(self):
    |                 ^^^^^^^^^^^^^
270 |                 return "mock-provider"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `generate_response`
   --> tests\unit\test_base_ai_provider.py:272:23
    |
270 |                 return "mock-provider"
271 |
272 |             async def generate_response(
    |                       ^^^^^^^^^^^^^^^^^
273 |                 self,
274 |                 messages,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `messages`
   --> tests\unit\test_base_ai_provider.py:274:17
    |
272 |             async def generate_response(
273 |                 self,
274 |                 messages,
    |                 ^^^^^^^^
275 |                 temperature=None,
276 |                 max_tokens=None,
    |

ANN001 Missing type annotation for function argument `temperature`
   --> tests\unit\test_base_ai_provider.py:275:17
    |
273 |                 self,
274 |                 messages,
275 |                 temperature=None,
    |                 ^^^^^^^^^^^
276 |                 max_tokens=None,
277 |                 **kwargs,
    |

ARG002 Unused method argument: `temperature`
   --> tests\unit\test_base_ai_provider.py:275:17
    |
273 |                 self,
274 |                 messages,
275 |                 temperature=None,
    |                 ^^^^^^^^^^^
276 |                 max_tokens=None,
277 |                 **kwargs,
    |

ANN001 Missing type annotation for function argument `max_tokens`
   --> tests\unit\test_base_ai_provider.py:276:17
    |
274 |                 messages,
275 |                 temperature=None,
276 |                 max_tokens=None,
    |                 ^^^^^^^^^^
277 |                 **kwargs,
278 |             ):
    |

ARG002 Unused method argument: `max_tokens`
   --> tests\unit\test_base_ai_provider.py:276:17
    |
274 |                 messages,
275 |                 temperature=None,
276 |                 max_tokens=None,
    |                 ^^^^^^^^^^
277 |                 **kwargs,
278 |             ):
    |

ANN003 Missing type annotation for `**kwargs`
   --> tests\unit\test_base_ai_provider.py:277:17
    |
275 |                 temperature=None,
276 |                 max_tokens=None,
277 |                 **kwargs,
    |                 ^^^^^^^^
278 |             ):
279 |                 return AIResponse(
    |

ARG002 Unused method argument: `kwargs`
   --> tests\unit\test_base_ai_provider.py:277:19
    |
275 |                 temperature=None,
276 |                 max_tokens=None,
277 |                 **kwargs,
    |                   ^^^^^^
278 |             ):
279 |                 return AIResponse(
    |

ANN202 Missing return type annotation for private function `is_configured`
   --> tests\unit\test_base_ai_provider.py:287:17
    |
285 |                 )
286 |
287 |             def is_configured(self):
    |                 ^^^^^^^^^^^^^
288 |                 return self._configured
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `is_available`
   --> tests\unit\test_base_ai_provider.py:290:23
    |
288 |                 return self._configured
289 |
290 |             async def is_available(self):
    |                       ^^^^^^^^^^^^
291 |                 return self._available
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `health_check`
   --> tests\unit\test_base_ai_provider.py:293:23
    |
291 |                 return self._available
292 |
293 |             async def health_check(self):
    |                       ^^^^^^^^^^^^
294 |                 return {"status": "healthy" if self._available else "unhealthy"}
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `close`
   --> tests\unit\test_base_ai_provider.py:296:23
    |
294 |                 return {"status": "healthy" if self._available else "unhealthy"}
295 |
296 |             async def close(self):
    |                       ^^^^^
297 |                 self._available = False
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_provider_configuration_states`
   --> tests\unit\test_base_ai_provider.py:323:15
    |
322 |     @pytest.mark.asyncio
323 |     async def test_provider_configuration_states(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
324 |         """Тест различных состояний конфигурации провайдера."""
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
   --> tests\unit\test_base_ai_provider.py:327:17
    |
326 |         class ConfigurableProvider(BaseAIProvider):
327 |             def __init__(self, api_key=None):
    |                 ^^^^^^^^
328 |                 self.name = "configurable-provider"
329 |                 self._api_key = api_key
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `api_key`
   --> tests\unit\test_base_ai_provider.py:327:32
    |
326 |         class ConfigurableProvider(BaseAIProvider):
327 |             def __init__(self, api_key=None):
    |                                ^^^^^^^
328 |                 self.name = "configurable-provider"
329 |                 self._api_key = api_key
    |

ANN202 Missing return type annotation for private function `provider_name`
   --> tests\unit\test_base_ai_provider.py:332:17
    |
331 |             @property
332 |             def provider_name(self):
    |                 ^^^^^^^^^^^^^
333 |                 return "configurable-provider"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `generate_response`
   --> tests\unit\test_base_ai_provider.py:335:23
    |
333 |                 return "configurable-provider"
334 |
335 |             async def generate_response(
    |                       ^^^^^^^^^^^^^^^^^
336 |                 self,
337 |                 messages,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `messages`
   --> tests\unit\test_base_ai_provider.py:337:17
    |
335 |             async def generate_response(
336 |                 self,
337 |                 messages,
    |                 ^^^^^^^^
338 |                 temperature=None,
339 |                 max_tokens=None,
    |

ARG002 Unused method argument: `messages`
   --> tests\unit\test_base_ai_provider.py:337:17
    |
335 |             async def generate_response(
336 |                 self,
337 |                 messages,
    |                 ^^^^^^^^
338 |                 temperature=None,
339 |                 max_tokens=None,
    |

ANN001 Missing type annotation for function argument `temperature`
   --> tests\unit\test_base_ai_provider.py:338:17
    |
336 |                 self,
337 |                 messages,
338 |                 temperature=None,
    |                 ^^^^^^^^^^^
339 |                 max_tokens=None,
340 |                 **kwargs,
    |

ARG002 Unused method argument: `temperature`
   --> tests\unit\test_base_ai_provider.py:338:17
    |
336 |                 self,
337 |                 messages,
338 |                 temperature=None,
    |                 ^^^^^^^^^^^
339 |                 max_tokens=None,
340 |                 **kwargs,
    |

ANN001 Missing type annotation for function argument `max_tokens`
   --> tests\unit\test_base_ai_provider.py:339:17
    |
337 |                 messages,
338 |                 temperature=None,
339 |                 max_tokens=None,
    |                 ^^^^^^^^^^
340 |                 **kwargs,
341 |             ):
    |

ARG002 Unused method argument: `max_tokens`
   --> tests\unit\test_base_ai_provider.py:339:17
    |
337 |                 messages,
338 |                 temperature=None,
339 |                 max_tokens=None,
    |                 ^^^^^^^^^^
340 |                 **kwargs,
341 |             ):
    |

ANN003 Missing type annotation for `**kwargs`
   --> tests\unit\test_base_ai_provider.py:340:17
    |
338 |                 temperature=None,
339 |                 max_tokens=None,
340 |                 **kwargs,
    |                 ^^^^^^^^
341 |             ):
342 |                 if not self.is_configured():
    |

ARG002 Unused method argument: `kwargs`
   --> tests\unit\test_base_ai_provider.py:340:19
    |
338 |                 temperature=None,
339 |                 max_tokens=None,
340 |                 **kwargs,
    |                   ^^^^^^
341 |             ):
342 |                 if not self.is_configured():
    |

TRY003 Avoid specifying long messages outside the exception class
   --> tests\unit\test_base_ai_provider.py:343:27
    |
341 |               ):
342 |                   if not self.is_configured():
343 |                       raise APIAuthenticationError(
    |  ___________________________^
344 | |                         "Провайдер не настроен",
345 | |                         "configurable",
346 | |                     )
    | |_____________________^
347 |                   return AIResponse(
348 |                       content="Настроенный ответ",
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\unit\test_base_ai_provider.py:344:25
    |
342 |                 if not self.is_configured():
343 |                     raise APIAuthenticationError(
344 |                         "Провайдер не настроен",
    |                         ^^^^^^^^^^^^^^^^^^^^^^^
345 |                         "configurable",
346 |                     )
    |
help: Assign to variable; remove string literal

ANN202 Missing return type annotation for private function `is_configured`
   --> tests\unit\test_base_ai_provider.py:355:17
    |
353 |                 )
354 |
355 |             def is_configured(self):
    |                 ^^^^^^^^^^^^^
356 |                 return self._api_key is not None and self._api_key != ""
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `is_available`
   --> tests\unit\test_base_ai_provider.py:358:23
    |
356 |                 return self._api_key is not None and self._api_key != ""
357 |
358 |             async def is_available(self):
    |                       ^^^^^^^^^^^^
359 |                 return self.is_configured()
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `health_check`
   --> tests\unit\test_base_ai_provider.py:361:23
    |
359 |                 return self.is_configured()
360 |
361 |             async def health_check(self):
    |                       ^^^^^^^^^^^^
362 |                 return {"status": "healthy" if self.is_configured() else "unhealthy"}
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `close`
   --> tests\unit\test_base_ai_provider.py:364:23
    |
362 |                 return {"status": "healthy" if self.is_configured() else "unhealthy"}
363 |
364 |             async def close(self):
    |                       ^^^^^
365 |                 pass
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_provider_error_handling`
   --> tests\unit\test_base_ai_provider.py:382:15
    |
381 |     @pytest.mark.asyncio
382 |     async def test_provider_error_handling(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
383 |         """Тест обработки ошибок в провайдере."""
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
   --> tests\unit\test_base_ai_provider.py:386:17
    |
385 |         class ErrorProvider(BaseAIProvider):
386 |             def __init__(self, error_type=None):
    |                 ^^^^^^^^
387 |                 self.name = "error-provider"
388 |                 self._error_type = error_type
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `error_type`
   --> tests\unit\test_base_ai_provider.py:386:32
    |
385 |         class ErrorProvider(BaseAIProvider):
386 |             def __init__(self, error_type=None):
    |                                ^^^^^^^^^^
387 |                 self.name = "error-provider"
388 |                 self._error_type = error_type
    |

ANN202 Missing return type annotation for private function `provider_name`
   --> tests\unit\test_base_ai_provider.py:391:17
    |
390 |             @property
391 |             def provider_name(self):
    |                 ^^^^^^^^^^^^^
392 |                 return "error-provider"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `generate_response`
   --> tests\unit\test_base_ai_provider.py:394:23
    |
392 |                 return "error-provider"
393 |
394 |             async def generate_response(
    |                       ^^^^^^^^^^^^^^^^^
395 |                 self,
396 |                 messages,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `messages`
   --> tests\unit\test_base_ai_provider.py:396:17
    |
394 |             async def generate_response(
395 |                 self,
396 |                 messages,
    |                 ^^^^^^^^
397 |                 temperature=None,
398 |                 max_tokens=None,
    |

ARG002 Unused method argument: `messages`
   --> tests\unit\test_base_ai_provider.py:396:17
    |
394 |             async def generate_response(
395 |                 self,
396 |                 messages,
    |                 ^^^^^^^^
397 |                 temperature=None,
398 |                 max_tokens=None,
    |

ANN001 Missing type annotation for function argument `temperature`
   --> tests\unit\test_base_ai_provider.py:397:17
    |
395 |                 self,
396 |                 messages,
397 |                 temperature=None,
    |                 ^^^^^^^^^^^
398 |                 max_tokens=None,
399 |                 **kwargs,
    |

ARG002 Unused method argument: `temperature`
   --> tests\unit\test_base_ai_provider.py:397:17
    |
395 |                 self,
396 |                 messages,
397 |                 temperature=None,
    |                 ^^^^^^^^^^^
398 |                 max_tokens=None,
399 |                 **kwargs,
    |

ANN001 Missing type annotation for function argument `max_tokens`
   --> tests\unit\test_base_ai_provider.py:398:17
    |
396 |                 messages,
397 |                 temperature=None,
398 |                 max_tokens=None,
    |                 ^^^^^^^^^^
399 |                 **kwargs,
400 |             ):
    |

ARG002 Unused method argument: `max_tokens`
   --> tests\unit\test_base_ai_provider.py:398:17
    |
396 |                 messages,
397 |                 temperature=None,
398 |                 max_tokens=None,
    |                 ^^^^^^^^^^
399 |                 **kwargs,
400 |             ):
    |

ANN003 Missing type annotation for `**kwargs`
   --> tests\unit\test_base_ai_provider.py:399:17
    |
397 |                 temperature=None,
398 |                 max_tokens=None,
399 |                 **kwargs,
    |                 ^^^^^^^^
400 |             ):
401 |                 if self._error_type == "auth":
    |

ARG002 Unused method argument: `kwargs`
   --> tests\unit\test_base_ai_provider.py:399:19
    |
397 |                 temperature=None,
398 |                 max_tokens=None,
399 |                 **kwargs,
    |                   ^^^^^^
400 |             ):
401 |                 if self._error_type == "auth":
    |

TRY003 Avoid specifying long messages outside the exception class
   --> tests\unit\test_base_ai_provider.py:402:27
    |
400 |             ):
401 |                 if self._error_type == "auth":
402 |                     raise APIAuthenticationError("Ошибка аутентификации", "error")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
403 |                 if self._error_type == "rate_limit":
404 |                     raise APIRateLimitError("Превышен лимит", "error")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\unit\test_base_ai_provider.py:402:50
    |
400 |             ):
401 |                 if self._error_type == "auth":
402 |                     raise APIAuthenticationError("Ошибка аутентификации", "error")
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^
403 |                 if self._error_type == "rate_limit":
404 |                     raise APIRateLimitError("Превышен лимит", "error")
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> tests\unit\test_base_ai_provider.py:404:27
    |
402 |                     raise APIAuthenticationError("Ошибка аутентификации", "error")
403 |                 if self._error_type == "rate_limit":
404 |                     raise APIRateLimitError("Превышен лимит", "error")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
405 |                 if self._error_type == "connection":
406 |                     raise APIConnectionError("Ошибка соединения", "error")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\unit\test_base_ai_provider.py:404:45
    |
402 |                     raise APIAuthenticationError("Ошибка аутентификации", "error")
403 |                 if self._error_type == "rate_limit":
404 |                     raise APIRateLimitError("Превышен лимит", "error")
    |                                             ^^^^^^^^^^^^^^^^
405 |                 if self._error_type == "connection":
406 |                     raise APIConnectionError("Ошибка соединения", "error")
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> tests\unit\test_base_ai_provider.py:406:27
    |
404 |                     raise APIRateLimitError("Превышен лимит", "error")
405 |                 if self._error_type == "connection":
406 |                     raise APIConnectionError("Ошибка соединения", "error")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
407 |                 if self._error_type == "quota":
408 |                     raise APIQuotaExceededError("Превышена квота", "error-provider")
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\unit\test_base_ai_provider.py:406:46
    |
404 |                     raise APIRateLimitError("Превышен лимит", "error")
405 |                 if self._error_type == "connection":
406 |                     raise APIConnectionError("Ошибка соединения", "error")
    |                                              ^^^^^^^^^^^^^^^^^^^
407 |                 if self._error_type == "quota":
408 |                     raise APIQuotaExceededError("Превышена квота", "error-provider")
    |
help: Assign to variable; remove string literal

TRY003 Avoid specifying long messages outside the exception class
   --> tests\unit\test_base_ai_provider.py:408:27
    |
406 |                     raise APIConnectionError("Ошибка соединения", "error")
407 |                 if self._error_type == "quota":
408 |                     raise APIQuotaExceededError("Превышена квота", "error-provider")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
409 |
410 |                 return AIResponse(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\unit\test_base_ai_provider.py:408:49
    |
406 |                     raise APIConnectionError("Ошибка соединения", "error")
407 |                 if self._error_type == "quota":
408 |                     raise APIQuotaExceededError("Превышена квота", "error-provider")
    |                                                 ^^^^^^^^^^^^^^^^^
409 |
410 |                 return AIResponse(
    |
help: Assign to variable; remove string literal

ANN202 Missing return type annotation for private function `is_configured`
   --> tests\unit\test_base_ai_provider.py:418:17
    |
416 |                 )
417 |
418 |             def is_configured(self):
    |                 ^^^^^^^^^^^^^
419 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `is_available`
   --> tests\unit\test_base_ai_provider.py:421:23
    |
419 |                 return True
420 |
421 |             async def is_available(self):
    |                       ^^^^^^^^^^^^
422 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `health_check`
   --> tests\unit\test_base_ai_provider.py:424:23
    |
422 |                 return True
423 |
424 |             async def health_check(self):
    |                       ^^^^^^^^^^^^
425 |                 return {"status": "healthy"}
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `close`
   --> tests\unit\test_base_ai_provider.py:427:23
    |
425 |                 return {"status": "healthy"}
426 |
427 |             async def close(self):
    |                       ^^^^^
428 |                 pass
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parameter_passing`
   --> tests\unit\test_base_ai_provider.py:461:15
    |
460 |     @pytest.mark.asyncio
461 |     async def test_parameter_passing(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^
462 |         """Тест передачи параметров в провайдер."""
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
   --> tests\unit\test_base_ai_provider.py:465:17
    |
464 |         class ParameterProvider(BaseAIProvider):
465 |             def __init__(self):
    |                 ^^^^^^^^
466 |                 self.name = "parameter-provider"
467 |                 self.last_params = {}
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `provider_name`
   --> tests\unit\test_base_ai_provider.py:470:17
    |
469 |             @property
470 |             def provider_name(self):
    |                 ^^^^^^^^^^^^^
471 |                 return "parameter-provider"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `generate_response`
   --> tests\unit\test_base_ai_provider.py:473:23
    |
471 |                 return "parameter-provider"
472 |
473 |             async def generate_response(
    |                       ^^^^^^^^^^^^^^^^^
474 |                 self,
475 |                 messages,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `messages`
   --> tests\unit\test_base_ai_provider.py:475:17
    |
473 |             async def generate_response(
474 |                 self,
475 |                 messages,
    |                 ^^^^^^^^
476 |                 temperature=None,
477 |                 max_tokens=None,
    |

ARG002 Unused method argument: `messages`
   --> tests\unit\test_base_ai_provider.py:475:17
    |
473 |             async def generate_response(
474 |                 self,
475 |                 messages,
    |                 ^^^^^^^^
476 |                 temperature=None,
477 |                 max_tokens=None,
    |

ANN001 Missing type annotation for function argument `temperature`
   --> tests\unit\test_base_ai_provider.py:476:17
    |
474 |                 self,
475 |                 messages,
476 |                 temperature=None,
    |                 ^^^^^^^^^^^
477 |                 max_tokens=None,
478 |                 **kwargs,
    |

ANN001 Missing type annotation for function argument `max_tokens`
   --> tests\unit\test_base_ai_provider.py:477:17
    |
475 |                 messages,
476 |                 temperature=None,
477 |                 max_tokens=None,
    |                 ^^^^^^^^^^
478 |                 **kwargs,
479 |             ):
    |

ANN003 Missing type annotation for `**kwargs`
   --> tests\unit\test_base_ai_provider.py:478:17
    |
476 |                 temperature=None,
477 |                 max_tokens=None,
478 |                 **kwargs,
    |                 ^^^^^^^^
479 |             ):
480 |                 self.last_params = {
    |

ANN202 Missing return type annotation for private function `is_configured`
   --> tests\unit\test_base_ai_provider.py:494:17
    |
492 |                 )
493 |
494 |             def is_configured(self):
    |                 ^^^^^^^^^^^^^
495 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `is_available`
   --> tests\unit\test_base_ai_provider.py:497:23
    |
495 |                 return True
496 |
497 |             async def is_available(self):
    |                       ^^^^^^^^^^^^
498 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `health_check`
   --> tests\unit\test_base_ai_provider.py:500:23
    |
498 |                 return True
499 |
500 |             async def health_check(self):
    |                       ^^^^^^^^^^^^
501 |                 return {"status": "healthy"}
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `close`
   --> tests\unit\test_base_ai_provider.py:503:23
    |
501 |                 return {"status": "healthy"}
502 |
503 |             async def close(self):
    |                       ^^^^^
504 |                 pass
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_provider_context_manager`
   --> tests\unit\test_base_ai_provider.py:535:15
    |
534 |     @pytest.mark.asyncio
535 |     async def test_provider_context_manager(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
536 |         """Тест использования провайдера как async context manager."""
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__init__`
   --> tests\unit\test_base_ai_provider.py:539:17
    |
538 |         class ContextProvider(BaseAIProvider):
539 |             def __init__(self):
    |                 ^^^^^^^^
540 |                 self.name = "context-provider"
541 |                 self.closed = False
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `provider_name`
   --> tests\unit\test_base_ai_provider.py:544:17
    |
543 |             @property
544 |             def provider_name(self):
    |                 ^^^^^^^^^^^^^
545 |                 return "context-provider"
    |
help: Add return type annotation: `str`

ANN202 Missing return type annotation for private function `generate_response`
   --> tests\unit\test_base_ai_provider.py:547:23
    |
545 |                 return "context-provider"
546 |
547 |             async def generate_response(
    |                       ^^^^^^^^^^^^^^^^^
548 |                 self,
549 |                 messages,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `messages`
   --> tests\unit\test_base_ai_provider.py:549:17
    |
547 |             async def generate_response(
548 |                 self,
549 |                 messages,
    |                 ^^^^^^^^
550 |                 temperature=None,
551 |                 max_tokens=None,
    |

ARG002 Unused method argument: `messages`
   --> tests\unit\test_base_ai_provider.py:549:17
    |
547 |             async def generate_response(
548 |                 self,
549 |                 messages,
    |                 ^^^^^^^^
550 |                 temperature=None,
551 |                 max_tokens=None,
    |

ANN001 Missing type annotation for function argument `temperature`
   --> tests\unit\test_base_ai_provider.py:550:17
    |
548 |                 self,
549 |                 messages,
550 |                 temperature=None,
    |                 ^^^^^^^^^^^
551 |                 max_tokens=None,
552 |                 **kwargs,
    |

ARG002 Unused method argument: `temperature`
   --> tests\unit\test_base_ai_provider.py:550:17
    |
548 |                 self,
549 |                 messages,
550 |                 temperature=None,
    |                 ^^^^^^^^^^^
551 |                 max_tokens=None,
552 |                 **kwargs,
    |

ANN001 Missing type annotation for function argument `max_tokens`
   --> tests\unit\test_base_ai_provider.py:551:17
    |
549 |                 messages,
550 |                 temperature=None,
551 |                 max_tokens=None,
    |                 ^^^^^^^^^^
552 |                 **kwargs,
553 |             ):
    |

ARG002 Unused method argument: `max_tokens`
   --> tests\unit\test_base_ai_provider.py:551:17
    |
549 |                 messages,
550 |                 temperature=None,
551 |                 max_tokens=None,
    |                 ^^^^^^^^^^
552 |                 **kwargs,
553 |             ):
    |

ANN003 Missing type annotation for `**kwargs`
   --> tests\unit\test_base_ai_provider.py:552:17
    |
550 |                 temperature=None,
551 |                 max_tokens=None,
552 |                 **kwargs,
    |                 ^^^^^^^^
553 |             ):
554 |                 if self.closed:
    |

ARG002 Unused method argument: `kwargs`
   --> tests\unit\test_base_ai_provider.py:552:19
    |
550 |                 temperature=None,
551 |                 max_tokens=None,
552 |                 **kwargs,
    |                   ^^^^^^
553 |             ):
554 |                 if self.closed:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> tests\unit\test_base_ai_provider.py:555:27
    |
553 |             ):
554 |                 if self.closed:
555 |                     raise APIConnectionError("Провайдер закрыт", "context")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
556 |
557 |                 return AIResponse(
    |

EM101 Exception must not use a string literal, assign to variable first
   --> tests\unit\test_base_ai_provider.py:555:46
    |
553 |             ):
554 |                 if self.closed:
555 |                     raise APIConnectionError("Провайдер закрыт", "context")
    |                                              ^^^^^^^^^^^^^^^^^^
556 |
557 |                 return AIResponse(
    |
help: Assign to variable; remove string literal

ANN202 Missing return type annotation for private function `is_configured`
   --> tests\unit\test_base_ai_provider.py:565:17
    |
563 |                 )
564 |
565 |             def is_configured(self):
    |                 ^^^^^^^^^^^^^
566 |                 return True
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `is_available`
   --> tests\unit\test_base_ai_provider.py:568:23
    |
566 |                 return True
567 |
568 |             async def is_available(self):
    |                       ^^^^^^^^^^^^
569 |                 return not self.closed
    |
help: Add return type annotation: `bool`

ANN202 Missing return type annotation for private function `health_check`
   --> tests\unit\test_base_ai_provider.py:571:23
    |
569 |                 return not self.closed
570 |
571 |             async def health_check(self):
    |                       ^^^^^^^^^^^^
572 |                 return {"status": "healthy" if not self.closed else "unhealthy"}
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `close`
   --> tests\unit\test_base_ai_provider.py:574:23
    |
572 |                 return {"status": "healthy" if not self.closed else "unhealthy"}
573 |
574 |             async def close(self):
    |                       ^^^^^
575 |                 self.closed = True
    |
help: Add return type annotation: `None`

ANN204 Missing return type annotation for special method `__aenter__`
   --> tests\unit\test_base_ai_provider.py:577:23
    |
575 |                 self.closed = True
576 |
577 |             async def __aenter__(self):
    |                       ^^^^^^^^^^
578 |                 return self
    |
help: Add return type annotation

ANN204 Missing return type annotation for special method `__aexit__`
   --> tests\unit\test_base_ai_provider.py:580:23
    |
578 |                 return self
579 |
580 |             async def __aexit__(self, exc_type, exc_val, exc_tb):
    |                       ^^^^^^^^^
581 |                 await self.close()
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `exc_type`
   --> tests\unit\test_base_ai_provider.py:580:39
    |
578 |                 return self
579 |
580 |             async def __aexit__(self, exc_type, exc_val, exc_tb):
    |                                       ^^^^^^^^
581 |                 await self.close()
    |

ANN001 Missing type annotation for function argument `exc_val`
   --> tests\unit\test_base_ai_provider.py:580:49
    |
578 |                 return self
579 |
580 |             async def __aexit__(self, exc_type, exc_val, exc_tb):
    |                                                 ^^^^^^^
581 |                 await self.close()
    |

ANN001 Missing type annotation for function argument `exc_tb`
   --> tests\unit\test_base_ai_provider.py:580:58
    |
578 |                 return self
579 |
580 |             async def __aexit__(self, exc_type, exc_val, exc_tb):
    |                                                          ^^^^^^
581 |                 await self.close()
    |

E402 Module level import not at top of file
  --> tests\unit\test_config.py:20:1
   |
19 | # Настраиваем логирование для тестов
20 | from app.utils.logging import setup_logging
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |
22 | setup_logging(
   |

ANN201 Missing return type annotation for public function `test_telegram_config_validation`
  --> tests\unit\test_config.py:33:9
   |
31 |     """Тесты валидации конфигурации."""
32 |
33 |     def test_telegram_config_validation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |         """Тест валидации TelegramConfig."""
35 |         from app.config import TelegramConfig
   |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
  --> tests\unit\test_config.py:35:9
   |
33 |     def test_telegram_config_validation(self):
34 |         """Тест валидации TelegramConfig."""
35 |         from app.config import TelegramConfig
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |
37 |         # Тест с невалидным токеном (пустой)
   |

S106 Possible hardcoded password assigned to argument: "BOT_TOKEN"
  --> tests\unit\test_config.py:41:28
   |
39 |             ValueError, match="BOT_TOKEN must be set to a valid Telegram bot token"
40 |         ):
41 |             TelegramConfig(BOT_TOKEN="your_telegram_bot_token_here")
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |
43 |         # Тест с невалидным токеном (без двоеточия)
   |

S106 Possible hardcoded password assigned to argument: "BOT_TOKEN"
  --> tests\unit\test_config.py:47:28
   |
45 |             ValueError, match="BOT_TOKEN must be in format 'number:hash'"
46 |         ):
47 |             TelegramConfig(BOT_TOKEN="invalid_token")
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^
48 |
49 |         # Тест с валидным токеном
   |

S106 Possible hardcoded password assigned to argument: "BOT_TOKEN"
  --> tests\unit\test_config.py:50:33
   |
49 |         # Тест с валидным токеном
50 |         config = TelegramConfig(BOT_TOKEN="123456789:ABCdefGHIjklMNOpqrsTUVwxyz")
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |         assert config.bot_token is not None
52 |         logger.success("✅ Валидация TelegramConfig работает")
   |

ANN201 Missing return type annotation for public function `test_deepseek_config_validation`
  --> tests\unit\test_config.py:54:9
   |
52 |         logger.success("✅ Валидация TelegramConfig работает")
53 |
54 |     def test_deepseek_config_validation(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |         """Тест валидации DeepSeekConfig."""
56 |         from app.config import DeepSeekConfig
   |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
  --> tests\unit\test_config.py:56:9
   |
54 |     def test_deepseek_config_validation(self):
55 |         """Тест валидации DeepSeekConfig."""
56 |         from app.config import DeepSeekConfig
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |
58 |         # Тест с невалидным API ключом (placeholder)
   |

ANN201 Missing return type annotation for public function `test_database_config_url_building`
  --> tests\unit\test_config.py:85:9
   |
83 |         logger.success("✅ Валидация DeepSeekConfig работает")
84 |
85 |     def test_database_config_url_building(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |         """Тест построения URL базы данных."""
87 |         from app.config import DatabaseConfig
   |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
  --> tests\unit\test_config.py:87:9
   |
85 |     def test_database_config_url_building(self):
86 |         """Тест построения URL базы данных."""
87 |         from app.config import DatabaseConfig
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |
89 |         config = DatabaseConfig(
   |

S106 Possible hardcoded password assigned to argument: "DATABASE_PASSWORD"
  --> tests\unit\test_config.py:94:13
   |
92 |             DATABASE_NAME="test_db",
93 |             DATABASE_USER="test_user",
94 |             DATABASE_PASSWORD="test_password",
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
95 |         )
   |

ANN201 Missing return type annotation for public function `test_user_limits_validation`
   --> tests\unit\test_config.py:103:9
    |
101 |         logger.success("✅ Построение URL БД работает корректно")
102 |
103 |     def test_user_limits_validation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
104 |         """Тест валидации UserLimitsConfig."""
105 |         from app.config import UserLimitsConfig
    |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:105:9
    |
103 |     def test_user_limits_validation(self):
104 |         """Тест валидации UserLimitsConfig."""
105 |         from app.config import UserLimitsConfig
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |
107 |         # Тест с отрицательным лимитом
    |

B017 Do not assert blind exception: `Exception`
   --> tests\unit\test_config.py:108:14
    |
107 |         # Тест с отрицательным лимитом
108 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
109 |             UserLimitsConfig(FREE_MESSAGES_LIMIT=-1)
    |

PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\unit\test_config.py:108:28
    |
107 |         # Тест с отрицательным лимитом
108 |         with pytest.raises(Exception):
    |                            ^^^^^^^^^
109 |             UserLimitsConfig(FREE_MESSAGES_LIMIT=-1)
    |

B017 Do not assert blind exception: `Exception`
   --> tests\unit\test_config.py:112:14
    |
111 |         # Тест с нулевой ценой
112 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
113 |             UserLimitsConfig(PREMIUM_PRICE=0)
    |

PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\unit\test_config.py:112:28
    |
111 |         # Тест с нулевой ценой
112 |         with pytest.raises(Exception):
    |                            ^^^^^^^^^
113 |             UserLimitsConfig(PREMIUM_PRICE=0)
    |

ANN201 Missing return type annotation for public function `test_admin_config_validation`
   --> tests\unit\test_config.py:125:9
    |
123 |         logger.success("✅ Валидация UserLimitsConfig работает")
124 |
125 |     def test_admin_config_validation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
126 |         """Тест валидации AdminConfig."""
127 |         from app.config import AdminConfig
    |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:127:9
    |
125 |     def test_admin_config_validation(self):
126 |         """Тест валидации AdminConfig."""
127 |         from app.config import AdminConfig
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |
129 |         # Тест с невалидным ID
    |

B017 Do not assert blind exception: `Exception`
   --> tests\unit\test_config.py:130:14
    |
129 |         # Тест с невалидным ID
130 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
131 |             AdminConfig(ADMIN_USER_ID=0)
    |

PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\unit\test_config.py:130:28
    |
129 |         # Тест с невалидным ID
130 |         with pytest.raises(Exception):
    |                            ^^^^^^^^^
131 |             AdminConfig(ADMIN_USER_ID=0)
    |

ANN201 Missing return type annotation for public function `test_config_loading_without_env_file`
   --> tests\unit\test_config.py:152:9
    |
151 |     @pytest.mark.skip(reason="Temporarily disabled due to commit issues")
152 |     def test_config_loading_without_env_file(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153 |         """Тест загрузки конфигурации без .env файла."""
154 |         from app.config import get_config
    |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:154:9
    |
152 |     def test_config_loading_without_env_file(self):
153 |         """Тест загрузки конфигурации без .env файла."""
154 |         from app.config import get_config
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
155 |
156 |         # Без .env файла должна быть ошибка валидации
    |

B017 Do not assert blind exception: `Exception`
   --> tests\unit\test_config.py:157:14
    |
156 |         # Без .env файла должна быть ошибка валидации
157 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
158 |             config = get_config()
    |

PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\unit\test_config.py:157:28
    |
156 |         # Без .env файла должна быть ошибка валидации
157 |         with pytest.raises(Exception):
    |                            ^^^^^^^^^
158 |             config = get_config()
    |

F841 Local variable `config` is assigned to but never used
   --> tests\unit\test_config.py:158:13
    |
156 |         # Без .env файла должна быть ошибка валидации
157 |         with pytest.raises(Exception):
158 |             config = get_config()
    |             ^^^^^^
159 |
160 |         logger.success("✅ Валидация обязательных полей работает")
    |
help: Remove assignment to unused variable `config`

ANN201 Missing return type annotation for public function `test_config_loading_with_env_file`
   --> tests\unit\test_config.py:173:9
    |
171 | """,
172 |     )
173 |     def test_config_loading_with_env_file(self, mock_exists, mock_open):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 |         """Тест загрузки конфигурации с .env файлом."""
175 |         mock_exists.return_value = True
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mock_exists`
   --> tests\unit\test_config.py:173:49
    |
171 | """,
172 |     )
173 |     def test_config_loading_with_env_file(self, mock_exists, mock_open):
    |                                                 ^^^^^^^^^^^
174 |         """Тест загрузки конфигурации с .env файлом."""
175 |         mock_exists.return_value = True
    |

ANN001 Missing type annotation for function argument `mock_open`
   --> tests\unit\test_config.py:173:62
    |
171 | """,
172 |     )
173 |     def test_config_loading_with_env_file(self, mock_exists, mock_open):
    |                                                              ^^^^^^^^^
174 |         """Тест загрузки конфигурации с .env файлом."""
175 |         mock_exists.return_value = True
    |

ARG002 Unused method argument: `mock_open`
   --> tests\unit\test_config.py:173:62
    |
171 | """,
172 |     )
173 |     def test_config_loading_with_env_file(self, mock_exists, mock_open):
    |                                                              ^^^^^^^^^
174 |         """Тест загрузки конфигурации с .env файлом."""
175 |         mock_exists.return_value = True
    |

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:178:9
    |
177 |         # Сбрасываем кеш конфигурации
178 |         import app.config
    |         ^^^^^^^^^^^^^^^^^
179 |
180 |         app.config._config_instance = None
    |

SLF001 Private member accessed: `_config_instance`
   --> tests\unit\test_config.py:180:9
    |
178 |         import app.config
179 |
180 |         app.config._config_instance = None
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
181 |
182 |         try:
    |

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:183:13
    |
182 |         try:
183 |             from app.config import get_config
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
184 |
185 |             config = get_config()
    |

S105 Possible hardcoded password assigned to: "bot_token"
   --> tests\unit\test_config.py:187:49
    |
185 |             config = get_config()
186 |
187 |             assert config.telegram.bot_token == "123456789:ABCdefGHIjklMNOpqrsTUVwxyz"
    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
188 |             assert config.deepseek.deepseek_api_key == "sk-test123456789"
189 |             assert config.secret_key == "test_secret_key_with_32_characters_minimum"
    |

S105 Possible hardcoded password assigned to: "secret_key"
   --> tests\unit\test_config.py:189:41
    |
187 |             assert config.telegram.bot_token == "123456789:ABCdefGHIjklMNOpqrsTUVwxyz"
188 |             assert config.deepseek.deepseek_api_key == "sk-test123456789"
189 |             assert config.secret_key == "test_secret_key_with_32_characters_minimum"
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
190 |             assert config.admin.admin_user_id == 123456789
    |

ANN201 Missing return type annotation for public function `test_config_singleton_behavior`
   --> tests\unit\test_config.py:199:9
    |
198 |     @pytest.mark.skip(reason="Temporarily disabled due to commit issues")
199 |     def test_config_singleton_behavior(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
200 |         """Тест поведения синглтона для конфигурации."""
201 |         import app.config
    |
help: Add return type annotation: `None`

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:201:9
    |
199 |     def test_config_singleton_behavior(self):
200 |         """Тест поведения синглтона для конфигурации."""
201 |         import app.config
    |         ^^^^^^^^^^^^^^^^^
202 |
203 |         # Сбрасываем кеш
    |

SLF001 Private member accessed: `_config_instance`
   --> tests\unit\test_config.py:204:9
    |
203 |         # Сбрасываем кеш
204 |         app.config._config_instance = None
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
205 |
206 |         from app.config import get_config
    |

PLC0415 `import` should be at the top-level of a file
   --> tests\unit\test_config.py:206:9
    |
204 |         app.config._config_instance = None
205 |
206 |         from app.config import get_config
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
207 |
208 |         # При отсутствии .env файла должна быть ошибка
    |

B017 Do not assert blind exception: `Exception`
   --> tests\unit\test_config.py:209:14
    |
208 |         # При отсутствии .env файла должна быть ошибка
209 |         with pytest.raises(Exception):
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
210 |             config1 = get_config()
    |

PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   --> tests\unit\test_config.py:209:28
    |
208 |         # При отсутствии .env файла должна быть ошибка
209 |         with pytest.raises(Exception):
    |                            ^^^^^^^^^
210 |             config1 = get_config()
    |

F841 Local variable `config1` is assigned to but never used
   --> tests\unit\test_config.py:210:13
    |
208 |         # При отсутствии .env файла должна быть ошибка
209 |         with pytest.raises(Exception):
210 |             config1 = get_config()
    |             ^^^^^^^
211 |
212 |         logger.success("✅ Singleton поведение работает корректно")
    |
help: Remove assignment to unused variable `config1`

ANN201 Missing return type annotation for public function `test_env_example_completeness`
   --> tests\unit\test_config.py:218:9
    |
216 |     """Тесты переменных окружения."""
217 |
218 |     def test_env_example_completeness(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |         """Проверка полноты .env.example файла."""
220 |         env_example = project_root / ".env.example"
    |
help: Add return type annotation: `None`

I001 [*] Import block is un-sorted or un-formatted
  --> tests\unit\test_models.py:8:1
   |
 6 |   """
 7 |
 8 | / from collections.abc import AsyncGenerator
 9 | | from datetime import date, datetime, timedelta
10 | |
11 | | import pytest
12 | | from sqlalchemy.ext.asyncio import AsyncSession
13 | |
14 | | from app.database import get_session
15 | | from app.models.conversation import (
16 | |     Conversation,
17 | |     ConversationCreate,
18 | |     ConversationResponse,
19 | |     ConversationUpdate,
20 | |     ConversationStatus,
21 | |     MessageRole,
22 | | )
23 | | from app.models.user import User, UserCreate, UserResponse, UserUpdate
   | |______________________________________________________________________^
   |
help: Organize imports

ANN201 Missing return type annotation for public function `test_user_data`
  --> tests\unit\test_models.py:31:9
   |
30 |     @pytest.fixture
31 |     def test_user_data(self):
   |         ^^^^^^^^^^^^^^
32 |         """Фикстура с тестовыми данными пользователя."""
33 |         return {
   |
help: Add return type annotation

DTZ011 `datetime.date.today()` used
  --> tests\unit\test_models.py:42:34
   |
40 |             "premium_expires_at": None,
41 |             "daily_message_count": 0,
42 |             "last_message_date": date.today(),
   |                                  ^^^^^^^^^^^^
43 |         }
   |
help: Use `datetime.datetime.now(tz=...).date()` instead

ANN201 Missing return type annotation for public function `test_user_creation`
  --> tests\unit\test_models.py:45:9
   |
43 |         }
44 |
45 |     def test_user_creation(self, test_user_data):
   |         ^^^^^^^^^^^^^^^^^^
46 |         """Тест создания пользователя."""
47 |         user = User(**test_user_data)
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `test_user_data`
  --> tests\unit\test_models.py:45:34
   |
43 |         }
44 |
45 |     def test_user_creation(self, test_user_data):
   |                                  ^^^^^^^^^^^^^^
46 |         """Тест создания пользователя."""
47 |         user = User(**test_user_data)
   |

DTZ011 `datetime.date.today()` used
  --> tests\unit\test_models.py:57:42
   |
55 |         assert user.premium_expires_at is None
56 |         assert user.daily_message_count == 0
57 |         assert user.last_message_date == date.today()
   |                                          ^^^^^^^^^^^^
58 |
59 |     def test_user_defaults(self):
   |
help: Use `datetime.datetime.now(tz=...).date()` instead

ANN201 Missing return type annotation for public function `test_user_defaults`
  --> tests\unit\test_models.py:59:9
   |
57 |         assert user.last_message_date == date.today()
58 |
59 |     def test_user_defaults(self):
   |         ^^^^^^^^^^^^^^^^^^
60 |         """Тест значений по умолчанию для User."""
61 |         user = User(telegram_id=999999999)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_user_display_name_method`
  --> tests\unit\test_models.py:75:9
   |
73 |         assert user.last_activity_at is None
74 |
75 |     def test_user_display_name_method(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
76 |         """Тест метода get_display_name."""
77 |         # Пользователь с именем и фамилией
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_is_premium_active_method`
  --> tests\unit\test_models.py:93:9
   |
91 |         assert user4.get_display_name() == "User 4"
92 |
93 |     def test_is_premium_active_method(self):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 |         """Тест метода is_premium_active."""
95 |         # Пользователь без премиума
   |
help: Add return type annotation: `None`

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests\unit\test_models.py:103:32
    |
101 |             telegram_id=2,
102 |             is_premium=True,
103 |             premium_expires_at=datetime.now() + timedelta(days=10),
    |                                ^^^^^^^^^^^^^^
104 |         )
105 |         assert user2.is_premium_active() is True
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests\unit\test_models.py:111:32
    |
109 |             telegram_id=3,
110 |             is_premium=True,
111 |             premium_expires_at=datetime.now() - timedelta(days=1),
    |                                ^^^^^^^^^^^^^^
112 |         )
113 |         assert user3.is_premium_active() is False
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ANN201 Missing return type annotation for public function `test_can_send_message_method`
   --> tests\unit\test_models.py:119:9
    |
117 |         assert user4.is_premium_active() is True
118 |
119 |     def test_can_send_message_method(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
120 |         """Тест метода can_send_message."""
121 |         # Премиум пользователь
    |
help: Add return type annotation: `None`

DTZ011 `datetime.date.today()` used
   --> tests\unit\test_models.py:126:31
    |
124 |             is_premium=True,
125 |             daily_message_count=100,
126 |             last_message_date=date.today(),
    |                               ^^^^^^^^^^^^
127 |         )
128 |         assert premium_user.can_send_message() is True
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

DTZ011 `datetime.date.today()` used
   --> tests\unit\test_models.py:135:31
    |
133 |             is_premium=False,
134 |             daily_message_count=5,
135 |             last_message_date=date.today(),
    |                               ^^^^^^^^^^^^
136 |         )
137 |         assert regular_user.can_send_message() is True
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

DTZ011 `datetime.date.today()` used
   --> tests\unit\test_models.py:144:31
    |
142 |             is_premium=False,
143 |             daily_message_count=20,
144 |             last_message_date=date.today(),
    |                               ^^^^^^^^^^^^
145 |         )
146 |         assert limited_user.can_send_message() is False
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

ANN201 Missing return type annotation for public function `test_reset_daily_count_if_needed_method`
   --> tests\unit\test_models.py:148:9
    |
146 |         assert limited_user.can_send_message() is False
147 |
148 |     def test_reset_daily_count_if_needed_method(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |         """Тест метода reset_daily_count_if_needed."""
150 |         # Пользователь с сегодняшней датой
    |
help: Add return type annotation: `None`

DTZ011 `datetime.date.today()` used
   --> tests\unit\test_models.py:154:31
    |
152 |             telegram_id=1,
153 |             daily_message_count=5,
154 |             last_message_date=date.today(),
    |                               ^^^^^^^^^^^^
155 |         )
156 |         result1 = user1.reset_daily_count_if_needed()
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

DTZ011 `datetime.date.today()` used
   --> tests\unit\test_models.py:164:31
    |
162 |             telegram_id=2,
163 |             daily_message_count=10,
164 |             last_message_date=date.today() - timedelta(days=1),
    |                               ^^^^^^^^^^^^
165 |         )
166 |         result2 = user2.reset_daily_count_if_needed()
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

DTZ011 `datetime.date.today()` used
   --> tests\unit\test_models.py:169:43
    |
167 |         assert result2 is True  # Сброшен
168 |         assert user2.daily_message_count == 0
169 |         assert user2.last_message_date == date.today()
    |                                           ^^^^^^^^^^^^
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

ANN201 Missing return type annotation for public function `test_user_create_schema`
   --> tests\unit\test_models.py:176:9
    |
174 |     """Тесты для Pydantic схем User."""
175 |
176 |     def test_user_create_schema(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
177 |         """Тест схемы UserCreate."""
178 |         data = {
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_user_create_minimal`
   --> tests\unit\test_models.py:192:9
    |
190 |         assert user_create.language_code == "en"
191 |
192 |     def test_user_create_minimal(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
193 |         """Тест минимальной схемы UserCreate."""
194 |         user_create = UserCreate(telegram_id=999999999)
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_user_update_schema`
   --> tests\unit\test_models.py:201:9
    |
199 |         assert user_create.language_code == "ru"  # Значение по умолчанию
200 |
201 |     def test_user_update_schema(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
202 |         """Тест схемы UserUpdate."""
203 |         data = {
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_user_response_schema`
   --> tests\unit\test_models.py:216:9
    |
214 |         assert user_update.last_name is None  # Не указано
215 |
216 |     def test_user_response_schema(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
217 |         """Тест схемы UserResponse."""
218 |         # Создаем User объект
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_data`
   --> tests\unit\test_models.py:242:9
    |
241 |     @pytest.fixture
242 |     def test_conversation_data(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^
243 |         """Фикстура с тестовыми данными диалога."""
244 |         return {
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `test_conversation_creation`
   --> tests\unit\test_models.py:253:9
    |
251 |         }
252 |
253 |     def test_conversation_creation(self, test_conversation_data):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
254 |         """Тест создания диалога."""
255 |         conversation = Conversation(**test_conversation_data)
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `test_conversation_data`
   --> tests\unit\test_models.py:253:42
    |
251 |         }
252 |
253 |     def test_conversation_creation(self, test_conversation_data):
    |                                          ^^^^^^^^^^^^^^^^^^^^^^
254 |         """Тест создания диалога."""
255 |         conversation = Conversation(**test_conversation_data)
    |

ANN201 Missing return type annotation for public function `test_conversation_with_ai_response`
   --> tests\unit\test_models.py:265:9
    |
263 |         assert isinstance(conversation.created_at, datetime)
264 |
265 |     def test_conversation_with_ai_response(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
266 |         """Тест создания диалога с ответом AI."""
267 |         conversation = Conversation(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_role_enum`
   --> tests\unit\test_models.py:282:9
    |
280 |         assert conversation.response_time_ms == 1500
281 |
282 |     def test_conversation_role_enum(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
283 |         """Тест enum для ролей сообщений."""
284 |         assert MessageRole.USER == "user"
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_content_validation`
   --> tests\unit\test_models.py:305:9
    |
303 |         assert system_msg.role == MessageRole.SYSTEM
304 |
305 |     def test_conversation_content_validation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
306 |         """Тест валидации содержимого сообщения."""
307 |         # Нормальное сообщение
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_create_schema`
   --> tests\unit\test_models.py:329:9
    |
327 |     """Тесты для Pydantic схем Conversation."""
328 |
329 |     def test_conversation_create_schema(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
330 |         """Тест схемы ConversationCreate."""
331 |         data = {
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_create_minimal`
   --> tests\unit\test_models.py:347:9
    |
345 |         assert conv_create.chat_id == 456
346 |
347 |     def test_conversation_create_minimal(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
348 |         """Тест минимальной схемы ConversationCreate."""
349 |         conv_create = ConversationCreate(
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_update_schema`
   --> tests\unit\test_models.py:360:9
    |
358 |         assert conv_create.chat_id is None
359 |
360 |     def test_conversation_update_schema(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
361 |         """Тест схемы ConversationUpdate."""
362 |         data = {
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_conversation_response_schema`
   --> tests\unit\test_models.py:377:15
    |
375 |         assert conv_update.response_time is None  # Не указано
376 |
377 |     async def test_conversation_response_schema(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
378 |         """Тест схемы ConversationResponse."""
379 |         # Создаем Conversation объект
    |
help: Add return type annotation: `None`

Found 1358 errors.
[*] 25 fixable with the `--fix` option (356 hidden fixes can be enabled with the `--unsafe-fixes` option).
